/*
Emby Server API

Explore the Emby Server API

API version: 4.1.1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package api

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


type LiveTvServiceAPI interface {

	/*
	DeleteLivetvChannelmappingoptions Method for DeleteLivetvChannelmappingoptions

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDeleteLivetvChannelmappingoptionsRequest
	*/
	DeleteLivetvChannelmappingoptions(ctx context.Context) ApiDeleteLivetvChannelmappingoptionsRequest

	// DeleteLivetvChannelmappingoptionsExecute executes the request
	DeleteLivetvChannelmappingoptionsExecute(r ApiDeleteLivetvChannelmappingoptionsRequest) (*http.Response, error)

	/*
	DeleteLivetvChannelmappings Method for DeleteLivetvChannelmappings

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDeleteLivetvChannelmappingsRequest
	*/
	DeleteLivetvChannelmappings(ctx context.Context) ApiDeleteLivetvChannelmappingsRequest

	// DeleteLivetvChannelmappingsExecute executes the request
	DeleteLivetvChannelmappingsExecute(r ApiDeleteLivetvChannelmappingsRequest) (*http.Response, error)

	/*
	DeleteLivetvListingproviders Deletes a listing provider

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDeleteLivetvListingprovidersRequest
	*/
	DeleteLivetvListingproviders(ctx context.Context) ApiDeleteLivetvListingprovidersRequest

	// DeleteLivetvListingprovidersExecute executes the request
	DeleteLivetvListingprovidersExecute(r ApiDeleteLivetvListingprovidersRequest) (*http.Response, error)

	/*
	DeleteLivetvRecordingsById Deletes a live tv recording

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Recording Id
	@return ApiDeleteLivetvRecordingsByIdRequest
	*/
	DeleteLivetvRecordingsById(ctx context.Context, id string) ApiDeleteLivetvRecordingsByIdRequest

	// DeleteLivetvRecordingsByIdExecute executes the request
	DeleteLivetvRecordingsByIdExecute(r ApiDeleteLivetvRecordingsByIdRequest) (*http.Response, error)

	/*
	DeleteLivetvSeriestimersById Cancels a live tv series timer

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Timer Id
	@return ApiDeleteLivetvSeriestimersByIdRequest
	*/
	DeleteLivetvSeriestimersById(ctx context.Context, id string) ApiDeleteLivetvSeriestimersByIdRequest

	// DeleteLivetvSeriestimersByIdExecute executes the request
	DeleteLivetvSeriestimersByIdExecute(r ApiDeleteLivetvSeriestimersByIdRequest) (*http.Response, error)

	/*
	DeleteLivetvTimersById Cancels a live tv timer

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Timer Id
	@return ApiDeleteLivetvTimersByIdRequest
	*/
	DeleteLivetvTimersById(ctx context.Context, id string) ApiDeleteLivetvTimersByIdRequest

	// DeleteLivetvTimersByIdExecute executes the request
	DeleteLivetvTimersByIdExecute(r ApiDeleteLivetvTimersByIdRequest) (*http.Response, error)

	/*
	DeleteLivetvTunerhosts Deletes a tuner host

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDeleteLivetvTunerhostsRequest
	*/
	DeleteLivetvTunerhosts(ctx context.Context) ApiDeleteLivetvTunerhostsRequest

	// DeleteLivetvTunerhostsExecute executes the request
	DeleteLivetvTunerhostsExecute(r ApiDeleteLivetvTunerhostsRequest) (*http.Response, error)

	/*
	GetLivetvChannelmappingoptions Method for GetLivetvChannelmappingoptions

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetLivetvChannelmappingoptionsRequest
	*/
	GetLivetvChannelmappingoptions(ctx context.Context) ApiGetLivetvChannelmappingoptionsRequest

	// GetLivetvChannelmappingoptionsExecute executes the request
	GetLivetvChannelmappingoptionsExecute(r ApiGetLivetvChannelmappingoptionsRequest) (*http.Response, error)

	/*
	GetLivetvChannelmappings Method for GetLivetvChannelmappings

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetLivetvChannelmappingsRequest
	*/
	GetLivetvChannelmappings(ctx context.Context) ApiGetLivetvChannelmappingsRequest

	// GetLivetvChannelmappingsExecute executes the request
	GetLivetvChannelmappingsExecute(r ApiGetLivetvChannelmappingsRequest) (*http.Response, error)

	/*
	GetLivetvChannels Gets available live tv channels.

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetLivetvChannelsRequest
	*/
	GetLivetvChannels(ctx context.Context) ApiGetLivetvChannelsRequest

	// GetLivetvChannelsExecute executes the request
	//  @return QueryResultBaseItemDto
	GetLivetvChannelsExecute(r ApiGetLivetvChannelsRequest) (*QueryResultBaseItemDto, *http.Response, error)

	/*
	GetLivetvChannelsById Gets a live tv channel

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Channel Id
	@return ApiGetLivetvChannelsByIdRequest
	*/
	GetLivetvChannelsById(ctx context.Context, id string) ApiGetLivetvChannelsByIdRequest

	// GetLivetvChannelsByIdExecute executes the request
	//  @return BaseItemDto
	GetLivetvChannelsByIdExecute(r ApiGetLivetvChannelsByIdRequest) (*BaseItemDto, *http.Response, error)

	/*
	GetLivetvGuideinfo Gets guide info

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetLivetvGuideinfoRequest
	*/
	GetLivetvGuideinfo(ctx context.Context) ApiGetLivetvGuideinfoRequest

	// GetLivetvGuideinfoExecute executes the request
	//  @return LiveTvGuideInfo
	GetLivetvGuideinfoExecute(r ApiGetLivetvGuideinfoRequest) (*LiveTvGuideInfo, *http.Response, error)

	/*
	GetLivetvInfo Gets available live tv services.

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetLivetvInfoRequest
	*/
	GetLivetvInfo(ctx context.Context) ApiGetLivetvInfoRequest

	// GetLivetvInfoExecute executes the request
	//  @return LiveTvLiveTvInfo
	GetLivetvInfoExecute(r ApiGetLivetvInfoRequest) (*LiveTvLiveTvInfo, *http.Response, error)

	/*
	GetLivetvListingproviders Gets current listing providers

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetLivetvListingprovidersRequest
	*/
	GetLivetvListingproviders(ctx context.Context) ApiGetLivetvListingprovidersRequest

	// GetLivetvListingprovidersExecute executes the request
	//  @return []LiveTvListingsProviderInfo
	GetLivetvListingprovidersExecute(r ApiGetLivetvListingprovidersRequest) ([]LiveTvListingsProviderInfo, *http.Response, error)

	/*
	GetLivetvListingprovidersAvailable Gets listing provider

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetLivetvListingprovidersAvailableRequest
	*/
	GetLivetvListingprovidersAvailable(ctx context.Context) ApiGetLivetvListingprovidersAvailableRequest

	// GetLivetvListingprovidersAvailableExecute executes the request
	//  @return []LiveTvListingProviderTypeInfo
	GetLivetvListingprovidersAvailableExecute(r ApiGetLivetvListingprovidersAvailableRequest) ([]LiveTvListingProviderTypeInfo, *http.Response, error)

	/*
	GetLivetvListingprovidersDefault Method for GetLivetvListingprovidersDefault

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetLivetvListingprovidersDefaultRequest
	*/
	GetLivetvListingprovidersDefault(ctx context.Context) ApiGetLivetvListingprovidersDefaultRequest

	// GetLivetvListingprovidersDefaultExecute executes the request
	//  @return LiveTvListingsProviderInfo
	GetLivetvListingprovidersDefaultExecute(r ApiGetLivetvListingprovidersDefaultRequest) (*LiveTvListingsProviderInfo, *http.Response, error)

	/*
	GetLivetvListingprovidersLineups Gets available lineups

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetLivetvListingprovidersLineupsRequest
	*/
	GetLivetvListingprovidersLineups(ctx context.Context) ApiGetLivetvListingprovidersLineupsRequest

	// GetLivetvListingprovidersLineupsExecute executes the request
	//  @return []NameIdPair
	GetLivetvListingprovidersLineupsExecute(r ApiGetLivetvListingprovidersLineupsRequest) ([]NameIdPair, *http.Response, error)

	/*
	GetLivetvListingprovidersSchedulesdirectCountries Gets available lineups

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetLivetvListingprovidersSchedulesdirectCountriesRequest
	*/
	GetLivetvListingprovidersSchedulesdirectCountries(ctx context.Context) ApiGetLivetvListingprovidersSchedulesdirectCountriesRequest

	// GetLivetvListingprovidersSchedulesdirectCountriesExecute executes the request
	GetLivetvListingprovidersSchedulesdirectCountriesExecute(r ApiGetLivetvListingprovidersSchedulesdirectCountriesRequest) (*http.Response, error)

	/*
	GetLivetvLiverecordingsByIdStream Gets a live tv channel

	No authentication required

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiGetLivetvLiverecordingsByIdStreamRequest
	*/
	GetLivetvLiverecordingsByIdStream(ctx context.Context, id string) ApiGetLivetvLiverecordingsByIdStreamRequest

	// GetLivetvLiverecordingsByIdStreamExecute executes the request
	GetLivetvLiverecordingsByIdStreamExecute(r ApiGetLivetvLiverecordingsByIdStreamRequest) (*http.Response, error)

	/*
	GetLivetvLivestreamfilesByIdByContainer Gets a live tv channel

	No authentication required

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@param container
	@return ApiGetLivetvLivestreamfilesByIdByContainerRequest
	*/
	GetLivetvLivestreamfilesByIdByContainer(ctx context.Context, id string, container string) ApiGetLivetvLivestreamfilesByIdByContainerRequest

	// GetLivetvLivestreamfilesByIdByContainerExecute executes the request
	GetLivetvLivestreamfilesByIdByContainerExecute(r ApiGetLivetvLivestreamfilesByIdByContainerRequest) (*http.Response, error)

	/*
	GetLivetvPrograms Gets available live tv epgs..

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetLivetvProgramsRequest
	*/
	GetLivetvPrograms(ctx context.Context) ApiGetLivetvProgramsRequest

	// GetLivetvProgramsExecute executes the request
	//  @return QueryResultBaseItemDto
	GetLivetvProgramsExecute(r ApiGetLivetvProgramsRequest) (*QueryResultBaseItemDto, *http.Response, error)

	/*
	GetLivetvProgramsRecommended Gets available live tv epgs..

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetLivetvProgramsRecommendedRequest
	*/
	GetLivetvProgramsRecommended(ctx context.Context) ApiGetLivetvProgramsRecommendedRequest

	// GetLivetvProgramsRecommendedExecute executes the request
	//  @return QueryResultBaseItemDto
	GetLivetvProgramsRecommendedExecute(r ApiGetLivetvProgramsRecommendedRequest) (*QueryResultBaseItemDto, *http.Response, error)

	/*
	GetLivetvRecordings Gets live tv recordings

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetLivetvRecordingsRequest
	*/
	GetLivetvRecordings(ctx context.Context) ApiGetLivetvRecordingsRequest

	// GetLivetvRecordingsExecute executes the request
	GetLivetvRecordingsExecute(r ApiGetLivetvRecordingsRequest) (*http.Response, error)

	/*
	GetLivetvRecordingsById Gets a live tv recording

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Recording Id
	@return ApiGetLivetvRecordingsByIdRequest
	*/
	GetLivetvRecordingsById(ctx context.Context, id string) ApiGetLivetvRecordingsByIdRequest

	// GetLivetvRecordingsByIdExecute executes the request
	//  @return BaseItemDto
	GetLivetvRecordingsByIdExecute(r ApiGetLivetvRecordingsByIdRequest) (*BaseItemDto, *http.Response, error)

	/*
	GetLivetvRecordingsFolders Gets recording folders

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetLivetvRecordingsFoldersRequest
	*/
	GetLivetvRecordingsFolders(ctx context.Context) ApiGetLivetvRecordingsFoldersRequest

	// GetLivetvRecordingsFoldersExecute executes the request
	//  @return []BaseItemDto
	GetLivetvRecordingsFoldersExecute(r ApiGetLivetvRecordingsFoldersRequest) ([]BaseItemDto, *http.Response, error)

	/*
	GetLivetvRecordingsGroups Gets live tv recording groups

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetLivetvRecordingsGroupsRequest
	*/
	GetLivetvRecordingsGroups(ctx context.Context) ApiGetLivetvRecordingsGroupsRequest

	// GetLivetvRecordingsGroupsExecute executes the request
	//  @return QueryResultBaseItemDto
	GetLivetvRecordingsGroupsExecute(r ApiGetLivetvRecordingsGroupsRequest) (*QueryResultBaseItemDto, *http.Response, error)

	/*
	GetLivetvRecordingsGroupsById Gets a recording group

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Recording group Id
	@return ApiGetLivetvRecordingsGroupsByIdRequest
	*/
	GetLivetvRecordingsGroupsById(ctx context.Context, id string) ApiGetLivetvRecordingsGroupsByIdRequest

	// GetLivetvRecordingsGroupsByIdExecute executes the request
	//  @return BaseItemDto
	GetLivetvRecordingsGroupsByIdExecute(r ApiGetLivetvRecordingsGroupsByIdRequest) (*BaseItemDto, *http.Response, error)

	/*
	GetLivetvRecordingsSeries Gets live tv recordings

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetLivetvRecordingsSeriesRequest
	*/
	GetLivetvRecordingsSeries(ctx context.Context) ApiGetLivetvRecordingsSeriesRequest

	// GetLivetvRecordingsSeriesExecute executes the request
	//  @return QueryResultBaseItemDto
	GetLivetvRecordingsSeriesExecute(r ApiGetLivetvRecordingsSeriesRequest) (*QueryResultBaseItemDto, *http.Response, error)

	/*
	GetLivetvSeriestimers Gets live tv series timers

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetLivetvSeriestimersRequest
	*/
	GetLivetvSeriestimers(ctx context.Context) ApiGetLivetvSeriestimersRequest

	// GetLivetvSeriestimersExecute executes the request
	//  @return QueryResultLiveTvSeriesTimerInfoDto
	GetLivetvSeriestimersExecute(r ApiGetLivetvSeriestimersRequest) (*QueryResultLiveTvSeriesTimerInfoDto, *http.Response, error)

	/*
	GetLivetvSeriestimersById Gets a live tv series timer

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Timer Id
	@return ApiGetLivetvSeriestimersByIdRequest
	*/
	GetLivetvSeriestimersById(ctx context.Context, id string) ApiGetLivetvSeriestimersByIdRequest

	// GetLivetvSeriestimersByIdExecute executes the request
	//  @return LiveTvTimerInfoDto
	GetLivetvSeriestimersByIdExecute(r ApiGetLivetvSeriestimersByIdRequest) (*LiveTvTimerInfoDto, *http.Response, error)

	/*
	GetLivetvTimers Gets live tv timers

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetLivetvTimersRequest
	*/
	GetLivetvTimers(ctx context.Context) ApiGetLivetvTimersRequest

	// GetLivetvTimersExecute executes the request
	//  @return QueryResultLiveTvTimerInfoDto
	GetLivetvTimersExecute(r ApiGetLivetvTimersRequest) (*QueryResultLiveTvTimerInfoDto, *http.Response, error)

	/*
	GetLivetvTimersById Gets a live tv timer

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Timer Id
	@return ApiGetLivetvTimersByIdRequest
	*/
	GetLivetvTimersById(ctx context.Context, id string) ApiGetLivetvTimersByIdRequest

	// GetLivetvTimersByIdExecute executes the request
	//  @return LiveTvTimerInfoDto
	GetLivetvTimersByIdExecute(r ApiGetLivetvTimersByIdRequest) (*LiveTvTimerInfoDto, *http.Response, error)

	/*
	GetLivetvTimersDefaults Gets default values for a new timer

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetLivetvTimersDefaultsRequest
	*/
	GetLivetvTimersDefaults(ctx context.Context) ApiGetLivetvTimersDefaultsRequest

	// GetLivetvTimersDefaultsExecute executes the request
	//  @return LiveTvSeriesTimerInfoDto
	GetLivetvTimersDefaultsExecute(r ApiGetLivetvTimersDefaultsRequest) (*LiveTvSeriesTimerInfoDto, *http.Response, error)

	/*
	GetLivetvTunerhosts Gets tuner hosts

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetLivetvTunerhostsRequest
	*/
	GetLivetvTunerhosts(ctx context.Context) ApiGetLivetvTunerhostsRequest

	// GetLivetvTunerhostsExecute executes the request
	//  @return []LiveTvTunerHostInfo
	GetLivetvTunerhostsExecute(r ApiGetLivetvTunerhostsRequest) ([]LiveTvTunerHostInfo, *http.Response, error)

	/*
	GetLivetvTunerhostsTypes Method for GetLivetvTunerhostsTypes

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetLivetvTunerhostsTypesRequest
	*/
	GetLivetvTunerhostsTypes(ctx context.Context) ApiGetLivetvTunerhostsTypesRequest

	// GetLivetvTunerhostsTypesExecute executes the request
	//  @return []NameIdPair
	GetLivetvTunerhostsTypesExecute(r ApiGetLivetvTunerhostsTypesRequest) ([]NameIdPair, *http.Response, error)

	/*
	GetLivetvTunersDiscvover Method for GetLivetvTunersDiscvover

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetLivetvTunersDiscvoverRequest
	*/
	GetLivetvTunersDiscvover(ctx context.Context) ApiGetLivetvTunersDiscvoverRequest

	// GetLivetvTunersDiscvoverExecute executes the request
	//  @return []LiveTvTunerHostInfo
	GetLivetvTunersDiscvoverExecute(r ApiGetLivetvTunersDiscvoverRequest) ([]LiveTvTunerHostInfo, *http.Response, error)

	/*
	HeadLivetvChannelmappingoptions Method for HeadLivetvChannelmappingoptions

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiHeadLivetvChannelmappingoptionsRequest
	*/
	HeadLivetvChannelmappingoptions(ctx context.Context) ApiHeadLivetvChannelmappingoptionsRequest

	// HeadLivetvChannelmappingoptionsExecute executes the request
	HeadLivetvChannelmappingoptionsExecute(r ApiHeadLivetvChannelmappingoptionsRequest) (*http.Response, error)

	/*
	HeadLivetvChannelmappings Method for HeadLivetvChannelmappings

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiHeadLivetvChannelmappingsRequest
	*/
	HeadLivetvChannelmappings(ctx context.Context) ApiHeadLivetvChannelmappingsRequest

	// HeadLivetvChannelmappingsExecute executes the request
	HeadLivetvChannelmappingsExecute(r ApiHeadLivetvChannelmappingsRequest) (*http.Response, error)

	/*
	OptionsLivetvChannelmappingoptions Method for OptionsLivetvChannelmappingoptions

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiOptionsLivetvChannelmappingoptionsRequest
	*/
	OptionsLivetvChannelmappingoptions(ctx context.Context) ApiOptionsLivetvChannelmappingoptionsRequest

	// OptionsLivetvChannelmappingoptionsExecute executes the request
	OptionsLivetvChannelmappingoptionsExecute(r ApiOptionsLivetvChannelmappingoptionsRequest) (*http.Response, error)

	/*
	OptionsLivetvChannelmappings Method for OptionsLivetvChannelmappings

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiOptionsLivetvChannelmappingsRequest
	*/
	OptionsLivetvChannelmappings(ctx context.Context) ApiOptionsLivetvChannelmappingsRequest

	// OptionsLivetvChannelmappingsExecute executes the request
	OptionsLivetvChannelmappingsExecute(r ApiOptionsLivetvChannelmappingsRequest) (*http.Response, error)

	/*
	PatchLivetvChannelmappingoptions Method for PatchLivetvChannelmappingoptions

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPatchLivetvChannelmappingoptionsRequest
	*/
	PatchLivetvChannelmappingoptions(ctx context.Context) ApiPatchLivetvChannelmappingoptionsRequest

	// PatchLivetvChannelmappingoptionsExecute executes the request
	PatchLivetvChannelmappingoptionsExecute(r ApiPatchLivetvChannelmappingoptionsRequest) (*http.Response, error)

	/*
	PatchLivetvChannelmappings Method for PatchLivetvChannelmappings

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPatchLivetvChannelmappingsRequest
	*/
	PatchLivetvChannelmappings(ctx context.Context) ApiPatchLivetvChannelmappingsRequest

	// PatchLivetvChannelmappingsExecute executes the request
	PatchLivetvChannelmappingsExecute(r ApiPatchLivetvChannelmappingsRequest) (*http.Response, error)

	/*
	PostLivetvChannelmappingoptions Method for PostLivetvChannelmappingoptions

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostLivetvChannelmappingoptionsRequest
	*/
	PostLivetvChannelmappingoptions(ctx context.Context) ApiPostLivetvChannelmappingoptionsRequest

	// PostLivetvChannelmappingoptionsExecute executes the request
	PostLivetvChannelmappingoptionsExecute(r ApiPostLivetvChannelmappingoptionsRequest) (*http.Response, error)

	/*
	PostLivetvChannelmappings Method for PostLivetvChannelmappings

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostLivetvChannelmappingsRequest
	*/
	PostLivetvChannelmappings(ctx context.Context) ApiPostLivetvChannelmappingsRequest

	// PostLivetvChannelmappingsExecute executes the request
	PostLivetvChannelmappingsExecute(r ApiPostLivetvChannelmappingsRequest) (*http.Response, error)

	/*
	PostLivetvListingproviders Adds a listing provider

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostLivetvListingprovidersRequest
	*/
	PostLivetvListingproviders(ctx context.Context) ApiPostLivetvListingprovidersRequest

	// PostLivetvListingprovidersExecute executes the request
	//  @return LiveTvListingsProviderInfo
	PostLivetvListingprovidersExecute(r ApiPostLivetvListingprovidersRequest) (*LiveTvListingsProviderInfo, *http.Response, error)

	/*
	PostLivetvPrograms Gets available live tv epgs..

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostLivetvProgramsRequest
	*/
	PostLivetvPrograms(ctx context.Context) ApiPostLivetvProgramsRequest

	// PostLivetvProgramsExecute executes the request
	//  @return QueryResultBaseItemDto
	PostLivetvProgramsExecute(r ApiPostLivetvProgramsRequest) (*QueryResultBaseItemDto, *http.Response, error)

	/*
	PostLivetvSeriestimers Creates a live tv series timer

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostLivetvSeriestimersRequest
	*/
	PostLivetvSeriestimers(ctx context.Context) ApiPostLivetvSeriestimersRequest

	// PostLivetvSeriestimersExecute executes the request
	PostLivetvSeriestimersExecute(r ApiPostLivetvSeriestimersRequest) (*http.Response, error)

	/*
	PostLivetvSeriestimersById Updates a live tv series timer

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiPostLivetvSeriestimersByIdRequest
	*/
	PostLivetvSeriestimersById(ctx context.Context, id string) ApiPostLivetvSeriestimersByIdRequest

	// PostLivetvSeriestimersByIdExecute executes the request
	PostLivetvSeriestimersByIdExecute(r ApiPostLivetvSeriestimersByIdRequest) (*http.Response, error)

	/*
	PostLivetvTimers Creates a live tv timer

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostLivetvTimersRequest
	*/
	PostLivetvTimers(ctx context.Context) ApiPostLivetvTimersRequest

	// PostLivetvTimersExecute executes the request
	PostLivetvTimersExecute(r ApiPostLivetvTimersRequest) (*http.Response, error)

	/*
	PostLivetvTimersById Updates a live tv timer

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiPostLivetvTimersByIdRequest
	*/
	PostLivetvTimersById(ctx context.Context, id string) ApiPostLivetvTimersByIdRequest

	// PostLivetvTimersByIdExecute executes the request
	PostLivetvTimersByIdExecute(r ApiPostLivetvTimersByIdRequest) (*http.Response, error)

	/*
	PostLivetvTunerhosts Adds a tuner host

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostLivetvTunerhostsRequest
	*/
	PostLivetvTunerhosts(ctx context.Context) ApiPostLivetvTunerhostsRequest

	// PostLivetvTunerhostsExecute executes the request
	//  @return LiveTvTunerHostInfo
	PostLivetvTunerhostsExecute(r ApiPostLivetvTunerhostsRequest) (*LiveTvTunerHostInfo, *http.Response, error)

	/*
	PostLivetvTunersByIdReset Resets a tv tuner

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Tuner Id
	@return ApiPostLivetvTunersByIdResetRequest
	*/
	PostLivetvTunersByIdReset(ctx context.Context, id string) ApiPostLivetvTunersByIdResetRequest

	// PostLivetvTunersByIdResetExecute executes the request
	PostLivetvTunersByIdResetExecute(r ApiPostLivetvTunersByIdResetRequest) (*http.Response, error)

	/*
	PutLivetvChannelmappingoptions Method for PutLivetvChannelmappingoptions

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPutLivetvChannelmappingoptionsRequest
	*/
	PutLivetvChannelmappingoptions(ctx context.Context) ApiPutLivetvChannelmappingoptionsRequest

	// PutLivetvChannelmappingoptionsExecute executes the request
	PutLivetvChannelmappingoptionsExecute(r ApiPutLivetvChannelmappingoptionsRequest) (*http.Response, error)

	/*
	PutLivetvChannelmappings Method for PutLivetvChannelmappings

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPutLivetvChannelmappingsRequest
	*/
	PutLivetvChannelmappings(ctx context.Context) ApiPutLivetvChannelmappingsRequest

	// PutLivetvChannelmappingsExecute executes the request
	PutLivetvChannelmappingsExecute(r ApiPutLivetvChannelmappingsRequest) (*http.Response, error)

	/*
	TraceLivetvChannelmappingoptions Method for TraceLivetvChannelmappingoptions

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiTraceLivetvChannelmappingoptionsRequest
	*/
	TraceLivetvChannelmappingoptions(ctx context.Context) ApiTraceLivetvChannelmappingoptionsRequest

	// TraceLivetvChannelmappingoptionsExecute executes the request
	TraceLivetvChannelmappingoptionsExecute(r ApiTraceLivetvChannelmappingoptionsRequest) (*http.Response, error)

	/*
	TraceLivetvChannelmappings Method for TraceLivetvChannelmappings

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiTraceLivetvChannelmappingsRequest
	*/
	TraceLivetvChannelmappings(ctx context.Context) ApiTraceLivetvChannelmappingsRequest

	// TraceLivetvChannelmappingsExecute executes the request
	TraceLivetvChannelmappingsExecute(r ApiTraceLivetvChannelmappingsRequest) (*http.Response, error)
}

// LiveTvServiceAPIService LiveTvServiceAPI service
type LiveTvServiceAPIService service

type ApiDeleteLivetvChannelmappingoptionsRequest struct {
	ctx context.Context
	ApiService LiveTvServiceAPI
	providerId *string
}

// Provider id
func (r ApiDeleteLivetvChannelmappingoptionsRequest) ProviderId(providerId string) ApiDeleteLivetvChannelmappingoptionsRequest {
	r.providerId = &providerId
	return r
}

func (r ApiDeleteLivetvChannelmappingoptionsRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteLivetvChannelmappingoptionsExecute(r)
}

/*
DeleteLivetvChannelmappingoptions Method for DeleteLivetvChannelmappingoptions

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteLivetvChannelmappingoptionsRequest
*/
func (a *LiveTvServiceAPIService) DeleteLivetvChannelmappingoptions(ctx context.Context) ApiDeleteLivetvChannelmappingoptionsRequest {
	return ApiDeleteLivetvChannelmappingoptionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *LiveTvServiceAPIService) DeleteLivetvChannelmappingoptionsExecute(r ApiDeleteLivetvChannelmappingoptionsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.DeleteLivetvChannelmappingoptions")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/ChannelMappingOptions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.providerId == nil {
		return nil, reportError("providerId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "ProviderId", r.providerId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteLivetvChannelmappingsRequest struct {
	ctx context.Context
	ApiService LiveTvServiceAPI
	providerId *string
}

// Provider id
func (r ApiDeleteLivetvChannelmappingsRequest) ProviderId(providerId string) ApiDeleteLivetvChannelmappingsRequest {
	r.providerId = &providerId
	return r
}

func (r ApiDeleteLivetvChannelmappingsRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteLivetvChannelmappingsExecute(r)
}

/*
DeleteLivetvChannelmappings Method for DeleteLivetvChannelmappings

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteLivetvChannelmappingsRequest
*/
func (a *LiveTvServiceAPIService) DeleteLivetvChannelmappings(ctx context.Context) ApiDeleteLivetvChannelmappingsRequest {
	return ApiDeleteLivetvChannelmappingsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *LiveTvServiceAPIService) DeleteLivetvChannelmappingsExecute(r ApiDeleteLivetvChannelmappingsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.DeleteLivetvChannelmappings")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/ChannelMappings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.providerId == nil {
		return nil, reportError("providerId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "ProviderId", r.providerId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteLivetvListingprovidersRequest struct {
	ctx context.Context
	ApiService LiveTvServiceAPI
	id *string
}

// Provider id
func (r ApiDeleteLivetvListingprovidersRequest) Id(id string) ApiDeleteLivetvListingprovidersRequest {
	r.id = &id
	return r
}

func (r ApiDeleteLivetvListingprovidersRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteLivetvListingprovidersExecute(r)
}

/*
DeleteLivetvListingproviders Deletes a listing provider

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteLivetvListingprovidersRequest
*/
func (a *LiveTvServiceAPIService) DeleteLivetvListingproviders(ctx context.Context) ApiDeleteLivetvListingprovidersRequest {
	return ApiDeleteLivetvListingprovidersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *LiveTvServiceAPIService) DeleteLivetvListingprovidersExecute(r ApiDeleteLivetvListingprovidersRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.DeleteLivetvListingproviders")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/ListingProviders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Id", r.id, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteLivetvRecordingsByIdRequest struct {
	ctx context.Context
	ApiService LiveTvServiceAPI
	id string
}

func (r ApiDeleteLivetvRecordingsByIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteLivetvRecordingsByIdExecute(r)
}

/*
DeleteLivetvRecordingsById Deletes a live tv recording

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Recording Id
 @return ApiDeleteLivetvRecordingsByIdRequest
*/
func (a *LiveTvServiceAPIService) DeleteLivetvRecordingsById(ctx context.Context, id string) ApiDeleteLivetvRecordingsByIdRequest {
	return ApiDeleteLivetvRecordingsByIdRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *LiveTvServiceAPIService) DeleteLivetvRecordingsByIdExecute(r ApiDeleteLivetvRecordingsByIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.DeleteLivetvRecordingsById")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/Recordings/{Id}"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteLivetvSeriestimersByIdRequest struct {
	ctx context.Context
	ApiService LiveTvServiceAPI
	id string
}

func (r ApiDeleteLivetvSeriestimersByIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteLivetvSeriestimersByIdExecute(r)
}

/*
DeleteLivetvSeriestimersById Cancels a live tv series timer

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Timer Id
 @return ApiDeleteLivetvSeriestimersByIdRequest
*/
func (a *LiveTvServiceAPIService) DeleteLivetvSeriestimersById(ctx context.Context, id string) ApiDeleteLivetvSeriestimersByIdRequest {
	return ApiDeleteLivetvSeriestimersByIdRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *LiveTvServiceAPIService) DeleteLivetvSeriestimersByIdExecute(r ApiDeleteLivetvSeriestimersByIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.DeleteLivetvSeriestimersById")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/SeriesTimers/{Id}"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteLivetvTimersByIdRequest struct {
	ctx context.Context
	ApiService LiveTvServiceAPI
	id string
}

func (r ApiDeleteLivetvTimersByIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteLivetvTimersByIdExecute(r)
}

/*
DeleteLivetvTimersById Cancels a live tv timer

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Timer Id
 @return ApiDeleteLivetvTimersByIdRequest
*/
func (a *LiveTvServiceAPIService) DeleteLivetvTimersById(ctx context.Context, id string) ApiDeleteLivetvTimersByIdRequest {
	return ApiDeleteLivetvTimersByIdRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *LiveTvServiceAPIService) DeleteLivetvTimersByIdExecute(r ApiDeleteLivetvTimersByIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.DeleteLivetvTimersById")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/Timers/{Id}"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteLivetvTunerhostsRequest struct {
	ctx context.Context
	ApiService LiveTvServiceAPI
	id *string
}

// Tuner host id
func (r ApiDeleteLivetvTunerhostsRequest) Id(id string) ApiDeleteLivetvTunerhostsRequest {
	r.id = &id
	return r
}

func (r ApiDeleteLivetvTunerhostsRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteLivetvTunerhostsExecute(r)
}

/*
DeleteLivetvTunerhosts Deletes a tuner host

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteLivetvTunerhostsRequest
*/
func (a *LiveTvServiceAPIService) DeleteLivetvTunerhosts(ctx context.Context) ApiDeleteLivetvTunerhostsRequest {
	return ApiDeleteLivetvTunerhostsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *LiveTvServiceAPIService) DeleteLivetvTunerhostsExecute(r ApiDeleteLivetvTunerhostsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.DeleteLivetvTunerhosts")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/TunerHosts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Id", r.id, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetLivetvChannelmappingoptionsRequest struct {
	ctx context.Context
	ApiService LiveTvServiceAPI
	providerId *string
}

// Provider id
func (r ApiGetLivetvChannelmappingoptionsRequest) ProviderId(providerId string) ApiGetLivetvChannelmappingoptionsRequest {
	r.providerId = &providerId
	return r
}

func (r ApiGetLivetvChannelmappingoptionsRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetLivetvChannelmappingoptionsExecute(r)
}

/*
GetLivetvChannelmappingoptions Method for GetLivetvChannelmappingoptions

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetLivetvChannelmappingoptionsRequest
*/
func (a *LiveTvServiceAPIService) GetLivetvChannelmappingoptions(ctx context.Context) ApiGetLivetvChannelmappingoptionsRequest {
	return ApiGetLivetvChannelmappingoptionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *LiveTvServiceAPIService) GetLivetvChannelmappingoptionsExecute(r ApiGetLivetvChannelmappingoptionsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.GetLivetvChannelmappingoptions")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/ChannelMappingOptions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.providerId == nil {
		return nil, reportError("providerId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "ProviderId", r.providerId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetLivetvChannelmappingsRequest struct {
	ctx context.Context
	ApiService LiveTvServiceAPI
	providerId *string
}

// Provider id
func (r ApiGetLivetvChannelmappingsRequest) ProviderId(providerId string) ApiGetLivetvChannelmappingsRequest {
	r.providerId = &providerId
	return r
}

func (r ApiGetLivetvChannelmappingsRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetLivetvChannelmappingsExecute(r)
}

/*
GetLivetvChannelmappings Method for GetLivetvChannelmappings

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetLivetvChannelmappingsRequest
*/
func (a *LiveTvServiceAPIService) GetLivetvChannelmappings(ctx context.Context) ApiGetLivetvChannelmappingsRequest {
	return ApiGetLivetvChannelmappingsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *LiveTvServiceAPIService) GetLivetvChannelmappingsExecute(r ApiGetLivetvChannelmappingsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.GetLivetvChannelmappings")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/ChannelMappings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.providerId == nil {
		return nil, reportError("providerId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "ProviderId", r.providerId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetLivetvChannelsRequest struct {
	ctx context.Context
	ApiService LiveTvServiceAPI
	type_ *string
	userId *string
	startIndex *int32
	isMovie *bool
	isSeries *bool
	isNews *bool
	isKids *bool
	isSports *bool
	limit *int32
	isFavorite *bool
	isLiked *bool
	isDisliked *bool
	enableFavoriteSorting *bool
	enableImages *bool
	imageTypeLimit *int32
	enableImageTypes *string
	fields *string
	addCurrentProgram *bool
	enableUserData *bool
}

// Optional filter by channel type.
func (r ApiGetLivetvChannelsRequest) Type_(type_ string) ApiGetLivetvChannelsRequest {
	r.type_ = &type_
	return r
}

// Optional filter by user and attach user data.
func (r ApiGetLivetvChannelsRequest) UserId(userId string) ApiGetLivetvChannelsRequest {
	r.userId = &userId
	return r
}

// Optional. The record index to start at. All items with a lower index will be dropped from the results.
func (r ApiGetLivetvChannelsRequest) StartIndex(startIndex int32) ApiGetLivetvChannelsRequest {
	r.startIndex = &startIndex
	return r
}

// Optional filter for movies.
func (r ApiGetLivetvChannelsRequest) IsMovie(isMovie bool) ApiGetLivetvChannelsRequest {
	r.isMovie = &isMovie
	return r
}

// Optional filter for movies.
func (r ApiGetLivetvChannelsRequest) IsSeries(isSeries bool) ApiGetLivetvChannelsRequest {
	r.isSeries = &isSeries
	return r
}

// Optional filter for news.
func (r ApiGetLivetvChannelsRequest) IsNews(isNews bool) ApiGetLivetvChannelsRequest {
	r.isNews = &isNews
	return r
}

// Optional filter for kids.
func (r ApiGetLivetvChannelsRequest) IsKids(isKids bool) ApiGetLivetvChannelsRequest {
	r.isKids = &isKids
	return r
}

// Optional filter for sports.
func (r ApiGetLivetvChannelsRequest) IsSports(isSports bool) ApiGetLivetvChannelsRequest {
	r.isSports = &isSports
	return r
}

// Optional. The maximum number of records to return
func (r ApiGetLivetvChannelsRequest) Limit(limit int32) ApiGetLivetvChannelsRequest {
	r.limit = &limit
	return r
}

// Filter by channels that are favorites, or not.
func (r ApiGetLivetvChannelsRequest) IsFavorite(isFavorite bool) ApiGetLivetvChannelsRequest {
	r.isFavorite = &isFavorite
	return r
}

// Filter by channels that are liked, or not.
func (r ApiGetLivetvChannelsRequest) IsLiked(isLiked bool) ApiGetLivetvChannelsRequest {
	r.isLiked = &isLiked
	return r
}

// Filter by channels that are disliked, or not.
func (r ApiGetLivetvChannelsRequest) IsDisliked(isDisliked bool) ApiGetLivetvChannelsRequest {
	r.isDisliked = &isDisliked
	return r
}

// Incorporate favorite and like status into channel sorting.
func (r ApiGetLivetvChannelsRequest) EnableFavoriteSorting(enableFavoriteSorting bool) ApiGetLivetvChannelsRequest {
	r.enableFavoriteSorting = &enableFavoriteSorting
	return r
}

// Optional, include image information in output
func (r ApiGetLivetvChannelsRequest) EnableImages(enableImages bool) ApiGetLivetvChannelsRequest {
	r.enableImages = &enableImages
	return r
}

// Optional, the max number of images to return, per image type
func (r ApiGetLivetvChannelsRequest) ImageTypeLimit(imageTypeLimit int32) ApiGetLivetvChannelsRequest {
	r.imageTypeLimit = &imageTypeLimit
	return r
}

// Optional. The image types to include in the output.
func (r ApiGetLivetvChannelsRequest) EnableImageTypes(enableImageTypes string) ApiGetLivetvChannelsRequest {
	r.enableImageTypes = &enableImageTypes
	return r
}

// Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
func (r ApiGetLivetvChannelsRequest) Fields(fields string) ApiGetLivetvChannelsRequest {
	r.fields = &fields
	return r
}

// Optional. Adds current program info to each channel
func (r ApiGetLivetvChannelsRequest) AddCurrentProgram(addCurrentProgram bool) ApiGetLivetvChannelsRequest {
	r.addCurrentProgram = &addCurrentProgram
	return r
}

// Optional, include user data
func (r ApiGetLivetvChannelsRequest) EnableUserData(enableUserData bool) ApiGetLivetvChannelsRequest {
	r.enableUserData = &enableUserData
	return r
}

func (r ApiGetLivetvChannelsRequest) Execute() (*QueryResultBaseItemDto, *http.Response, error) {
	return r.ApiService.GetLivetvChannelsExecute(r)
}

/*
GetLivetvChannels Gets available live tv channels.

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetLivetvChannelsRequest
*/
func (a *LiveTvServiceAPIService) GetLivetvChannels(ctx context.Context) ApiGetLivetvChannelsRequest {
	return ApiGetLivetvChannelsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return QueryResultBaseItemDto
func (a *LiveTvServiceAPIService) GetLivetvChannelsExecute(r ApiGetLivetvChannelsRequest) (*QueryResultBaseItemDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QueryResultBaseItemDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.GetLivetvChannels")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/Channels"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Type", r.type_, "form", "")
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "UserId", r.userId, "form", "")
	}
	if r.startIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "StartIndex", r.startIndex, "form", "")
	}
	if r.isMovie != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsMovie", r.isMovie, "form", "")
	}
	if r.isSeries != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsSeries", r.isSeries, "form", "")
	}
	if r.isNews != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsNews", r.isNews, "form", "")
	}
	if r.isKids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsKids", r.isKids, "form", "")
	}
	if r.isSports != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsSports", r.isSports, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Limit", r.limit, "form", "")
	}
	if r.isFavorite != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsFavorite", r.isFavorite, "form", "")
	}
	if r.isLiked != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsLiked", r.isLiked, "form", "")
	}
	if r.isDisliked != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsDisliked", r.isDisliked, "form", "")
	}
	if r.enableFavoriteSorting != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableFavoriteSorting", r.enableFavoriteSorting, "form", "")
	}
	if r.enableImages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImages", r.enableImages, "form", "")
	}
	if r.imageTypeLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ImageTypeLimit", r.imageTypeLimit, "form", "")
	}
	if r.enableImageTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImageTypes", r.enableImageTypes, "form", "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Fields", r.fields, "form", "")
	}
	if r.addCurrentProgram != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AddCurrentProgram", r.addCurrentProgram, "form", "")
	}
	if r.enableUserData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableUserData", r.enableUserData, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetLivetvChannelsByIdRequest struct {
	ctx context.Context
	ApiService LiveTvServiceAPI
	id string
	userId *string
}

// Optional attach user data.
func (r ApiGetLivetvChannelsByIdRequest) UserId(userId string) ApiGetLivetvChannelsByIdRequest {
	r.userId = &userId
	return r
}

func (r ApiGetLivetvChannelsByIdRequest) Execute() (*BaseItemDto, *http.Response, error) {
	return r.ApiService.GetLivetvChannelsByIdExecute(r)
}

/*
GetLivetvChannelsById Gets a live tv channel

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Channel Id
 @return ApiGetLivetvChannelsByIdRequest
*/
func (a *LiveTvServiceAPIService) GetLivetvChannelsById(ctx context.Context, id string) ApiGetLivetvChannelsByIdRequest {
	return ApiGetLivetvChannelsByIdRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return BaseItemDto
func (a *LiveTvServiceAPIService) GetLivetvChannelsByIdExecute(r ApiGetLivetvChannelsByIdRequest) (*BaseItemDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BaseItemDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.GetLivetvChannelsById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/Channels/{Id}"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "UserId", r.userId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetLivetvGuideinfoRequest struct {
	ctx context.Context
	ApiService LiveTvServiceAPI
}

func (r ApiGetLivetvGuideinfoRequest) Execute() (*LiveTvGuideInfo, *http.Response, error) {
	return r.ApiService.GetLivetvGuideinfoExecute(r)
}

/*
GetLivetvGuideinfo Gets guide info

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetLivetvGuideinfoRequest
*/
func (a *LiveTvServiceAPIService) GetLivetvGuideinfo(ctx context.Context) ApiGetLivetvGuideinfoRequest {
	return ApiGetLivetvGuideinfoRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return LiveTvGuideInfo
func (a *LiveTvServiceAPIService) GetLivetvGuideinfoExecute(r ApiGetLivetvGuideinfoRequest) (*LiveTvGuideInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LiveTvGuideInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.GetLivetvGuideinfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/GuideInfo"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetLivetvInfoRequest struct {
	ctx context.Context
	ApiService LiveTvServiceAPI
}

func (r ApiGetLivetvInfoRequest) Execute() (*LiveTvLiveTvInfo, *http.Response, error) {
	return r.ApiService.GetLivetvInfoExecute(r)
}

/*
GetLivetvInfo Gets available live tv services.

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetLivetvInfoRequest
*/
func (a *LiveTvServiceAPIService) GetLivetvInfo(ctx context.Context) ApiGetLivetvInfoRequest {
	return ApiGetLivetvInfoRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return LiveTvLiveTvInfo
func (a *LiveTvServiceAPIService) GetLivetvInfoExecute(r ApiGetLivetvInfoRequest) (*LiveTvLiveTvInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LiveTvLiveTvInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.GetLivetvInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/Info"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetLivetvListingprovidersRequest struct {
	ctx context.Context
	ApiService LiveTvServiceAPI
}

func (r ApiGetLivetvListingprovidersRequest) Execute() ([]LiveTvListingsProviderInfo, *http.Response, error) {
	return r.ApiService.GetLivetvListingprovidersExecute(r)
}

/*
GetLivetvListingproviders Gets current listing providers

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetLivetvListingprovidersRequest
*/
func (a *LiveTvServiceAPIService) GetLivetvListingproviders(ctx context.Context) ApiGetLivetvListingprovidersRequest {
	return ApiGetLivetvListingprovidersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []LiveTvListingsProviderInfo
func (a *LiveTvServiceAPIService) GetLivetvListingprovidersExecute(r ApiGetLivetvListingprovidersRequest) ([]LiveTvListingsProviderInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []LiveTvListingsProviderInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.GetLivetvListingproviders")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/ListingProviders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetLivetvListingprovidersAvailableRequest struct {
	ctx context.Context
	ApiService LiveTvServiceAPI
}

func (r ApiGetLivetvListingprovidersAvailableRequest) Execute() ([]LiveTvListingProviderTypeInfo, *http.Response, error) {
	return r.ApiService.GetLivetvListingprovidersAvailableExecute(r)
}

/*
GetLivetvListingprovidersAvailable Gets listing provider

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetLivetvListingprovidersAvailableRequest
*/
func (a *LiveTvServiceAPIService) GetLivetvListingprovidersAvailable(ctx context.Context) ApiGetLivetvListingprovidersAvailableRequest {
	return ApiGetLivetvListingprovidersAvailableRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []LiveTvListingProviderTypeInfo
func (a *LiveTvServiceAPIService) GetLivetvListingprovidersAvailableExecute(r ApiGetLivetvListingprovidersAvailableRequest) ([]LiveTvListingProviderTypeInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []LiveTvListingProviderTypeInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.GetLivetvListingprovidersAvailable")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/ListingProviders/Available"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetLivetvListingprovidersDefaultRequest struct {
	ctx context.Context
	ApiService LiveTvServiceAPI
}

func (r ApiGetLivetvListingprovidersDefaultRequest) Execute() (*LiveTvListingsProviderInfo, *http.Response, error) {
	return r.ApiService.GetLivetvListingprovidersDefaultExecute(r)
}

/*
GetLivetvListingprovidersDefault Method for GetLivetvListingprovidersDefault

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetLivetvListingprovidersDefaultRequest
*/
func (a *LiveTvServiceAPIService) GetLivetvListingprovidersDefault(ctx context.Context) ApiGetLivetvListingprovidersDefaultRequest {
	return ApiGetLivetvListingprovidersDefaultRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return LiveTvListingsProviderInfo
func (a *LiveTvServiceAPIService) GetLivetvListingprovidersDefaultExecute(r ApiGetLivetvListingprovidersDefaultRequest) (*LiveTvListingsProviderInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LiveTvListingsProviderInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.GetLivetvListingprovidersDefault")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/ListingProviders/Default"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetLivetvListingprovidersLineupsRequest struct {
	ctx context.Context
	ApiService LiveTvServiceAPI
	id *string
	type_ *string
	location *string
	country *string
}

// Provider id
func (r ApiGetLivetvListingprovidersLineupsRequest) Id(id string) ApiGetLivetvListingprovidersLineupsRequest {
	r.id = &id
	return r
}

// Provider Type
func (r ApiGetLivetvListingprovidersLineupsRequest) Type_(type_ string) ApiGetLivetvListingprovidersLineupsRequest {
	r.type_ = &type_
	return r
}

// Location
func (r ApiGetLivetvListingprovidersLineupsRequest) Location(location string) ApiGetLivetvListingprovidersLineupsRequest {
	r.location = &location
	return r
}

// Country
func (r ApiGetLivetvListingprovidersLineupsRequest) Country(country string) ApiGetLivetvListingprovidersLineupsRequest {
	r.country = &country
	return r
}

func (r ApiGetLivetvListingprovidersLineupsRequest) Execute() ([]NameIdPair, *http.Response, error) {
	return r.ApiService.GetLivetvListingprovidersLineupsExecute(r)
}

/*
GetLivetvListingprovidersLineups Gets available lineups

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetLivetvListingprovidersLineupsRequest
*/
func (a *LiveTvServiceAPIService) GetLivetvListingprovidersLineups(ctx context.Context) ApiGetLivetvListingprovidersLineupsRequest {
	return ApiGetLivetvListingprovidersLineupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []NameIdPair
func (a *LiveTvServiceAPIService) GetLivetvListingprovidersLineupsExecute(r ApiGetLivetvListingprovidersLineupsRequest) ([]NameIdPair, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []NameIdPair
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.GetLivetvListingprovidersLineups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/ListingProviders/Lineups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Id", r.id, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Type", r.type_, "form", "")
	}
	if r.location != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Location", r.location, "form", "")
	}
	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Country", r.country, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetLivetvListingprovidersSchedulesdirectCountriesRequest struct {
	ctx context.Context
	ApiService LiveTvServiceAPI
}

func (r ApiGetLivetvListingprovidersSchedulesdirectCountriesRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetLivetvListingprovidersSchedulesdirectCountriesExecute(r)
}

/*
GetLivetvListingprovidersSchedulesdirectCountries Gets available lineups

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetLivetvListingprovidersSchedulesdirectCountriesRequest
*/
func (a *LiveTvServiceAPIService) GetLivetvListingprovidersSchedulesdirectCountries(ctx context.Context) ApiGetLivetvListingprovidersSchedulesdirectCountriesRequest {
	return ApiGetLivetvListingprovidersSchedulesdirectCountriesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *LiveTvServiceAPIService) GetLivetvListingprovidersSchedulesdirectCountriesExecute(r ApiGetLivetvListingprovidersSchedulesdirectCountriesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.GetLivetvListingprovidersSchedulesdirectCountries")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/ListingProviders/SchedulesDirect/Countries"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetLivetvLiverecordingsByIdStreamRequest struct {
	ctx context.Context
	ApiService LiveTvServiceAPI
	id string
}

func (r ApiGetLivetvLiverecordingsByIdStreamRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetLivetvLiverecordingsByIdStreamExecute(r)
}

/*
GetLivetvLiverecordingsByIdStream Gets a live tv channel

No authentication required

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiGetLivetvLiverecordingsByIdStreamRequest
*/
func (a *LiveTvServiceAPIService) GetLivetvLiverecordingsByIdStream(ctx context.Context, id string) ApiGetLivetvLiverecordingsByIdStreamRequest {
	return ApiGetLivetvLiverecordingsByIdStreamRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *LiveTvServiceAPIService) GetLivetvLiverecordingsByIdStreamExecute(r ApiGetLivetvLiverecordingsByIdStreamRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.GetLivetvLiverecordingsByIdStream")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/LiveRecordings/{Id}/stream"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetLivetvLivestreamfilesByIdByContainerRequest struct {
	ctx context.Context
	ApiService LiveTvServiceAPI
	id string
	container string
}

func (r ApiGetLivetvLivestreamfilesByIdByContainerRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetLivetvLivestreamfilesByIdByContainerExecute(r)
}

/*
GetLivetvLivestreamfilesByIdByContainer Gets a live tv channel

No authentication required

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @param container
 @return ApiGetLivetvLivestreamfilesByIdByContainerRequest
*/
func (a *LiveTvServiceAPIService) GetLivetvLivestreamfilesByIdByContainer(ctx context.Context, id string, container string) ApiGetLivetvLivestreamfilesByIdByContainerRequest {
	return ApiGetLivetvLivestreamfilesByIdByContainerRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		container: container,
	}
}

// Execute executes the request
func (a *LiveTvServiceAPIService) GetLivetvLivestreamfilesByIdByContainerExecute(r ApiGetLivetvLivestreamfilesByIdByContainerRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.GetLivetvLivestreamfilesByIdByContainer")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/LiveStreamFiles/{Id}/stream.{Container}"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Container"+"}", url.PathEscape(parameterValueToString(r.container, "container")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetLivetvProgramsRequest struct {
	ctx context.Context
	ApiService LiveTvServiceAPI
	channelIds *string
	userId *string
	minStartDate *string
	hasAired *bool
	maxStartDate *string
	minEndDate *string
	maxEndDate *string
	isMovie *bool
	isSeries *bool
	isNews *bool
	isKids *bool
	isSports *bool
	startIndex *int32
	limit *int32
	sortBy *string
	sortOrder *string
	genreIds *string
	enableImages *bool
	imageTypeLimit *int32
	enableImageTypes *string
	enableUserData *bool
	fields *string
}

// The channels to return guide information for.
func (r ApiGetLivetvProgramsRequest) ChannelIds(channelIds string) ApiGetLivetvProgramsRequest {
	r.channelIds = &channelIds
	return r
}

// Optional filter by user id.
func (r ApiGetLivetvProgramsRequest) UserId(userId string) ApiGetLivetvProgramsRequest {
	r.userId = &userId
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r ApiGetLivetvProgramsRequest) MinStartDate(minStartDate string) ApiGetLivetvProgramsRequest {
	r.minStartDate = &minStartDate
	return r
}

// Optional. Filter by programs that have completed airing, or not.
func (r ApiGetLivetvProgramsRequest) HasAired(hasAired bool) ApiGetLivetvProgramsRequest {
	r.hasAired = &hasAired
	return r
}

// Optional. The maximum premiere date. Format &#x3D; ISO
func (r ApiGetLivetvProgramsRequest) MaxStartDate(maxStartDate string) ApiGetLivetvProgramsRequest {
	r.maxStartDate = &maxStartDate
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r ApiGetLivetvProgramsRequest) MinEndDate(minEndDate string) ApiGetLivetvProgramsRequest {
	r.minEndDate = &minEndDate
	return r
}

// Optional. The maximum premiere date. Format &#x3D; ISO
func (r ApiGetLivetvProgramsRequest) MaxEndDate(maxEndDate string) ApiGetLivetvProgramsRequest {
	r.maxEndDate = &maxEndDate
	return r
}

// Optional filter for movies.
func (r ApiGetLivetvProgramsRequest) IsMovie(isMovie bool) ApiGetLivetvProgramsRequest {
	r.isMovie = &isMovie
	return r
}

// Optional filter for movies.
func (r ApiGetLivetvProgramsRequest) IsSeries(isSeries bool) ApiGetLivetvProgramsRequest {
	r.isSeries = &isSeries
	return r
}

// Optional filter for news.
func (r ApiGetLivetvProgramsRequest) IsNews(isNews bool) ApiGetLivetvProgramsRequest {
	r.isNews = &isNews
	return r
}

// Optional filter for kids.
func (r ApiGetLivetvProgramsRequest) IsKids(isKids bool) ApiGetLivetvProgramsRequest {
	r.isKids = &isKids
	return r
}

// Optional filter for sports.
func (r ApiGetLivetvProgramsRequest) IsSports(isSports bool) ApiGetLivetvProgramsRequest {
	r.isSports = &isSports
	return r
}

// Optional. The record index to start at. All items with a lower index will be dropped from the results.
func (r ApiGetLivetvProgramsRequest) StartIndex(startIndex int32) ApiGetLivetvProgramsRequest {
	r.startIndex = &startIndex
	return r
}

// Optional. The maximum number of records to return
func (r ApiGetLivetvProgramsRequest) Limit(limit int32) ApiGetLivetvProgramsRequest {
	r.limit = &limit
	return r
}

// Optional. Specify one or more sort orders, comma delimeted. Options: Name, StartDate
func (r ApiGetLivetvProgramsRequest) SortBy(sortBy string) ApiGetLivetvProgramsRequest {
	r.sortBy = &sortBy
	return r
}

// Sort Order - Ascending,Descending
func (r ApiGetLivetvProgramsRequest) SortOrder(sortOrder string) ApiGetLivetvProgramsRequest {
	r.sortOrder = &sortOrder
	return r
}

// The genres to return guide information for.
func (r ApiGetLivetvProgramsRequest) GenreIds(genreIds string) ApiGetLivetvProgramsRequest {
	r.genreIds = &genreIds
	return r
}

// Optional, include image information in output
func (r ApiGetLivetvProgramsRequest) EnableImages(enableImages bool) ApiGetLivetvProgramsRequest {
	r.enableImages = &enableImages
	return r
}

// Optional, the max number of images to return, per image type
func (r ApiGetLivetvProgramsRequest) ImageTypeLimit(imageTypeLimit int32) ApiGetLivetvProgramsRequest {
	r.imageTypeLimit = &imageTypeLimit
	return r
}

// Optional. The image types to include in the output.
func (r ApiGetLivetvProgramsRequest) EnableImageTypes(enableImageTypes string) ApiGetLivetvProgramsRequest {
	r.enableImageTypes = &enableImageTypes
	return r
}

// Optional, include user data
func (r ApiGetLivetvProgramsRequest) EnableUserData(enableUserData bool) ApiGetLivetvProgramsRequest {
	r.enableUserData = &enableUserData
	return r
}

// Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
func (r ApiGetLivetvProgramsRequest) Fields(fields string) ApiGetLivetvProgramsRequest {
	r.fields = &fields
	return r
}

func (r ApiGetLivetvProgramsRequest) Execute() (*QueryResultBaseItemDto, *http.Response, error) {
	return r.ApiService.GetLivetvProgramsExecute(r)
}

/*
GetLivetvPrograms Gets available live tv epgs..

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetLivetvProgramsRequest
*/
func (a *LiveTvServiceAPIService) GetLivetvPrograms(ctx context.Context) ApiGetLivetvProgramsRequest {
	return ApiGetLivetvProgramsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return QueryResultBaseItemDto
func (a *LiveTvServiceAPIService) GetLivetvProgramsExecute(r ApiGetLivetvProgramsRequest) (*QueryResultBaseItemDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QueryResultBaseItemDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.GetLivetvPrograms")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/Programs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.channelIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ChannelIds", r.channelIds, "form", "")
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "UserId", r.userId, "form", "")
	}
	if r.minStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinStartDate", r.minStartDate, "form", "")
	}
	if r.hasAired != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasAired", r.hasAired, "form", "")
	}
	if r.maxStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxStartDate", r.maxStartDate, "form", "")
	}
	if r.minEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinEndDate", r.minEndDate, "form", "")
	}
	if r.maxEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxEndDate", r.maxEndDate, "form", "")
	}
	if r.isMovie != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsMovie", r.isMovie, "form", "")
	}
	if r.isSeries != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsSeries", r.isSeries, "form", "")
	}
	if r.isNews != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsNews", r.isNews, "form", "")
	}
	if r.isKids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsKids", r.isKids, "form", "")
	}
	if r.isSports != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsSports", r.isSports, "form", "")
	}
	if r.startIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "StartIndex", r.startIndex, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Limit", r.limit, "form", "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SortBy", r.sortBy, "form", "")
	}
	if r.sortOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SortOrder", r.sortOrder, "form", "")
	}
	if r.genreIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "GenreIds", r.genreIds, "form", "")
	}
	if r.enableImages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImages", r.enableImages, "form", "")
	}
	if r.imageTypeLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ImageTypeLimit", r.imageTypeLimit, "form", "")
	}
	if r.enableImageTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImageTypes", r.enableImageTypes, "form", "")
	}
	if r.enableUserData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableUserData", r.enableUserData, "form", "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Fields", r.fields, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetLivetvProgramsRecommendedRequest struct {
	ctx context.Context
	ApiService LiveTvServiceAPI
	userId *string
	limit *int32
	isAiring *bool
	hasAired *bool
	isSeries *bool
	isMovie *bool
	isNews *bool
	isKids *bool
	isSports *bool
	enableImages *bool
	imageTypeLimit *int32
	enableImageTypes *string
	genreIds *string
	fields *string
	enableUserData *bool
}

// Optional filter by user id.
func (r ApiGetLivetvProgramsRecommendedRequest) UserId(userId string) ApiGetLivetvProgramsRecommendedRequest {
	r.userId = &userId
	return r
}

// Optional. The maximum number of records to return
func (r ApiGetLivetvProgramsRecommendedRequest) Limit(limit int32) ApiGetLivetvProgramsRecommendedRequest {
	r.limit = &limit
	return r
}

// Optional. Filter by programs that are currently airing, or not.
func (r ApiGetLivetvProgramsRecommendedRequest) IsAiring(isAiring bool) ApiGetLivetvProgramsRecommendedRequest {
	r.isAiring = &isAiring
	return r
}

// Optional. Filter by programs that have completed airing, or not.
func (r ApiGetLivetvProgramsRecommendedRequest) HasAired(hasAired bool) ApiGetLivetvProgramsRecommendedRequest {
	r.hasAired = &hasAired
	return r
}

// Optional filter for movies.
func (r ApiGetLivetvProgramsRecommendedRequest) IsSeries(isSeries bool) ApiGetLivetvProgramsRecommendedRequest {
	r.isSeries = &isSeries
	return r
}

// Optional filter for movies.
func (r ApiGetLivetvProgramsRecommendedRequest) IsMovie(isMovie bool) ApiGetLivetvProgramsRecommendedRequest {
	r.isMovie = &isMovie
	return r
}

// Optional filter for news.
func (r ApiGetLivetvProgramsRecommendedRequest) IsNews(isNews bool) ApiGetLivetvProgramsRecommendedRequest {
	r.isNews = &isNews
	return r
}

// Optional filter for kids.
func (r ApiGetLivetvProgramsRecommendedRequest) IsKids(isKids bool) ApiGetLivetvProgramsRecommendedRequest {
	r.isKids = &isKids
	return r
}

// Optional filter for sports.
func (r ApiGetLivetvProgramsRecommendedRequest) IsSports(isSports bool) ApiGetLivetvProgramsRecommendedRequest {
	r.isSports = &isSports
	return r
}

// Optional, include image information in output
func (r ApiGetLivetvProgramsRecommendedRequest) EnableImages(enableImages bool) ApiGetLivetvProgramsRecommendedRequest {
	r.enableImages = &enableImages
	return r
}

// Optional, the max number of images to return, per image type
func (r ApiGetLivetvProgramsRecommendedRequest) ImageTypeLimit(imageTypeLimit int32) ApiGetLivetvProgramsRecommendedRequest {
	r.imageTypeLimit = &imageTypeLimit
	return r
}

// Optional. The image types to include in the output.
func (r ApiGetLivetvProgramsRecommendedRequest) EnableImageTypes(enableImageTypes string) ApiGetLivetvProgramsRecommendedRequest {
	r.enableImageTypes = &enableImageTypes
	return r
}

// The genres to return guide information for.
func (r ApiGetLivetvProgramsRecommendedRequest) GenreIds(genreIds string) ApiGetLivetvProgramsRecommendedRequest {
	r.genreIds = &genreIds
	return r
}

// Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
func (r ApiGetLivetvProgramsRecommendedRequest) Fields(fields string) ApiGetLivetvProgramsRecommendedRequest {
	r.fields = &fields
	return r
}

// Optional, include user data
func (r ApiGetLivetvProgramsRecommendedRequest) EnableUserData(enableUserData bool) ApiGetLivetvProgramsRecommendedRequest {
	r.enableUserData = &enableUserData
	return r
}

func (r ApiGetLivetvProgramsRecommendedRequest) Execute() (*QueryResultBaseItemDto, *http.Response, error) {
	return r.ApiService.GetLivetvProgramsRecommendedExecute(r)
}

/*
GetLivetvProgramsRecommended Gets available live tv epgs..

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetLivetvProgramsRecommendedRequest
*/
func (a *LiveTvServiceAPIService) GetLivetvProgramsRecommended(ctx context.Context) ApiGetLivetvProgramsRecommendedRequest {
	return ApiGetLivetvProgramsRecommendedRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return QueryResultBaseItemDto
func (a *LiveTvServiceAPIService) GetLivetvProgramsRecommendedExecute(r ApiGetLivetvProgramsRecommendedRequest) (*QueryResultBaseItemDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QueryResultBaseItemDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.GetLivetvProgramsRecommended")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/Programs/Recommended"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "UserId", r.userId, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Limit", r.limit, "form", "")
	}
	if r.isAiring != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsAiring", r.isAiring, "form", "")
	}
	if r.hasAired != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasAired", r.hasAired, "form", "")
	}
	if r.isSeries != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsSeries", r.isSeries, "form", "")
	}
	if r.isMovie != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsMovie", r.isMovie, "form", "")
	}
	if r.isNews != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsNews", r.isNews, "form", "")
	}
	if r.isKids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsKids", r.isKids, "form", "")
	}
	if r.isSports != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsSports", r.isSports, "form", "")
	}
	if r.enableImages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImages", r.enableImages, "form", "")
	}
	if r.imageTypeLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ImageTypeLimit", r.imageTypeLimit, "form", "")
	}
	if r.enableImageTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImageTypes", r.enableImageTypes, "form", "")
	}
	if r.genreIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "GenreIds", r.genreIds, "form", "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Fields", r.fields, "form", "")
	}
	if r.enableUserData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableUserData", r.enableUserData, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetLivetvRecordingsRequest struct {
	ctx context.Context
	ApiService LiveTvServiceAPI
	channelId *string
	status *string
	isInProgress *bool
	seriesTimerId *string
	artistType *string
	maxOfficialRating *string
	hasThemeSong *bool
	hasThemeVideo *bool
	hasSubtitles *bool
	hasSpecialFeature *bool
	hasTrailer *bool
	adjacentTo *string
	minIndexNumber *int32
	minPlayers *int32
	maxPlayers *int32
	parentIndexNumber *int32
	hasParentalRating *bool
	isHD *bool
	locationTypes *string
	excludeLocationTypes *string
	isMissing *bool
	isUnaired *bool
	minCommunityRating *float64
	minCriticRating *float64
	airedDuringSeason *int32
	minPremiereDate *string
	minDateLastSaved *string
	minDateLastSavedForUser *string
	maxPremiereDate *string
	hasOverview *bool
	hasImdbId *bool
	hasTmdbId *bool
	hasTvdbId *bool
	excludeItemIds *string
	startIndex *int32
	limit *int32
	recursive *bool
	sortOrder *string
	parentId *string
	fields *string
	excludeItemTypes *string
	includeItemTypes *string
	anyProviderIdEquals *string
	filters *string
	isFavorite *bool
	isMovie *bool
	isSeries *bool
	isNews *bool
	isKids *bool
	isSports *bool
	mediaTypes *string
	imageTypes *string
	sortBy *string
	isPlayed *bool
	genres *string
	officialRatings *string
	tags *string
	years *string
	enableImages *bool
	enableUserData *bool
	imageTypeLimit *int32
	enableImageTypes *string
	person *string
	personIds *string
	personTypes *string
	studios *string
	studioIds *string
	artists *string
	artistIds *string
	albums *string
	ids *string
	videoTypes *string
	containers *string
	audioCodecs *string
	videoCodecs *string
	subtitleCodecs *string
	path *string
	userId *string
	minOfficialRating *string
	isLocked *bool
	isPlaceHolder *bool
	hasOfficialRating *bool
	groupItemsIntoCollections *bool
	is3D *bool
	seriesStatus *string
	nameStartsWithOrGreater *string
	nameStartsWith *string
	nameLessThan *string
}

// Optional filter by channel id.
func (r ApiGetLivetvRecordingsRequest) ChannelId(channelId string) ApiGetLivetvRecordingsRequest {
	r.channelId = &channelId
	return r
}

// Optional filter by recording status.
func (r ApiGetLivetvRecordingsRequest) Status(status string) ApiGetLivetvRecordingsRequest {
	r.status = &status
	return r
}

// Optional filter by recordings that are in progress, or not.
func (r ApiGetLivetvRecordingsRequest) IsInProgress(isInProgress bool) ApiGetLivetvRecordingsRequest {
	r.isInProgress = &isInProgress
	return r
}

// Optional filter by recordings belonging to a series timer
func (r ApiGetLivetvRecordingsRequest) SeriesTimerId(seriesTimerId string) ApiGetLivetvRecordingsRequest {
	r.seriesTimerId = &seriesTimerId
	return r
}

// Artist or AlbumArtist
func (r ApiGetLivetvRecordingsRequest) ArtistType(artistType string) ApiGetLivetvRecordingsRequest {
	r.artistType = &artistType
	return r
}

// Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
func (r ApiGetLivetvRecordingsRequest) MaxOfficialRating(maxOfficialRating string) ApiGetLivetvRecordingsRequest {
	r.maxOfficialRating = &maxOfficialRating
	return r
}

// Optional filter by items with theme songs.
func (r ApiGetLivetvRecordingsRequest) HasThemeSong(hasThemeSong bool) ApiGetLivetvRecordingsRequest {
	r.hasThemeSong = &hasThemeSong
	return r
}

// Optional filter by items with theme videos.
func (r ApiGetLivetvRecordingsRequest) HasThemeVideo(hasThemeVideo bool) ApiGetLivetvRecordingsRequest {
	r.hasThemeVideo = &hasThemeVideo
	return r
}

// Optional filter by items with subtitles.
func (r ApiGetLivetvRecordingsRequest) HasSubtitles(hasSubtitles bool) ApiGetLivetvRecordingsRequest {
	r.hasSubtitles = &hasSubtitles
	return r
}

// Optional filter by items with special features.
func (r ApiGetLivetvRecordingsRequest) HasSpecialFeature(hasSpecialFeature bool) ApiGetLivetvRecordingsRequest {
	r.hasSpecialFeature = &hasSpecialFeature
	return r
}

// Optional filter by items with trailers.
func (r ApiGetLivetvRecordingsRequest) HasTrailer(hasTrailer bool) ApiGetLivetvRecordingsRequest {
	r.hasTrailer = &hasTrailer
	return r
}

// Optional. Return items that are siblings of a supplied item.
func (r ApiGetLivetvRecordingsRequest) AdjacentTo(adjacentTo string) ApiGetLivetvRecordingsRequest {
	r.adjacentTo = &adjacentTo
	return r
}

// Optional filter by minimum index number.
func (r ApiGetLivetvRecordingsRequest) MinIndexNumber(minIndexNumber int32) ApiGetLivetvRecordingsRequest {
	r.minIndexNumber = &minIndexNumber
	return r
}

// Optional filter by minimum number of game players.
func (r ApiGetLivetvRecordingsRequest) MinPlayers(minPlayers int32) ApiGetLivetvRecordingsRequest {
	r.minPlayers = &minPlayers
	return r
}

// Optional filter by maximum number of game players.
func (r ApiGetLivetvRecordingsRequest) MaxPlayers(maxPlayers int32) ApiGetLivetvRecordingsRequest {
	r.maxPlayers = &maxPlayers
	return r
}

// Optional filter by parent index number.
func (r ApiGetLivetvRecordingsRequest) ParentIndexNumber(parentIndexNumber int32) ApiGetLivetvRecordingsRequest {
	r.parentIndexNumber = &parentIndexNumber
	return r
}

// Optional filter by items that have or do not have a parental rating
func (r ApiGetLivetvRecordingsRequest) HasParentalRating(hasParentalRating bool) ApiGetLivetvRecordingsRequest {
	r.hasParentalRating = &hasParentalRating
	return r
}

// Optional filter by items that are HD or not.
func (r ApiGetLivetvRecordingsRequest) IsHD(isHD bool) ApiGetLivetvRecordingsRequest {
	r.isHD = &isHD
	return r
}

// Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
func (r ApiGetLivetvRecordingsRequest) LocationTypes(locationTypes string) ApiGetLivetvRecordingsRequest {
	r.locationTypes = &locationTypes
	return r
}

// Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
func (r ApiGetLivetvRecordingsRequest) ExcludeLocationTypes(excludeLocationTypes string) ApiGetLivetvRecordingsRequest {
	r.excludeLocationTypes = &excludeLocationTypes
	return r
}

// Optional filter by items that are missing episodes or not.
func (r ApiGetLivetvRecordingsRequest) IsMissing(isMissing bool) ApiGetLivetvRecordingsRequest {
	r.isMissing = &isMissing
	return r
}

// Optional filter by items that are unaired episodes or not.
func (r ApiGetLivetvRecordingsRequest) IsUnaired(isUnaired bool) ApiGetLivetvRecordingsRequest {
	r.isUnaired = &isUnaired
	return r
}

// Optional filter by minimum community rating.
func (r ApiGetLivetvRecordingsRequest) MinCommunityRating(minCommunityRating float64) ApiGetLivetvRecordingsRequest {
	r.minCommunityRating = &minCommunityRating
	return r
}

// Optional filter by minimum critic rating.
func (r ApiGetLivetvRecordingsRequest) MinCriticRating(minCriticRating float64) ApiGetLivetvRecordingsRequest {
	r.minCriticRating = &minCriticRating
	return r
}

// Gets all episodes that aired during a season, including specials.
func (r ApiGetLivetvRecordingsRequest) AiredDuringSeason(airedDuringSeason int32) ApiGetLivetvRecordingsRequest {
	r.airedDuringSeason = &airedDuringSeason
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r ApiGetLivetvRecordingsRequest) MinPremiereDate(minPremiereDate string) ApiGetLivetvRecordingsRequest {
	r.minPremiereDate = &minPremiereDate
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r ApiGetLivetvRecordingsRequest) MinDateLastSaved(minDateLastSaved string) ApiGetLivetvRecordingsRequest {
	r.minDateLastSaved = &minDateLastSaved
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r ApiGetLivetvRecordingsRequest) MinDateLastSavedForUser(minDateLastSavedForUser string) ApiGetLivetvRecordingsRequest {
	r.minDateLastSavedForUser = &minDateLastSavedForUser
	return r
}

// Optional. The maximum premiere date. Format &#x3D; ISO
func (r ApiGetLivetvRecordingsRequest) MaxPremiereDate(maxPremiereDate string) ApiGetLivetvRecordingsRequest {
	r.maxPremiereDate = &maxPremiereDate
	return r
}

// Optional filter by items that have an overview or not.
func (r ApiGetLivetvRecordingsRequest) HasOverview(hasOverview bool) ApiGetLivetvRecordingsRequest {
	r.hasOverview = &hasOverview
	return r
}

// Optional filter by items that have an imdb id or not.
func (r ApiGetLivetvRecordingsRequest) HasImdbId(hasImdbId bool) ApiGetLivetvRecordingsRequest {
	r.hasImdbId = &hasImdbId
	return r
}

// Optional filter by items that have a tmdb id or not.
func (r ApiGetLivetvRecordingsRequest) HasTmdbId(hasTmdbId bool) ApiGetLivetvRecordingsRequest {
	r.hasTmdbId = &hasTmdbId
	return r
}

// Optional filter by items that have a tvdb id or not.
func (r ApiGetLivetvRecordingsRequest) HasTvdbId(hasTvdbId bool) ApiGetLivetvRecordingsRequest {
	r.hasTvdbId = &hasTvdbId
	return r
}

// Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
func (r ApiGetLivetvRecordingsRequest) ExcludeItemIds(excludeItemIds string) ApiGetLivetvRecordingsRequest {
	r.excludeItemIds = &excludeItemIds
	return r
}

// Optional. The record index to start at. All items with a lower index will be dropped from the results.
func (r ApiGetLivetvRecordingsRequest) StartIndex(startIndex int32) ApiGetLivetvRecordingsRequest {
	r.startIndex = &startIndex
	return r
}

// Optional. The maximum number of records to return
func (r ApiGetLivetvRecordingsRequest) Limit(limit int32) ApiGetLivetvRecordingsRequest {
	r.limit = &limit
	return r
}

// When searching within folders, this determines whether or not the search will be recursive. true/false
func (r ApiGetLivetvRecordingsRequest) Recursive(recursive bool) ApiGetLivetvRecordingsRequest {
	r.recursive = &recursive
	return r
}

// Sort Order - Ascending,Descending
func (r ApiGetLivetvRecordingsRequest) SortOrder(sortOrder string) ApiGetLivetvRecordingsRequest {
	r.sortOrder = &sortOrder
	return r
}

// Specify this to localize the search to a specific item or folder. Omit to use the root
func (r ApiGetLivetvRecordingsRequest) ParentId(parentId string) ApiGetLivetvRecordingsRequest {
	r.parentId = &parentId
	return r
}

// Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
func (r ApiGetLivetvRecordingsRequest) Fields(fields string) ApiGetLivetvRecordingsRequest {
	r.fields = &fields
	return r
}

// Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
func (r ApiGetLivetvRecordingsRequest) ExcludeItemTypes(excludeItemTypes string) ApiGetLivetvRecordingsRequest {
	r.excludeItemTypes = &excludeItemTypes
	return r
}

// Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
func (r ApiGetLivetvRecordingsRequest) IncludeItemTypes(includeItemTypes string) ApiGetLivetvRecordingsRequest {
	r.includeItemTypes = &includeItemTypes
	return r
}

// Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form &#39;prov.id&#39;, e.g. &#39;imdb.tt123456&#39;. This allows multiple, comma delimeted value pairs.
func (r ApiGetLivetvRecordingsRequest) AnyProviderIdEquals(anyProviderIdEquals string) ApiGetLivetvRecordingsRequest {
	r.anyProviderIdEquals = &anyProviderIdEquals
	return r
}

// Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
func (r ApiGetLivetvRecordingsRequest) Filters(filters string) ApiGetLivetvRecordingsRequest {
	r.filters = &filters
	return r
}

// Optional filter by items that are marked as favorite, or not.
func (r ApiGetLivetvRecordingsRequest) IsFavorite(isFavorite bool) ApiGetLivetvRecordingsRequest {
	r.isFavorite = &isFavorite
	return r
}

// Optional filter for movies.
func (r ApiGetLivetvRecordingsRequest) IsMovie(isMovie bool) ApiGetLivetvRecordingsRequest {
	r.isMovie = &isMovie
	return r
}

// Optional filter for movies.
func (r ApiGetLivetvRecordingsRequest) IsSeries(isSeries bool) ApiGetLivetvRecordingsRequest {
	r.isSeries = &isSeries
	return r
}

// Optional filter for news.
func (r ApiGetLivetvRecordingsRequest) IsNews(isNews bool) ApiGetLivetvRecordingsRequest {
	r.isNews = &isNews
	return r
}

// Optional filter for kids.
func (r ApiGetLivetvRecordingsRequest) IsKids(isKids bool) ApiGetLivetvRecordingsRequest {
	r.isKids = &isKids
	return r
}

// Optional filter for sports.
func (r ApiGetLivetvRecordingsRequest) IsSports(isSports bool) ApiGetLivetvRecordingsRequest {
	r.isSports = &isSports
	return r
}

// Optional filter by MediaType. Allows multiple, comma delimited.
func (r ApiGetLivetvRecordingsRequest) MediaTypes(mediaTypes string) ApiGetLivetvRecordingsRequest {
	r.mediaTypes = &mediaTypes
	return r
}

// Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
func (r ApiGetLivetvRecordingsRequest) ImageTypes(imageTypes string) ApiGetLivetvRecordingsRequest {
	r.imageTypes = &imageTypes
	return r
}

// Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
func (r ApiGetLivetvRecordingsRequest) SortBy(sortBy string) ApiGetLivetvRecordingsRequest {
	r.sortBy = &sortBy
	return r
}

// Optional filter by items that are played, or not.
func (r ApiGetLivetvRecordingsRequest) IsPlayed(isPlayed bool) ApiGetLivetvRecordingsRequest {
	r.isPlayed = &isPlayed
	return r
}

// Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
func (r ApiGetLivetvRecordingsRequest) Genres(genres string) ApiGetLivetvRecordingsRequest {
	r.genres = &genres
	return r
}

// Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
func (r ApiGetLivetvRecordingsRequest) OfficialRatings(officialRatings string) ApiGetLivetvRecordingsRequest {
	r.officialRatings = &officialRatings
	return r
}

// Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
func (r ApiGetLivetvRecordingsRequest) Tags(tags string) ApiGetLivetvRecordingsRequest {
	r.tags = &tags
	return r
}

// Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
func (r ApiGetLivetvRecordingsRequest) Years(years string) ApiGetLivetvRecordingsRequest {
	r.years = &years
	return r
}

// Optional, include image information in output
func (r ApiGetLivetvRecordingsRequest) EnableImages(enableImages bool) ApiGetLivetvRecordingsRequest {
	r.enableImages = &enableImages
	return r
}

// Optional, include user data
func (r ApiGetLivetvRecordingsRequest) EnableUserData(enableUserData bool) ApiGetLivetvRecordingsRequest {
	r.enableUserData = &enableUserData
	return r
}

// Optional, the max number of images to return, per image type
func (r ApiGetLivetvRecordingsRequest) ImageTypeLimit(imageTypeLimit int32) ApiGetLivetvRecordingsRequest {
	r.imageTypeLimit = &imageTypeLimit
	return r
}

// Optional. The image types to include in the output.
func (r ApiGetLivetvRecordingsRequest) EnableImageTypes(enableImageTypes string) ApiGetLivetvRecordingsRequest {
	r.enableImageTypes = &enableImageTypes
	return r
}

// Optional. If specified, results will be filtered to include only those containing the specified person.
func (r ApiGetLivetvRecordingsRequest) Person(person string) ApiGetLivetvRecordingsRequest {
	r.person = &person
	return r
}

// Optional. If specified, results will be filtered to include only those containing the specified person.
func (r ApiGetLivetvRecordingsRequest) PersonIds(personIds string) ApiGetLivetvRecordingsRequest {
	r.personIds = &personIds
	return r
}

// Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
func (r ApiGetLivetvRecordingsRequest) PersonTypes(personTypes string) ApiGetLivetvRecordingsRequest {
	r.personTypes = &personTypes
	return r
}

// Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
func (r ApiGetLivetvRecordingsRequest) Studios(studios string) ApiGetLivetvRecordingsRequest {
	r.studios = &studios
	return r
}

// Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
func (r ApiGetLivetvRecordingsRequest) StudioIds(studioIds string) ApiGetLivetvRecordingsRequest {
	r.studioIds = &studioIds
	return r
}

// Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
func (r ApiGetLivetvRecordingsRequest) Artists(artists string) ApiGetLivetvRecordingsRequest {
	r.artists = &artists
	return r
}

// Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
func (r ApiGetLivetvRecordingsRequest) ArtistIds(artistIds string) ApiGetLivetvRecordingsRequest {
	r.artistIds = &artistIds
	return r
}

// Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
func (r ApiGetLivetvRecordingsRequest) Albums(albums string) ApiGetLivetvRecordingsRequest {
	r.albums = &albums
	return r
}

// Optional. If specific items are needed, specify a list of item id&#39;s to retrieve. This allows multiple, comma delimited.
func (r ApiGetLivetvRecordingsRequest) Ids(ids string) ApiGetLivetvRecordingsRequest {
	r.ids = &ids
	return r
}

// Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
func (r ApiGetLivetvRecordingsRequest) VideoTypes(videoTypes string) ApiGetLivetvRecordingsRequest {
	r.videoTypes = &videoTypes
	return r
}

// Optional filter by Container. Allows multiple, comma delimeted.
func (r ApiGetLivetvRecordingsRequest) Containers(containers string) ApiGetLivetvRecordingsRequest {
	r.containers = &containers
	return r
}

// Optional filter by AudioCodec. Allows multiple, comma delimeted.
func (r ApiGetLivetvRecordingsRequest) AudioCodecs(audioCodecs string) ApiGetLivetvRecordingsRequest {
	r.audioCodecs = &audioCodecs
	return r
}

// Optional filter by VideoCodec. Allows multiple, comma delimeted.
func (r ApiGetLivetvRecordingsRequest) VideoCodecs(videoCodecs string) ApiGetLivetvRecordingsRequest {
	r.videoCodecs = &videoCodecs
	return r
}

// Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
func (r ApiGetLivetvRecordingsRequest) SubtitleCodecs(subtitleCodecs string) ApiGetLivetvRecordingsRequest {
	r.subtitleCodecs = &subtitleCodecs
	return r
}

// Optional filter by Path.
func (r ApiGetLivetvRecordingsRequest) Path(path string) ApiGetLivetvRecordingsRequest {
	r.path = &path
	return r
}

// User Id
func (r ApiGetLivetvRecordingsRequest) UserId(userId string) ApiGetLivetvRecordingsRequest {
	r.userId = &userId
	return r
}

// Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
func (r ApiGetLivetvRecordingsRequest) MinOfficialRating(minOfficialRating string) ApiGetLivetvRecordingsRequest {
	r.minOfficialRating = &minOfficialRating
	return r
}

// Optional filter by items that are locked.
func (r ApiGetLivetvRecordingsRequest) IsLocked(isLocked bool) ApiGetLivetvRecordingsRequest {
	r.isLocked = &isLocked
	return r
}

// Optional filter by items that are placeholders
func (r ApiGetLivetvRecordingsRequest) IsPlaceHolder(isPlaceHolder bool) ApiGetLivetvRecordingsRequest {
	r.isPlaceHolder = &isPlaceHolder
	return r
}

// Optional filter by items that have official ratings
func (r ApiGetLivetvRecordingsRequest) HasOfficialRating(hasOfficialRating bool) ApiGetLivetvRecordingsRequest {
	r.hasOfficialRating = &hasOfficialRating
	return r
}

// Whether or not to hide items behind their boxsets.
func (r ApiGetLivetvRecordingsRequest) GroupItemsIntoCollections(groupItemsIntoCollections bool) ApiGetLivetvRecordingsRequest {
	r.groupItemsIntoCollections = &groupItemsIntoCollections
	return r
}

// Optional filter by items that are 3D, or not.
func (r ApiGetLivetvRecordingsRequest) Is3D(is3D bool) ApiGetLivetvRecordingsRequest {
	r.is3D = &is3D
	return r
}

// Optional filter by Series Status. Allows multiple, comma delimeted.
func (r ApiGetLivetvRecordingsRequest) SeriesStatus(seriesStatus string) ApiGetLivetvRecordingsRequest {
	r.seriesStatus = &seriesStatus
	return r
}

// Optional filter by items whose name is sorted equally or greater than a given input string.
func (r ApiGetLivetvRecordingsRequest) NameStartsWithOrGreater(nameStartsWithOrGreater string) ApiGetLivetvRecordingsRequest {
	r.nameStartsWithOrGreater = &nameStartsWithOrGreater
	return r
}

// Optional filter by items whose name is sorted equally than a given input string.
func (r ApiGetLivetvRecordingsRequest) NameStartsWith(nameStartsWith string) ApiGetLivetvRecordingsRequest {
	r.nameStartsWith = &nameStartsWith
	return r
}

// Optional filter by items whose name is equally or lesser than a given input string.
func (r ApiGetLivetvRecordingsRequest) NameLessThan(nameLessThan string) ApiGetLivetvRecordingsRequest {
	r.nameLessThan = &nameLessThan
	return r
}

func (r ApiGetLivetvRecordingsRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetLivetvRecordingsExecute(r)
}

/*
GetLivetvRecordings Gets live tv recordings

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetLivetvRecordingsRequest
*/
func (a *LiveTvServiceAPIService) GetLivetvRecordings(ctx context.Context) ApiGetLivetvRecordingsRequest {
	return ApiGetLivetvRecordingsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *LiveTvServiceAPIService) GetLivetvRecordingsExecute(r ApiGetLivetvRecordingsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.GetLivetvRecordings")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/Recordings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.channelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ChannelId", r.channelId, "form", "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Status", r.status, "form", "")
	}
	if r.isInProgress != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsInProgress", r.isInProgress, "form", "")
	}
	if r.seriesTimerId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SeriesTimerId", r.seriesTimerId, "form", "")
	}
	if r.artistType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ArtistType", r.artistType, "form", "")
	}
	if r.maxOfficialRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxOfficialRating", r.maxOfficialRating, "form", "")
	}
	if r.hasThemeSong != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasThemeSong", r.hasThemeSong, "form", "")
	}
	if r.hasThemeVideo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasThemeVideo", r.hasThemeVideo, "form", "")
	}
	if r.hasSubtitles != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasSubtitles", r.hasSubtitles, "form", "")
	}
	if r.hasSpecialFeature != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasSpecialFeature", r.hasSpecialFeature, "form", "")
	}
	if r.hasTrailer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasTrailer", r.hasTrailer, "form", "")
	}
	if r.adjacentTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AdjacentTo", r.adjacentTo, "form", "")
	}
	if r.minIndexNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinIndexNumber", r.minIndexNumber, "form", "")
	}
	if r.minPlayers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinPlayers", r.minPlayers, "form", "")
	}
	if r.maxPlayers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxPlayers", r.maxPlayers, "form", "")
	}
	if r.parentIndexNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ParentIndexNumber", r.parentIndexNumber, "form", "")
	}
	if r.hasParentalRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasParentalRating", r.hasParentalRating, "form", "")
	}
	if r.isHD != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsHD", r.isHD, "form", "")
	}
	if r.locationTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "LocationTypes", r.locationTypes, "form", "")
	}
	if r.excludeLocationTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ExcludeLocationTypes", r.excludeLocationTypes, "form", "")
	}
	if r.isMissing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsMissing", r.isMissing, "form", "")
	}
	if r.isUnaired != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsUnaired", r.isUnaired, "form", "")
	}
	if r.minCommunityRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinCommunityRating", r.minCommunityRating, "form", "")
	}
	if r.minCriticRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinCriticRating", r.minCriticRating, "form", "")
	}
	if r.airedDuringSeason != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AiredDuringSeason", r.airedDuringSeason, "form", "")
	}
	if r.minPremiereDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinPremiereDate", r.minPremiereDate, "form", "")
	}
	if r.minDateLastSaved != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinDateLastSaved", r.minDateLastSaved, "form", "")
	}
	if r.minDateLastSavedForUser != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinDateLastSavedForUser", r.minDateLastSavedForUser, "form", "")
	}
	if r.maxPremiereDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxPremiereDate", r.maxPremiereDate, "form", "")
	}
	if r.hasOverview != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasOverview", r.hasOverview, "form", "")
	}
	if r.hasImdbId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasImdbId", r.hasImdbId, "form", "")
	}
	if r.hasTmdbId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasTmdbId", r.hasTmdbId, "form", "")
	}
	if r.hasTvdbId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasTvdbId", r.hasTvdbId, "form", "")
	}
	if r.excludeItemIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ExcludeItemIds", r.excludeItemIds, "form", "")
	}
	if r.startIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "StartIndex", r.startIndex, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Limit", r.limit, "form", "")
	}
	if r.recursive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Recursive", r.recursive, "form", "")
	}
	if r.sortOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SortOrder", r.sortOrder, "form", "")
	}
	if r.parentId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ParentId", r.parentId, "form", "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Fields", r.fields, "form", "")
	}
	if r.excludeItemTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ExcludeItemTypes", r.excludeItemTypes, "form", "")
	}
	if r.includeItemTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IncludeItemTypes", r.includeItemTypes, "form", "")
	}
	if r.anyProviderIdEquals != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AnyProviderIdEquals", r.anyProviderIdEquals, "form", "")
	}
	if r.filters != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Filters", r.filters, "form", "")
	}
	if r.isFavorite != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsFavorite", r.isFavorite, "form", "")
	}
	if r.isMovie != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsMovie", r.isMovie, "form", "")
	}
	if r.isSeries != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsSeries", r.isSeries, "form", "")
	}
	if r.isNews != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsNews", r.isNews, "form", "")
	}
	if r.isKids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsKids", r.isKids, "form", "")
	}
	if r.isSports != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsSports", r.isSports, "form", "")
	}
	if r.mediaTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MediaTypes", r.mediaTypes, "form", "")
	}
	if r.imageTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ImageTypes", r.imageTypes, "form", "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SortBy", r.sortBy, "form", "")
	}
	if r.isPlayed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsPlayed", r.isPlayed, "form", "")
	}
	if r.genres != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Genres", r.genres, "form", "")
	}
	if r.officialRatings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "OfficialRatings", r.officialRatings, "form", "")
	}
	if r.tags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Tags", r.tags, "form", "")
	}
	if r.years != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Years", r.years, "form", "")
	}
	if r.enableImages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImages", r.enableImages, "form", "")
	}
	if r.enableUserData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableUserData", r.enableUserData, "form", "")
	}
	if r.imageTypeLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ImageTypeLimit", r.imageTypeLimit, "form", "")
	}
	if r.enableImageTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImageTypes", r.enableImageTypes, "form", "")
	}
	if r.person != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Person", r.person, "form", "")
	}
	if r.personIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "PersonIds", r.personIds, "form", "")
	}
	if r.personTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "PersonTypes", r.personTypes, "form", "")
	}
	if r.studios != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Studios", r.studios, "form", "")
	}
	if r.studioIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "StudioIds", r.studioIds, "form", "")
	}
	if r.artists != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Artists", r.artists, "form", "")
	}
	if r.artistIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ArtistIds", r.artistIds, "form", "")
	}
	if r.albums != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Albums", r.albums, "form", "")
	}
	if r.ids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Ids", r.ids, "form", "")
	}
	if r.videoTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "VideoTypes", r.videoTypes, "form", "")
	}
	if r.containers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Containers", r.containers, "form", "")
	}
	if r.audioCodecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AudioCodecs", r.audioCodecs, "form", "")
	}
	if r.videoCodecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "VideoCodecs", r.videoCodecs, "form", "")
	}
	if r.subtitleCodecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SubtitleCodecs", r.subtitleCodecs, "form", "")
	}
	if r.path != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Path", r.path, "form", "")
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "UserId", r.userId, "form", "")
	}
	if r.minOfficialRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinOfficialRating", r.minOfficialRating, "form", "")
	}
	if r.isLocked != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsLocked", r.isLocked, "form", "")
	}
	if r.isPlaceHolder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsPlaceHolder", r.isPlaceHolder, "form", "")
	}
	if r.hasOfficialRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasOfficialRating", r.hasOfficialRating, "form", "")
	}
	if r.groupItemsIntoCollections != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "GroupItemsIntoCollections", r.groupItemsIntoCollections, "form", "")
	}
	if r.is3D != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Is3D", r.is3D, "form", "")
	}
	if r.seriesStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SeriesStatus", r.seriesStatus, "form", "")
	}
	if r.nameStartsWithOrGreater != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "NameStartsWithOrGreater", r.nameStartsWithOrGreater, "form", "")
	}
	if r.nameStartsWith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "NameStartsWith", r.nameStartsWith, "form", "")
	}
	if r.nameLessThan != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "NameLessThan", r.nameLessThan, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetLivetvRecordingsByIdRequest struct {
	ctx context.Context
	ApiService LiveTvServiceAPI
	id string
	userId *string
}

// Optional attach user data.
func (r ApiGetLivetvRecordingsByIdRequest) UserId(userId string) ApiGetLivetvRecordingsByIdRequest {
	r.userId = &userId
	return r
}

func (r ApiGetLivetvRecordingsByIdRequest) Execute() (*BaseItemDto, *http.Response, error) {
	return r.ApiService.GetLivetvRecordingsByIdExecute(r)
}

/*
GetLivetvRecordingsById Gets a live tv recording

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Recording Id
 @return ApiGetLivetvRecordingsByIdRequest
*/
func (a *LiveTvServiceAPIService) GetLivetvRecordingsById(ctx context.Context, id string) ApiGetLivetvRecordingsByIdRequest {
	return ApiGetLivetvRecordingsByIdRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return BaseItemDto
func (a *LiveTvServiceAPIService) GetLivetvRecordingsByIdExecute(r ApiGetLivetvRecordingsByIdRequest) (*BaseItemDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BaseItemDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.GetLivetvRecordingsById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/Recordings/{Id}"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "UserId", r.userId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetLivetvRecordingsFoldersRequest struct {
	ctx context.Context
	ApiService LiveTvServiceAPI
	userId *string
}

// Optional filter by user and attach user data.
func (r ApiGetLivetvRecordingsFoldersRequest) UserId(userId string) ApiGetLivetvRecordingsFoldersRequest {
	r.userId = &userId
	return r
}

func (r ApiGetLivetvRecordingsFoldersRequest) Execute() ([]BaseItemDto, *http.Response, error) {
	return r.ApiService.GetLivetvRecordingsFoldersExecute(r)
}

/*
GetLivetvRecordingsFolders Gets recording folders

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetLivetvRecordingsFoldersRequest
*/
func (a *LiveTvServiceAPIService) GetLivetvRecordingsFolders(ctx context.Context) ApiGetLivetvRecordingsFoldersRequest {
	return ApiGetLivetvRecordingsFoldersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []BaseItemDto
func (a *LiveTvServiceAPIService) GetLivetvRecordingsFoldersExecute(r ApiGetLivetvRecordingsFoldersRequest) ([]BaseItemDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []BaseItemDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.GetLivetvRecordingsFolders")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/Recordings/Folders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "UserId", r.userId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetLivetvRecordingsGroupsRequest struct {
	ctx context.Context
	ApiService LiveTvServiceAPI
	userId *string
}

// Optional filter by user and attach user data.
func (r ApiGetLivetvRecordingsGroupsRequest) UserId(userId string) ApiGetLivetvRecordingsGroupsRequest {
	r.userId = &userId
	return r
}

func (r ApiGetLivetvRecordingsGroupsRequest) Execute() (*QueryResultBaseItemDto, *http.Response, error) {
	return r.ApiService.GetLivetvRecordingsGroupsExecute(r)
}

/*
GetLivetvRecordingsGroups Gets live tv recording groups

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetLivetvRecordingsGroupsRequest
*/
func (a *LiveTvServiceAPIService) GetLivetvRecordingsGroups(ctx context.Context) ApiGetLivetvRecordingsGroupsRequest {
	return ApiGetLivetvRecordingsGroupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return QueryResultBaseItemDto
func (a *LiveTvServiceAPIService) GetLivetvRecordingsGroupsExecute(r ApiGetLivetvRecordingsGroupsRequest) (*QueryResultBaseItemDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QueryResultBaseItemDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.GetLivetvRecordingsGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/Recordings/Groups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "UserId", r.userId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetLivetvRecordingsGroupsByIdRequest struct {
	ctx context.Context
	ApiService LiveTvServiceAPI
	id string
}

func (r ApiGetLivetvRecordingsGroupsByIdRequest) Execute() (*BaseItemDto, *http.Response, error) {
	return r.ApiService.GetLivetvRecordingsGroupsByIdExecute(r)
}

/*
GetLivetvRecordingsGroupsById Gets a recording group

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Recording group Id
 @return ApiGetLivetvRecordingsGroupsByIdRequest
*/
func (a *LiveTvServiceAPIService) GetLivetvRecordingsGroupsById(ctx context.Context, id string) ApiGetLivetvRecordingsGroupsByIdRequest {
	return ApiGetLivetvRecordingsGroupsByIdRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return BaseItemDto
func (a *LiveTvServiceAPIService) GetLivetvRecordingsGroupsByIdExecute(r ApiGetLivetvRecordingsGroupsByIdRequest) (*BaseItemDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BaseItemDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.GetLivetvRecordingsGroupsById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/Recordings/Groups/{Id}"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetLivetvRecordingsSeriesRequest struct {
	ctx context.Context
	ApiService LiveTvServiceAPI
	channelId *string
	userId *string
	groupId *string
	startIndex *int32
	limit *int32
	status *string
	isInProgress *bool
	seriesTimerId *string
	enableImages *bool
	imageTypeLimit *int32
	enableImageTypes *string
	fields *string
	enableUserData *bool
}

// Optional filter by channel id.
func (r ApiGetLivetvRecordingsSeriesRequest) ChannelId(channelId string) ApiGetLivetvRecordingsSeriesRequest {
	r.channelId = &channelId
	return r
}

// Optional filter by user and attach user data.
func (r ApiGetLivetvRecordingsSeriesRequest) UserId(userId string) ApiGetLivetvRecordingsSeriesRequest {
	r.userId = &userId
	return r
}

// Optional filter by recording group.
func (r ApiGetLivetvRecordingsSeriesRequest) GroupId(groupId string) ApiGetLivetvRecordingsSeriesRequest {
	r.groupId = &groupId
	return r
}

// Optional. The record index to start at. All items with a lower index will be dropped from the results.
func (r ApiGetLivetvRecordingsSeriesRequest) StartIndex(startIndex int32) ApiGetLivetvRecordingsSeriesRequest {
	r.startIndex = &startIndex
	return r
}

// Optional. The maximum number of records to return
func (r ApiGetLivetvRecordingsSeriesRequest) Limit(limit int32) ApiGetLivetvRecordingsSeriesRequest {
	r.limit = &limit
	return r
}

// Optional filter by recording status.
func (r ApiGetLivetvRecordingsSeriesRequest) Status(status string) ApiGetLivetvRecordingsSeriesRequest {
	r.status = &status
	return r
}

// Optional filter by recordings that are in progress, or not.
func (r ApiGetLivetvRecordingsSeriesRequest) IsInProgress(isInProgress bool) ApiGetLivetvRecordingsSeriesRequest {
	r.isInProgress = &isInProgress
	return r
}

// Optional filter by recordings belonging to a series timer
func (r ApiGetLivetvRecordingsSeriesRequest) SeriesTimerId(seriesTimerId string) ApiGetLivetvRecordingsSeriesRequest {
	r.seriesTimerId = &seriesTimerId
	return r
}

// Optional, include image information in output
func (r ApiGetLivetvRecordingsSeriesRequest) EnableImages(enableImages bool) ApiGetLivetvRecordingsSeriesRequest {
	r.enableImages = &enableImages
	return r
}

// Optional, the max number of images to return, per image type
func (r ApiGetLivetvRecordingsSeriesRequest) ImageTypeLimit(imageTypeLimit int32) ApiGetLivetvRecordingsSeriesRequest {
	r.imageTypeLimit = &imageTypeLimit
	return r
}

// Optional. The image types to include in the output.
func (r ApiGetLivetvRecordingsSeriesRequest) EnableImageTypes(enableImageTypes string) ApiGetLivetvRecordingsSeriesRequest {
	r.enableImageTypes = &enableImageTypes
	return r
}

// Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
func (r ApiGetLivetvRecordingsSeriesRequest) Fields(fields string) ApiGetLivetvRecordingsSeriesRequest {
	r.fields = &fields
	return r
}

// Optional, include user data
func (r ApiGetLivetvRecordingsSeriesRequest) EnableUserData(enableUserData bool) ApiGetLivetvRecordingsSeriesRequest {
	r.enableUserData = &enableUserData
	return r
}

func (r ApiGetLivetvRecordingsSeriesRequest) Execute() (*QueryResultBaseItemDto, *http.Response, error) {
	return r.ApiService.GetLivetvRecordingsSeriesExecute(r)
}

/*
GetLivetvRecordingsSeries Gets live tv recordings

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetLivetvRecordingsSeriesRequest
*/
func (a *LiveTvServiceAPIService) GetLivetvRecordingsSeries(ctx context.Context) ApiGetLivetvRecordingsSeriesRequest {
	return ApiGetLivetvRecordingsSeriesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return QueryResultBaseItemDto
func (a *LiveTvServiceAPIService) GetLivetvRecordingsSeriesExecute(r ApiGetLivetvRecordingsSeriesRequest) (*QueryResultBaseItemDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QueryResultBaseItemDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.GetLivetvRecordingsSeries")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/Recordings/Series"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.channelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ChannelId", r.channelId, "form", "")
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "UserId", r.userId, "form", "")
	}
	if r.groupId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "GroupId", r.groupId, "form", "")
	}
	if r.startIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "StartIndex", r.startIndex, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Limit", r.limit, "form", "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Status", r.status, "form", "")
	}
	if r.isInProgress != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsInProgress", r.isInProgress, "form", "")
	}
	if r.seriesTimerId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SeriesTimerId", r.seriesTimerId, "form", "")
	}
	if r.enableImages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImages", r.enableImages, "form", "")
	}
	if r.imageTypeLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ImageTypeLimit", r.imageTypeLimit, "form", "")
	}
	if r.enableImageTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImageTypes", r.enableImageTypes, "form", "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Fields", r.fields, "form", "")
	}
	if r.enableUserData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableUserData", r.enableUserData, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetLivetvSeriestimersRequest struct {
	ctx context.Context
	ApiService LiveTvServiceAPI
	sortBy *string
	sortOrder *string
}

// Optional. Sort by SortName or Priority
func (r ApiGetLivetvSeriestimersRequest) SortBy(sortBy string) ApiGetLivetvSeriestimersRequest {
	r.sortBy = &sortBy
	return r
}

// Optional. Sort in Ascending or Descending order
func (r ApiGetLivetvSeriestimersRequest) SortOrder(sortOrder string) ApiGetLivetvSeriestimersRequest {
	r.sortOrder = &sortOrder
	return r
}

func (r ApiGetLivetvSeriestimersRequest) Execute() (*QueryResultLiveTvSeriesTimerInfoDto, *http.Response, error) {
	return r.ApiService.GetLivetvSeriestimersExecute(r)
}

/*
GetLivetvSeriestimers Gets live tv series timers

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetLivetvSeriestimersRequest
*/
func (a *LiveTvServiceAPIService) GetLivetvSeriestimers(ctx context.Context) ApiGetLivetvSeriestimersRequest {
	return ApiGetLivetvSeriestimersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return QueryResultLiveTvSeriesTimerInfoDto
func (a *LiveTvServiceAPIService) GetLivetvSeriestimersExecute(r ApiGetLivetvSeriestimersRequest) (*QueryResultLiveTvSeriesTimerInfoDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QueryResultLiveTvSeriesTimerInfoDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.GetLivetvSeriestimers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/SeriesTimers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SortBy", r.sortBy, "form", "")
	}
	if r.sortOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SortOrder", r.sortOrder, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetLivetvSeriestimersByIdRequest struct {
	ctx context.Context
	ApiService LiveTvServiceAPI
	id string
}

func (r ApiGetLivetvSeriestimersByIdRequest) Execute() (*LiveTvTimerInfoDto, *http.Response, error) {
	return r.ApiService.GetLivetvSeriestimersByIdExecute(r)
}

/*
GetLivetvSeriestimersById Gets a live tv series timer

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Timer Id
 @return ApiGetLivetvSeriestimersByIdRequest
*/
func (a *LiveTvServiceAPIService) GetLivetvSeriestimersById(ctx context.Context, id string) ApiGetLivetvSeriestimersByIdRequest {
	return ApiGetLivetvSeriestimersByIdRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return LiveTvTimerInfoDto
func (a *LiveTvServiceAPIService) GetLivetvSeriestimersByIdExecute(r ApiGetLivetvSeriestimersByIdRequest) (*LiveTvTimerInfoDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LiveTvTimerInfoDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.GetLivetvSeriestimersById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/SeriesTimers/{Id}"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetLivetvTimersRequest struct {
	ctx context.Context
	ApiService LiveTvServiceAPI
	channelId *string
	seriesTimerId *string
}

// Optional filter by channel id.
func (r ApiGetLivetvTimersRequest) ChannelId(channelId string) ApiGetLivetvTimersRequest {
	r.channelId = &channelId
	return r
}

// Optional filter by timers belonging to a series timer
func (r ApiGetLivetvTimersRequest) SeriesTimerId(seriesTimerId string) ApiGetLivetvTimersRequest {
	r.seriesTimerId = &seriesTimerId
	return r
}

func (r ApiGetLivetvTimersRequest) Execute() (*QueryResultLiveTvTimerInfoDto, *http.Response, error) {
	return r.ApiService.GetLivetvTimersExecute(r)
}

/*
GetLivetvTimers Gets live tv timers

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetLivetvTimersRequest
*/
func (a *LiveTvServiceAPIService) GetLivetvTimers(ctx context.Context) ApiGetLivetvTimersRequest {
	return ApiGetLivetvTimersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return QueryResultLiveTvTimerInfoDto
func (a *LiveTvServiceAPIService) GetLivetvTimersExecute(r ApiGetLivetvTimersRequest) (*QueryResultLiveTvTimerInfoDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QueryResultLiveTvTimerInfoDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.GetLivetvTimers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/Timers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.channelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ChannelId", r.channelId, "form", "")
	}
	if r.seriesTimerId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SeriesTimerId", r.seriesTimerId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetLivetvTimersByIdRequest struct {
	ctx context.Context
	ApiService LiveTvServiceAPI
	id string
}

func (r ApiGetLivetvTimersByIdRequest) Execute() (*LiveTvTimerInfoDto, *http.Response, error) {
	return r.ApiService.GetLivetvTimersByIdExecute(r)
}

/*
GetLivetvTimersById Gets a live tv timer

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Timer Id
 @return ApiGetLivetvTimersByIdRequest
*/
func (a *LiveTvServiceAPIService) GetLivetvTimersById(ctx context.Context, id string) ApiGetLivetvTimersByIdRequest {
	return ApiGetLivetvTimersByIdRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return LiveTvTimerInfoDto
func (a *LiveTvServiceAPIService) GetLivetvTimersByIdExecute(r ApiGetLivetvTimersByIdRequest) (*LiveTvTimerInfoDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LiveTvTimerInfoDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.GetLivetvTimersById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/Timers/{Id}"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetLivetvTimersDefaultsRequest struct {
	ctx context.Context
	ApiService LiveTvServiceAPI
	programId *string
}

// Optional, to attach default values based on a program.
func (r ApiGetLivetvTimersDefaultsRequest) ProgramId(programId string) ApiGetLivetvTimersDefaultsRequest {
	r.programId = &programId
	return r
}

func (r ApiGetLivetvTimersDefaultsRequest) Execute() (*LiveTvSeriesTimerInfoDto, *http.Response, error) {
	return r.ApiService.GetLivetvTimersDefaultsExecute(r)
}

/*
GetLivetvTimersDefaults Gets default values for a new timer

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetLivetvTimersDefaultsRequest
*/
func (a *LiveTvServiceAPIService) GetLivetvTimersDefaults(ctx context.Context) ApiGetLivetvTimersDefaultsRequest {
	return ApiGetLivetvTimersDefaultsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return LiveTvSeriesTimerInfoDto
func (a *LiveTvServiceAPIService) GetLivetvTimersDefaultsExecute(r ApiGetLivetvTimersDefaultsRequest) (*LiveTvSeriesTimerInfoDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LiveTvSeriesTimerInfoDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.GetLivetvTimersDefaults")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/Timers/Defaults"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.programId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ProgramId", r.programId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetLivetvTunerhostsRequest struct {
	ctx context.Context
	ApiService LiveTvServiceAPI
}

func (r ApiGetLivetvTunerhostsRequest) Execute() ([]LiveTvTunerHostInfo, *http.Response, error) {
	return r.ApiService.GetLivetvTunerhostsExecute(r)
}

/*
GetLivetvTunerhosts Gets tuner hosts

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetLivetvTunerhostsRequest
*/
func (a *LiveTvServiceAPIService) GetLivetvTunerhosts(ctx context.Context) ApiGetLivetvTunerhostsRequest {
	return ApiGetLivetvTunerhostsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []LiveTvTunerHostInfo
func (a *LiveTvServiceAPIService) GetLivetvTunerhostsExecute(r ApiGetLivetvTunerhostsRequest) ([]LiveTvTunerHostInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []LiveTvTunerHostInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.GetLivetvTunerhosts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/TunerHosts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetLivetvTunerhostsTypesRequest struct {
	ctx context.Context
	ApiService LiveTvServiceAPI
}

func (r ApiGetLivetvTunerhostsTypesRequest) Execute() ([]NameIdPair, *http.Response, error) {
	return r.ApiService.GetLivetvTunerhostsTypesExecute(r)
}

/*
GetLivetvTunerhostsTypes Method for GetLivetvTunerhostsTypes

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetLivetvTunerhostsTypesRequest
*/
func (a *LiveTvServiceAPIService) GetLivetvTunerhostsTypes(ctx context.Context) ApiGetLivetvTunerhostsTypesRequest {
	return ApiGetLivetvTunerhostsTypesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []NameIdPair
func (a *LiveTvServiceAPIService) GetLivetvTunerhostsTypesExecute(r ApiGetLivetvTunerhostsTypesRequest) ([]NameIdPair, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []NameIdPair
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.GetLivetvTunerhostsTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/TunerHosts/Types"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetLivetvTunersDiscvoverRequest struct {
	ctx context.Context
	ApiService LiveTvServiceAPI
}

func (r ApiGetLivetvTunersDiscvoverRequest) Execute() ([]LiveTvTunerHostInfo, *http.Response, error) {
	return r.ApiService.GetLivetvTunersDiscvoverExecute(r)
}

/*
GetLivetvTunersDiscvover Method for GetLivetvTunersDiscvover

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetLivetvTunersDiscvoverRequest
*/
func (a *LiveTvServiceAPIService) GetLivetvTunersDiscvover(ctx context.Context) ApiGetLivetvTunersDiscvoverRequest {
	return ApiGetLivetvTunersDiscvoverRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []LiveTvTunerHostInfo
func (a *LiveTvServiceAPIService) GetLivetvTunersDiscvoverExecute(r ApiGetLivetvTunersDiscvoverRequest) ([]LiveTvTunerHostInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []LiveTvTunerHostInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.GetLivetvTunersDiscvover")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/Tuners/Discvover"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiHeadLivetvChannelmappingoptionsRequest struct {
	ctx context.Context
	ApiService LiveTvServiceAPI
	providerId *string
}

// Provider id
func (r ApiHeadLivetvChannelmappingoptionsRequest) ProviderId(providerId string) ApiHeadLivetvChannelmappingoptionsRequest {
	r.providerId = &providerId
	return r
}

func (r ApiHeadLivetvChannelmappingoptionsRequest) Execute() (*http.Response, error) {
	return r.ApiService.HeadLivetvChannelmappingoptionsExecute(r)
}

/*
HeadLivetvChannelmappingoptions Method for HeadLivetvChannelmappingoptions

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiHeadLivetvChannelmappingoptionsRequest
*/
func (a *LiveTvServiceAPIService) HeadLivetvChannelmappingoptions(ctx context.Context) ApiHeadLivetvChannelmappingoptionsRequest {
	return ApiHeadLivetvChannelmappingoptionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *LiveTvServiceAPIService) HeadLivetvChannelmappingoptionsExecute(r ApiHeadLivetvChannelmappingoptionsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodHead
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.HeadLivetvChannelmappingoptions")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/ChannelMappingOptions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.providerId == nil {
		return nil, reportError("providerId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "ProviderId", r.providerId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiHeadLivetvChannelmappingsRequest struct {
	ctx context.Context
	ApiService LiveTvServiceAPI
	providerId *string
}

// Provider id
func (r ApiHeadLivetvChannelmappingsRequest) ProviderId(providerId string) ApiHeadLivetvChannelmappingsRequest {
	r.providerId = &providerId
	return r
}

func (r ApiHeadLivetvChannelmappingsRequest) Execute() (*http.Response, error) {
	return r.ApiService.HeadLivetvChannelmappingsExecute(r)
}

/*
HeadLivetvChannelmappings Method for HeadLivetvChannelmappings

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiHeadLivetvChannelmappingsRequest
*/
func (a *LiveTvServiceAPIService) HeadLivetvChannelmappings(ctx context.Context) ApiHeadLivetvChannelmappingsRequest {
	return ApiHeadLivetvChannelmappingsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *LiveTvServiceAPIService) HeadLivetvChannelmappingsExecute(r ApiHeadLivetvChannelmappingsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodHead
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.HeadLivetvChannelmappings")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/ChannelMappings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.providerId == nil {
		return nil, reportError("providerId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "ProviderId", r.providerId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiOptionsLivetvChannelmappingoptionsRequest struct {
	ctx context.Context
	ApiService LiveTvServiceAPI
	providerId *string
}

// Provider id
func (r ApiOptionsLivetvChannelmappingoptionsRequest) ProviderId(providerId string) ApiOptionsLivetvChannelmappingoptionsRequest {
	r.providerId = &providerId
	return r
}

func (r ApiOptionsLivetvChannelmappingoptionsRequest) Execute() (*http.Response, error) {
	return r.ApiService.OptionsLivetvChannelmappingoptionsExecute(r)
}

/*
OptionsLivetvChannelmappingoptions Method for OptionsLivetvChannelmappingoptions

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiOptionsLivetvChannelmappingoptionsRequest
*/
func (a *LiveTvServiceAPIService) OptionsLivetvChannelmappingoptions(ctx context.Context) ApiOptionsLivetvChannelmappingoptionsRequest {
	return ApiOptionsLivetvChannelmappingoptionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *LiveTvServiceAPIService) OptionsLivetvChannelmappingoptionsExecute(r ApiOptionsLivetvChannelmappingoptionsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodOptions
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.OptionsLivetvChannelmappingoptions")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/ChannelMappingOptions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.providerId == nil {
		return nil, reportError("providerId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "ProviderId", r.providerId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiOptionsLivetvChannelmappingsRequest struct {
	ctx context.Context
	ApiService LiveTvServiceAPI
	providerId *string
}

// Provider id
func (r ApiOptionsLivetvChannelmappingsRequest) ProviderId(providerId string) ApiOptionsLivetvChannelmappingsRequest {
	r.providerId = &providerId
	return r
}

func (r ApiOptionsLivetvChannelmappingsRequest) Execute() (*http.Response, error) {
	return r.ApiService.OptionsLivetvChannelmappingsExecute(r)
}

/*
OptionsLivetvChannelmappings Method for OptionsLivetvChannelmappings

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiOptionsLivetvChannelmappingsRequest
*/
func (a *LiveTvServiceAPIService) OptionsLivetvChannelmappings(ctx context.Context) ApiOptionsLivetvChannelmappingsRequest {
	return ApiOptionsLivetvChannelmappingsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *LiveTvServiceAPIService) OptionsLivetvChannelmappingsExecute(r ApiOptionsLivetvChannelmappingsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodOptions
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.OptionsLivetvChannelmappings")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/ChannelMappings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.providerId == nil {
		return nil, reportError("providerId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "ProviderId", r.providerId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPatchLivetvChannelmappingoptionsRequest struct {
	ctx context.Context
	ApiService LiveTvServiceAPI
	providerId *string
}

// Provider id
func (r ApiPatchLivetvChannelmappingoptionsRequest) ProviderId(providerId string) ApiPatchLivetvChannelmappingoptionsRequest {
	r.providerId = &providerId
	return r
}

func (r ApiPatchLivetvChannelmappingoptionsRequest) Execute() (*http.Response, error) {
	return r.ApiService.PatchLivetvChannelmappingoptionsExecute(r)
}

/*
PatchLivetvChannelmappingoptions Method for PatchLivetvChannelmappingoptions

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPatchLivetvChannelmappingoptionsRequest
*/
func (a *LiveTvServiceAPIService) PatchLivetvChannelmappingoptions(ctx context.Context) ApiPatchLivetvChannelmappingoptionsRequest {
	return ApiPatchLivetvChannelmappingoptionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *LiveTvServiceAPIService) PatchLivetvChannelmappingoptionsExecute(r ApiPatchLivetvChannelmappingoptionsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.PatchLivetvChannelmappingoptions")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/ChannelMappingOptions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.providerId == nil {
		return nil, reportError("providerId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "ProviderId", r.providerId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPatchLivetvChannelmappingsRequest struct {
	ctx context.Context
	ApiService LiveTvServiceAPI
	providerId *string
}

// Provider id
func (r ApiPatchLivetvChannelmappingsRequest) ProviderId(providerId string) ApiPatchLivetvChannelmappingsRequest {
	r.providerId = &providerId
	return r
}

func (r ApiPatchLivetvChannelmappingsRequest) Execute() (*http.Response, error) {
	return r.ApiService.PatchLivetvChannelmappingsExecute(r)
}

/*
PatchLivetvChannelmappings Method for PatchLivetvChannelmappings

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPatchLivetvChannelmappingsRequest
*/
func (a *LiveTvServiceAPIService) PatchLivetvChannelmappings(ctx context.Context) ApiPatchLivetvChannelmappingsRequest {
	return ApiPatchLivetvChannelmappingsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *LiveTvServiceAPIService) PatchLivetvChannelmappingsExecute(r ApiPatchLivetvChannelmappingsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.PatchLivetvChannelmappings")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/ChannelMappings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.providerId == nil {
		return nil, reportError("providerId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "ProviderId", r.providerId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostLivetvChannelmappingoptionsRequest struct {
	ctx context.Context
	ApiService LiveTvServiceAPI
	providerId *string
}

// Provider id
func (r ApiPostLivetvChannelmappingoptionsRequest) ProviderId(providerId string) ApiPostLivetvChannelmappingoptionsRequest {
	r.providerId = &providerId
	return r
}

func (r ApiPostLivetvChannelmappingoptionsRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostLivetvChannelmappingoptionsExecute(r)
}

/*
PostLivetvChannelmappingoptions Method for PostLivetvChannelmappingoptions

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostLivetvChannelmappingoptionsRequest
*/
func (a *LiveTvServiceAPIService) PostLivetvChannelmappingoptions(ctx context.Context) ApiPostLivetvChannelmappingoptionsRequest {
	return ApiPostLivetvChannelmappingoptionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *LiveTvServiceAPIService) PostLivetvChannelmappingoptionsExecute(r ApiPostLivetvChannelmappingoptionsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.PostLivetvChannelmappingoptions")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/ChannelMappingOptions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.providerId == nil {
		return nil, reportError("providerId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "ProviderId", r.providerId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostLivetvChannelmappingsRequest struct {
	ctx context.Context
	ApiService LiveTvServiceAPI
	providerId *string
	liveTvSetChannelMapping *LiveTvSetChannelMapping
}

// Provider id
func (r ApiPostLivetvChannelmappingsRequest) ProviderId(providerId string) ApiPostLivetvChannelmappingsRequest {
	r.providerId = &providerId
	return r
}

// SetChannelMapping
func (r ApiPostLivetvChannelmappingsRequest) LiveTvSetChannelMapping(liveTvSetChannelMapping LiveTvSetChannelMapping) ApiPostLivetvChannelmappingsRequest {
	r.liveTvSetChannelMapping = &liveTvSetChannelMapping
	return r
}

func (r ApiPostLivetvChannelmappingsRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostLivetvChannelmappingsExecute(r)
}

/*
PostLivetvChannelmappings Method for PostLivetvChannelmappings

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostLivetvChannelmappingsRequest
*/
func (a *LiveTvServiceAPIService) PostLivetvChannelmappings(ctx context.Context) ApiPostLivetvChannelmappingsRequest {
	return ApiPostLivetvChannelmappingsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *LiveTvServiceAPIService) PostLivetvChannelmappingsExecute(r ApiPostLivetvChannelmappingsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.PostLivetvChannelmappings")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/ChannelMappings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.providerId == nil {
		return nil, reportError("providerId is required and must be specified")
	}
	if r.liveTvSetChannelMapping == nil {
		return nil, reportError("liveTvSetChannelMapping is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "ProviderId", r.providerId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.liveTvSetChannelMapping
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostLivetvListingprovidersRequest struct {
	ctx context.Context
	ApiService LiveTvServiceAPI
	liveTvListingsProviderInfo *LiveTvListingsProviderInfo
}

// ListingsProviderInfo: 
func (r ApiPostLivetvListingprovidersRequest) LiveTvListingsProviderInfo(liveTvListingsProviderInfo LiveTvListingsProviderInfo) ApiPostLivetvListingprovidersRequest {
	r.liveTvListingsProviderInfo = &liveTvListingsProviderInfo
	return r
}

func (r ApiPostLivetvListingprovidersRequest) Execute() (*LiveTvListingsProviderInfo, *http.Response, error) {
	return r.ApiService.PostLivetvListingprovidersExecute(r)
}

/*
PostLivetvListingproviders Adds a listing provider

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostLivetvListingprovidersRequest
*/
func (a *LiveTvServiceAPIService) PostLivetvListingproviders(ctx context.Context) ApiPostLivetvListingprovidersRequest {
	return ApiPostLivetvListingprovidersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return LiveTvListingsProviderInfo
func (a *LiveTvServiceAPIService) PostLivetvListingprovidersExecute(r ApiPostLivetvListingprovidersRequest) (*LiveTvListingsProviderInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LiveTvListingsProviderInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.PostLivetvListingproviders")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/ListingProviders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.liveTvListingsProviderInfo == nil {
		return localVarReturnValue, nil, reportError("liveTvListingsProviderInfo is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.liveTvListingsProviderInfo
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostLivetvProgramsRequest struct {
	ctx context.Context
	ApiService LiveTvServiceAPI
	liveTvGetPrograms *LiveTvGetPrograms
	channelIds *string
	userId *string
	minStartDate *string
	maxStartDate *string
	minEndDate *string
	maxEndDate *string
	isMovie *bool
	isSeries *bool
	isNews *bool
	isKids *bool
	isSports *bool
	genreIds *string
}

// GetPrograms
func (r ApiPostLivetvProgramsRequest) LiveTvGetPrograms(liveTvGetPrograms LiveTvGetPrograms) ApiPostLivetvProgramsRequest {
	r.liveTvGetPrograms = &liveTvGetPrograms
	return r
}

// The channels to return guide information for.
func (r ApiPostLivetvProgramsRequest) ChannelIds(channelIds string) ApiPostLivetvProgramsRequest {
	r.channelIds = &channelIds
	return r
}

// Optional filter by user id.
func (r ApiPostLivetvProgramsRequest) UserId(userId string) ApiPostLivetvProgramsRequest {
	r.userId = &userId
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r ApiPostLivetvProgramsRequest) MinStartDate(minStartDate string) ApiPostLivetvProgramsRequest {
	r.minStartDate = &minStartDate
	return r
}

// Optional. The maximum premiere date. Format &#x3D; ISO
func (r ApiPostLivetvProgramsRequest) MaxStartDate(maxStartDate string) ApiPostLivetvProgramsRequest {
	r.maxStartDate = &maxStartDate
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r ApiPostLivetvProgramsRequest) MinEndDate(minEndDate string) ApiPostLivetvProgramsRequest {
	r.minEndDate = &minEndDate
	return r
}

// Optional. The maximum premiere date. Format &#x3D; ISO
func (r ApiPostLivetvProgramsRequest) MaxEndDate(maxEndDate string) ApiPostLivetvProgramsRequest {
	r.maxEndDate = &maxEndDate
	return r
}

// Optional filter for movies.
func (r ApiPostLivetvProgramsRequest) IsMovie(isMovie bool) ApiPostLivetvProgramsRequest {
	r.isMovie = &isMovie
	return r
}

// Optional filter for movies.
func (r ApiPostLivetvProgramsRequest) IsSeries(isSeries bool) ApiPostLivetvProgramsRequest {
	r.isSeries = &isSeries
	return r
}

// Optional filter for news.
func (r ApiPostLivetvProgramsRequest) IsNews(isNews bool) ApiPostLivetvProgramsRequest {
	r.isNews = &isNews
	return r
}

// Optional filter for kids.
func (r ApiPostLivetvProgramsRequest) IsKids(isKids bool) ApiPostLivetvProgramsRequest {
	r.isKids = &isKids
	return r
}

// Optional filter for sports.
func (r ApiPostLivetvProgramsRequest) IsSports(isSports bool) ApiPostLivetvProgramsRequest {
	r.isSports = &isSports
	return r
}

// The genres to return guide information for.
func (r ApiPostLivetvProgramsRequest) GenreIds(genreIds string) ApiPostLivetvProgramsRequest {
	r.genreIds = &genreIds
	return r
}

func (r ApiPostLivetvProgramsRequest) Execute() (*QueryResultBaseItemDto, *http.Response, error) {
	return r.ApiService.PostLivetvProgramsExecute(r)
}

/*
PostLivetvPrograms Gets available live tv epgs..

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostLivetvProgramsRequest
*/
func (a *LiveTvServiceAPIService) PostLivetvPrograms(ctx context.Context) ApiPostLivetvProgramsRequest {
	return ApiPostLivetvProgramsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return QueryResultBaseItemDto
func (a *LiveTvServiceAPIService) PostLivetvProgramsExecute(r ApiPostLivetvProgramsRequest) (*QueryResultBaseItemDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QueryResultBaseItemDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.PostLivetvPrograms")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/Programs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.liveTvGetPrograms == nil {
		return localVarReturnValue, nil, reportError("liveTvGetPrograms is required and must be specified")
	}

	if r.channelIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ChannelIds", r.channelIds, "form", "")
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "UserId", r.userId, "form", "")
	}
	if r.minStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinStartDate", r.minStartDate, "form", "")
	}
	if r.maxStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxStartDate", r.maxStartDate, "form", "")
	}
	if r.minEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinEndDate", r.minEndDate, "form", "")
	}
	if r.maxEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxEndDate", r.maxEndDate, "form", "")
	}
	if r.isMovie != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsMovie", r.isMovie, "form", "")
	}
	if r.isSeries != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsSeries", r.isSeries, "form", "")
	}
	if r.isNews != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsNews", r.isNews, "form", "")
	}
	if r.isKids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsKids", r.isKids, "form", "")
	}
	if r.isSports != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsSports", r.isSports, "form", "")
	}
	if r.genreIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "GenreIds", r.genreIds, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.liveTvGetPrograms
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostLivetvSeriestimersRequest struct {
	ctx context.Context
	ApiService LiveTvServiceAPI
	liveTvSeriesTimerInfoDto *LiveTvSeriesTimerInfoDto
}

// SeriesTimerInfoDto: 
func (r ApiPostLivetvSeriestimersRequest) LiveTvSeriesTimerInfoDto(liveTvSeriesTimerInfoDto LiveTvSeriesTimerInfoDto) ApiPostLivetvSeriestimersRequest {
	r.liveTvSeriesTimerInfoDto = &liveTvSeriesTimerInfoDto
	return r
}

func (r ApiPostLivetvSeriestimersRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostLivetvSeriestimersExecute(r)
}

/*
PostLivetvSeriestimers Creates a live tv series timer

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostLivetvSeriestimersRequest
*/
func (a *LiveTvServiceAPIService) PostLivetvSeriestimers(ctx context.Context) ApiPostLivetvSeriestimersRequest {
	return ApiPostLivetvSeriestimersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *LiveTvServiceAPIService) PostLivetvSeriestimersExecute(r ApiPostLivetvSeriestimersRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.PostLivetvSeriestimers")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/SeriesTimers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.liveTvSeriesTimerInfoDto == nil {
		return nil, reportError("liveTvSeriesTimerInfoDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.liveTvSeriesTimerInfoDto
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostLivetvSeriestimersByIdRequest struct {
	ctx context.Context
	ApiService LiveTvServiceAPI
	id string
	liveTvSeriesTimerInfoDto *LiveTvSeriesTimerInfoDto
}

// SeriesTimerInfoDto: 
func (r ApiPostLivetvSeriestimersByIdRequest) LiveTvSeriesTimerInfoDto(liveTvSeriesTimerInfoDto LiveTvSeriesTimerInfoDto) ApiPostLivetvSeriestimersByIdRequest {
	r.liveTvSeriesTimerInfoDto = &liveTvSeriesTimerInfoDto
	return r
}

func (r ApiPostLivetvSeriestimersByIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostLivetvSeriestimersByIdExecute(r)
}

/*
PostLivetvSeriestimersById Updates a live tv series timer

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiPostLivetvSeriestimersByIdRequest
*/
func (a *LiveTvServiceAPIService) PostLivetvSeriestimersById(ctx context.Context, id string) ApiPostLivetvSeriestimersByIdRequest {
	return ApiPostLivetvSeriestimersByIdRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *LiveTvServiceAPIService) PostLivetvSeriestimersByIdExecute(r ApiPostLivetvSeriestimersByIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.PostLivetvSeriestimersById")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/SeriesTimers/{Id}"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.liveTvSeriesTimerInfoDto == nil {
		return nil, reportError("liveTvSeriesTimerInfoDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.liveTvSeriesTimerInfoDto
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostLivetvTimersRequest struct {
	ctx context.Context
	ApiService LiveTvServiceAPI
	liveTvTimerInfoDto *LiveTvTimerInfoDto
}

// TimerInfoDto: 
func (r ApiPostLivetvTimersRequest) LiveTvTimerInfoDto(liveTvTimerInfoDto LiveTvTimerInfoDto) ApiPostLivetvTimersRequest {
	r.liveTvTimerInfoDto = &liveTvTimerInfoDto
	return r
}

func (r ApiPostLivetvTimersRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostLivetvTimersExecute(r)
}

/*
PostLivetvTimers Creates a live tv timer

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostLivetvTimersRequest
*/
func (a *LiveTvServiceAPIService) PostLivetvTimers(ctx context.Context) ApiPostLivetvTimersRequest {
	return ApiPostLivetvTimersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *LiveTvServiceAPIService) PostLivetvTimersExecute(r ApiPostLivetvTimersRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.PostLivetvTimers")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/Timers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.liveTvTimerInfoDto == nil {
		return nil, reportError("liveTvTimerInfoDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.liveTvTimerInfoDto
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostLivetvTimersByIdRequest struct {
	ctx context.Context
	ApiService LiveTvServiceAPI
	id string
	liveTvTimerInfoDto *LiveTvTimerInfoDto
}

// TimerInfoDto: 
func (r ApiPostLivetvTimersByIdRequest) LiveTvTimerInfoDto(liveTvTimerInfoDto LiveTvTimerInfoDto) ApiPostLivetvTimersByIdRequest {
	r.liveTvTimerInfoDto = &liveTvTimerInfoDto
	return r
}

func (r ApiPostLivetvTimersByIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostLivetvTimersByIdExecute(r)
}

/*
PostLivetvTimersById Updates a live tv timer

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiPostLivetvTimersByIdRequest
*/
func (a *LiveTvServiceAPIService) PostLivetvTimersById(ctx context.Context, id string) ApiPostLivetvTimersByIdRequest {
	return ApiPostLivetvTimersByIdRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *LiveTvServiceAPIService) PostLivetvTimersByIdExecute(r ApiPostLivetvTimersByIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.PostLivetvTimersById")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/Timers/{Id}"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.liveTvTimerInfoDto == nil {
		return nil, reportError("liveTvTimerInfoDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.liveTvTimerInfoDto
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostLivetvTunerhostsRequest struct {
	ctx context.Context
	ApiService LiveTvServiceAPI
	liveTvTunerHostInfo *LiveTvTunerHostInfo
}

// TunerHostInfo: 
func (r ApiPostLivetvTunerhostsRequest) LiveTvTunerHostInfo(liveTvTunerHostInfo LiveTvTunerHostInfo) ApiPostLivetvTunerhostsRequest {
	r.liveTvTunerHostInfo = &liveTvTunerHostInfo
	return r
}

func (r ApiPostLivetvTunerhostsRequest) Execute() (*LiveTvTunerHostInfo, *http.Response, error) {
	return r.ApiService.PostLivetvTunerhostsExecute(r)
}

/*
PostLivetvTunerhosts Adds a tuner host

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostLivetvTunerhostsRequest
*/
func (a *LiveTvServiceAPIService) PostLivetvTunerhosts(ctx context.Context) ApiPostLivetvTunerhostsRequest {
	return ApiPostLivetvTunerhostsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return LiveTvTunerHostInfo
func (a *LiveTvServiceAPIService) PostLivetvTunerhostsExecute(r ApiPostLivetvTunerhostsRequest) (*LiveTvTunerHostInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LiveTvTunerHostInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.PostLivetvTunerhosts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/TunerHosts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.liveTvTunerHostInfo == nil {
		return localVarReturnValue, nil, reportError("liveTvTunerHostInfo is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.liveTvTunerHostInfo
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostLivetvTunersByIdResetRequest struct {
	ctx context.Context
	ApiService LiveTvServiceAPI
	id string
}

func (r ApiPostLivetvTunersByIdResetRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostLivetvTunersByIdResetExecute(r)
}

/*
PostLivetvTunersByIdReset Resets a tv tuner

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Tuner Id
 @return ApiPostLivetvTunersByIdResetRequest
*/
func (a *LiveTvServiceAPIService) PostLivetvTunersByIdReset(ctx context.Context, id string) ApiPostLivetvTunersByIdResetRequest {
	return ApiPostLivetvTunersByIdResetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *LiveTvServiceAPIService) PostLivetvTunersByIdResetExecute(r ApiPostLivetvTunersByIdResetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.PostLivetvTunersByIdReset")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/Tuners/{Id}/Reset"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPutLivetvChannelmappingoptionsRequest struct {
	ctx context.Context
	ApiService LiveTvServiceAPI
	providerId *string
}

// Provider id
func (r ApiPutLivetvChannelmappingoptionsRequest) ProviderId(providerId string) ApiPutLivetvChannelmappingoptionsRequest {
	r.providerId = &providerId
	return r
}

func (r ApiPutLivetvChannelmappingoptionsRequest) Execute() (*http.Response, error) {
	return r.ApiService.PutLivetvChannelmappingoptionsExecute(r)
}

/*
PutLivetvChannelmappingoptions Method for PutLivetvChannelmappingoptions

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPutLivetvChannelmappingoptionsRequest
*/
func (a *LiveTvServiceAPIService) PutLivetvChannelmappingoptions(ctx context.Context) ApiPutLivetvChannelmappingoptionsRequest {
	return ApiPutLivetvChannelmappingoptionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *LiveTvServiceAPIService) PutLivetvChannelmappingoptionsExecute(r ApiPutLivetvChannelmappingoptionsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.PutLivetvChannelmappingoptions")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/ChannelMappingOptions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.providerId == nil {
		return nil, reportError("providerId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "ProviderId", r.providerId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPutLivetvChannelmappingsRequest struct {
	ctx context.Context
	ApiService LiveTvServiceAPI
	providerId *string
	liveTvSetChannelMapping *LiveTvSetChannelMapping
}

// Provider id
func (r ApiPutLivetvChannelmappingsRequest) ProviderId(providerId string) ApiPutLivetvChannelmappingsRequest {
	r.providerId = &providerId
	return r
}

// SetChannelMapping
func (r ApiPutLivetvChannelmappingsRequest) LiveTvSetChannelMapping(liveTvSetChannelMapping LiveTvSetChannelMapping) ApiPutLivetvChannelmappingsRequest {
	r.liveTvSetChannelMapping = &liveTvSetChannelMapping
	return r
}

func (r ApiPutLivetvChannelmappingsRequest) Execute() (*http.Response, error) {
	return r.ApiService.PutLivetvChannelmappingsExecute(r)
}

/*
PutLivetvChannelmappings Method for PutLivetvChannelmappings

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPutLivetvChannelmappingsRequest
*/
func (a *LiveTvServiceAPIService) PutLivetvChannelmappings(ctx context.Context) ApiPutLivetvChannelmappingsRequest {
	return ApiPutLivetvChannelmappingsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *LiveTvServiceAPIService) PutLivetvChannelmappingsExecute(r ApiPutLivetvChannelmappingsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.PutLivetvChannelmappings")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/ChannelMappings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.providerId == nil {
		return nil, reportError("providerId is required and must be specified")
	}
	if r.liveTvSetChannelMapping == nil {
		return nil, reportError("liveTvSetChannelMapping is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "ProviderId", r.providerId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.liveTvSetChannelMapping
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTraceLivetvChannelmappingoptionsRequest struct {
	ctx context.Context
	ApiService LiveTvServiceAPI
	providerId *string
}

// Provider id
func (r ApiTraceLivetvChannelmappingoptionsRequest) ProviderId(providerId string) ApiTraceLivetvChannelmappingoptionsRequest {
	r.providerId = &providerId
	return r
}

func (r ApiTraceLivetvChannelmappingoptionsRequest) Execute() (*http.Response, error) {
	return r.ApiService.TraceLivetvChannelmappingoptionsExecute(r)
}

/*
TraceLivetvChannelmappingoptions Method for TraceLivetvChannelmappingoptions

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTraceLivetvChannelmappingoptionsRequest
*/
func (a *LiveTvServiceAPIService) TraceLivetvChannelmappingoptions(ctx context.Context) ApiTraceLivetvChannelmappingoptionsRequest {
	return ApiTraceLivetvChannelmappingoptionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *LiveTvServiceAPIService) TraceLivetvChannelmappingoptionsExecute(r ApiTraceLivetvChannelmappingoptionsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodTrace
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.TraceLivetvChannelmappingoptions")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/ChannelMappingOptions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.providerId == nil {
		return nil, reportError("providerId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "ProviderId", r.providerId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTraceLivetvChannelmappingsRequest struct {
	ctx context.Context
	ApiService LiveTvServiceAPI
	providerId *string
}

// Provider id
func (r ApiTraceLivetvChannelmappingsRequest) ProviderId(providerId string) ApiTraceLivetvChannelmappingsRequest {
	r.providerId = &providerId
	return r
}

func (r ApiTraceLivetvChannelmappingsRequest) Execute() (*http.Response, error) {
	return r.ApiService.TraceLivetvChannelmappingsExecute(r)
}

/*
TraceLivetvChannelmappings Method for TraceLivetvChannelmappings

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTraceLivetvChannelmappingsRequest
*/
func (a *LiveTvServiceAPIService) TraceLivetvChannelmappings(ctx context.Context) ApiTraceLivetvChannelmappingsRequest {
	return ApiTraceLivetvChannelmappingsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *LiveTvServiceAPIService) TraceLivetvChannelmappingsExecute(r ApiTraceLivetvChannelmappingsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodTrace
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvServiceAPIService.TraceLivetvChannelmappings")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/ChannelMappings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.providerId == nil {
		return nil, reportError("providerId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "ProviderId", r.providerId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
