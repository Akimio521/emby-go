/*
Emby Server API

Explore the Emby Server API

API version: 4.1.1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package api

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


type LibraryServiceAPI interface {

	/*
	DeleteItems Deletes an item from the library and file system

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDeleteItemsRequest
	*/
	DeleteItems(ctx context.Context) ApiDeleteItemsRequest

	// DeleteItemsExecute executes the request
	DeleteItemsExecute(r ApiDeleteItemsRequest) (*http.Response, error)

	/*
	DeleteItemsById Deletes an item from the library and file system

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Item Id
	@return ApiDeleteItemsByIdRequest
	*/
	DeleteItemsById(ctx context.Context, id string) ApiDeleteItemsByIdRequest

	// DeleteItemsByIdExecute executes the request
	DeleteItemsByIdExecute(r ApiDeleteItemsByIdRequest) (*http.Response, error)

	/*
	GetAlbumsByIdSimilar Finds albums similar to a given album.

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Item Id
	@return ApiGetAlbumsByIdSimilarRequest
	*/
	GetAlbumsByIdSimilar(ctx context.Context, id string) ApiGetAlbumsByIdSimilarRequest

	// GetAlbumsByIdSimilarExecute executes the request
	//  @return QueryResultBaseItemDto
	GetAlbumsByIdSimilarExecute(r ApiGetAlbumsByIdSimilarRequest) (*QueryResultBaseItemDto, *http.Response, error)

	/*
	GetArtistsByIdSimilar Finds albums similar to a given album.

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Item Id
	@return ApiGetArtistsByIdSimilarRequest
	*/
	GetArtistsByIdSimilar(ctx context.Context, id string) ApiGetArtistsByIdSimilarRequest

	// GetArtistsByIdSimilarExecute executes the request
	//  @return QueryResultBaseItemDto
	GetArtistsByIdSimilarExecute(r ApiGetArtistsByIdSimilarRequest) (*QueryResultBaseItemDto, *http.Response, error)

	/*
	GetGamesByIdSimilar Finds games similar to a given game.

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Item Id
	@return ApiGetGamesByIdSimilarRequest
	*/
	GetGamesByIdSimilar(ctx context.Context, id string) ApiGetGamesByIdSimilarRequest

	// GetGamesByIdSimilarExecute executes the request
	//  @return QueryResultBaseItemDto
	GetGamesByIdSimilarExecute(r ApiGetGamesByIdSimilarRequest) (*QueryResultBaseItemDto, *http.Response, error)

	/*
	GetItemsByIdAncestors Gets all parents of an item

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Item Id
	@return ApiGetItemsByIdAncestorsRequest
	*/
	GetItemsByIdAncestors(ctx context.Context, id string) ApiGetItemsByIdAncestorsRequest

	// GetItemsByIdAncestorsExecute executes the request
	//  @return []BaseItemDto
	GetItemsByIdAncestorsExecute(r ApiGetItemsByIdAncestorsRequest) ([]BaseItemDto, *http.Response, error)

	/*
	GetItemsByIdCriticreviews Gets critic reviews for an item

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Item Id
	@return ApiGetItemsByIdCriticreviewsRequest
	*/
	GetItemsByIdCriticreviews(ctx context.Context, id string) ApiGetItemsByIdCriticreviewsRequest

	// GetItemsByIdCriticreviewsExecute executes the request
	//  @return QueryResultBaseItemDto
	GetItemsByIdCriticreviewsExecute(r ApiGetItemsByIdCriticreviewsRequest) (*QueryResultBaseItemDto, *http.Response, error)

	/*
	GetItemsByIdDeleteinfo Gets delete info for an item

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Item Id
	@return ApiGetItemsByIdDeleteinfoRequest
	*/
	GetItemsByIdDeleteinfo(ctx context.Context, id string) ApiGetItemsByIdDeleteinfoRequest

	// GetItemsByIdDeleteinfoExecute executes the request
	//  @return LibraryDeleteInfo
	GetItemsByIdDeleteinfoExecute(r ApiGetItemsByIdDeleteinfoRequest) (*LibraryDeleteInfo, *http.Response, error)

	/*
	GetItemsByIdDownload Downloads item media

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Item Id
	@return ApiGetItemsByIdDownloadRequest
	*/
	GetItemsByIdDownload(ctx context.Context, id string) ApiGetItemsByIdDownloadRequest

	// GetItemsByIdDownloadExecute executes the request
	GetItemsByIdDownloadExecute(r ApiGetItemsByIdDownloadRequest) (*http.Response, error)

	/*
	GetItemsByIdFile Gets the original file of an item

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Item Id
	@return ApiGetItemsByIdFileRequest
	*/
	GetItemsByIdFile(ctx context.Context, id string) ApiGetItemsByIdFileRequest

	// GetItemsByIdFileExecute executes the request
	GetItemsByIdFileExecute(r ApiGetItemsByIdFileRequest) (*http.Response, error)

	/*
	GetItemsByIdSimilar Gets similar items

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Item Id
	@return ApiGetItemsByIdSimilarRequest
	*/
	GetItemsByIdSimilar(ctx context.Context, id string) ApiGetItemsByIdSimilarRequest

	// GetItemsByIdSimilarExecute executes the request
	//  @return QueryResultBaseItemDto
	GetItemsByIdSimilarExecute(r ApiGetItemsByIdSimilarRequest) (*QueryResultBaseItemDto, *http.Response, error)

	/*
	GetItemsByIdThememedia Gets theme videos and songs for an item

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Item Id
	@return ApiGetItemsByIdThememediaRequest
	*/
	GetItemsByIdThememedia(ctx context.Context, id string) ApiGetItemsByIdThememediaRequest

	// GetItemsByIdThememediaExecute executes the request
	//  @return AllThemeMediaResult
	GetItemsByIdThememediaExecute(r ApiGetItemsByIdThememediaRequest) (*AllThemeMediaResult, *http.Response, error)

	/*
	GetItemsByIdThemesongs Gets theme songs for an item

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Item Id
	@return ApiGetItemsByIdThemesongsRequest
	*/
	GetItemsByIdThemesongs(ctx context.Context, id string) ApiGetItemsByIdThemesongsRequest

	// GetItemsByIdThemesongsExecute executes the request
	//  @return ThemeMediaResult
	GetItemsByIdThemesongsExecute(r ApiGetItemsByIdThemesongsRequest) (*ThemeMediaResult, *http.Response, error)

	/*
	GetItemsByIdThemevideos Gets theme videos for an item

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Item Id
	@return ApiGetItemsByIdThemevideosRequest
	*/
	GetItemsByIdThemevideos(ctx context.Context, id string) ApiGetItemsByIdThemevideosRequest

	// GetItemsByIdThemevideosExecute executes the request
	//  @return ThemeMediaResult
	GetItemsByIdThemevideosExecute(r ApiGetItemsByIdThemevideosRequest) (*ThemeMediaResult, *http.Response, error)

	/*
	GetItemsCounts Method for GetItemsCounts

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetItemsCountsRequest
	*/
	GetItemsCounts(ctx context.Context) ApiGetItemsCountsRequest

	// GetItemsCountsExecute executes the request
	//  @return ItemCounts
	GetItemsCountsExecute(r ApiGetItemsCountsRequest) (*ItemCounts, *http.Response, error)

	/*
	GetLibrariesAvailableoptions Method for GetLibrariesAvailableoptions

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetLibrariesAvailableoptionsRequest
	*/
	GetLibrariesAvailableoptions(ctx context.Context) ApiGetLibrariesAvailableoptionsRequest

	// GetLibrariesAvailableoptionsExecute executes the request
	//  @return LibraryLibraryOptionsResult
	GetLibrariesAvailableoptionsExecute(r ApiGetLibrariesAvailableoptionsRequest) (*LibraryLibraryOptionsResult, *http.Response, error)

	/*
	GetLibraryMediafolders Gets all user media folders.

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetLibraryMediafoldersRequest
	*/
	GetLibraryMediafolders(ctx context.Context) ApiGetLibraryMediafoldersRequest

	// GetLibraryMediafoldersExecute executes the request
	//  @return QueryResultBaseItemDto
	GetLibraryMediafoldersExecute(r ApiGetLibraryMediafoldersRequest) (*QueryResultBaseItemDto, *http.Response, error)

	/*
	GetLibraryPhysicalpaths Gets a list of physical paths from virtual folders

	Requires authentication as administrator

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetLibraryPhysicalpathsRequest
	*/
	GetLibraryPhysicalpaths(ctx context.Context) ApiGetLibraryPhysicalpathsRequest

	// GetLibraryPhysicalpathsExecute executes the request
	//  @return []string
	GetLibraryPhysicalpathsExecute(r ApiGetLibraryPhysicalpathsRequest) ([]string, *http.Response, error)

	/*
	GetLibrarySelectablemediafolders Gets all user media folders.

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetLibrarySelectablemediafoldersRequest
	*/
	GetLibrarySelectablemediafolders(ctx context.Context) ApiGetLibrarySelectablemediafoldersRequest

	// GetLibrarySelectablemediafoldersExecute executes the request
	//  @return []LibraryMediaFolder
	GetLibrarySelectablemediafoldersExecute(r ApiGetLibrarySelectablemediafoldersRequest) ([]LibraryMediaFolder, *http.Response, error)

	/*
	GetMoviesByIdSimilar Finds movies and trailers similar to a given movie.

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Item Id
	@return ApiGetMoviesByIdSimilarRequest
	*/
	GetMoviesByIdSimilar(ctx context.Context, id string) ApiGetMoviesByIdSimilarRequest

	// GetMoviesByIdSimilarExecute executes the request
	//  @return QueryResultBaseItemDto
	GetMoviesByIdSimilarExecute(r ApiGetMoviesByIdSimilarRequest) (*QueryResultBaseItemDto, *http.Response, error)

	/*
	GetShowsByIdSimilar Finds tv shows similar to a given one.

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Item Id
	@return ApiGetShowsByIdSimilarRequest
	*/
	GetShowsByIdSimilar(ctx context.Context, id string) ApiGetShowsByIdSimilarRequest

	// GetShowsByIdSimilarExecute executes the request
	//  @return QueryResultBaseItemDto
	GetShowsByIdSimilarExecute(r ApiGetShowsByIdSimilarRequest) (*QueryResultBaseItemDto, *http.Response, error)

	/*
	GetTrailersByIdSimilar Finds movies and trailers similar to a given trailer.

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Item Id
	@return ApiGetTrailersByIdSimilarRequest
	*/
	GetTrailersByIdSimilar(ctx context.Context, id string) ApiGetTrailersByIdSimilarRequest

	// GetTrailersByIdSimilarExecute executes the request
	//  @return QueryResultBaseItemDto
	GetTrailersByIdSimilarExecute(r ApiGetTrailersByIdSimilarRequest) (*QueryResultBaseItemDto, *http.Response, error)

	/*
	PostLibraryMediaUpdated Reports that new movies have been added by an external source

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostLibraryMediaUpdatedRequest
	*/
	PostLibraryMediaUpdated(ctx context.Context) ApiPostLibraryMediaUpdatedRequest

	// PostLibraryMediaUpdatedExecute executes the request
	PostLibraryMediaUpdatedExecute(r ApiPostLibraryMediaUpdatedRequest) (*http.Response, error)

	/*
	PostLibraryMoviesAdded Deprecated. Use /Library/Media/Updated

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostLibraryMoviesAddedRequest
	*/
	PostLibraryMoviesAdded(ctx context.Context) ApiPostLibraryMoviesAddedRequest

	// PostLibraryMoviesAddedExecute executes the request
	PostLibraryMoviesAddedExecute(r ApiPostLibraryMoviesAddedRequest) (*http.Response, error)

	/*
	PostLibraryMoviesUpdated Deprecated. Use /Library/Media/Updated

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostLibraryMoviesUpdatedRequest
	*/
	PostLibraryMoviesUpdated(ctx context.Context) ApiPostLibraryMoviesUpdatedRequest

	// PostLibraryMoviesUpdatedExecute executes the request
	PostLibraryMoviesUpdatedExecute(r ApiPostLibraryMoviesUpdatedRequest) (*http.Response, error)

	/*
	PostLibraryRefresh Starts a library scan

	Requires authentication as administrator

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostLibraryRefreshRequest
	*/
	PostLibraryRefresh(ctx context.Context) ApiPostLibraryRefreshRequest

	// PostLibraryRefreshExecute executes the request
	PostLibraryRefreshExecute(r ApiPostLibraryRefreshRequest) (*http.Response, error)

	/*
	PostLibrarySeriesAdded Deprecated. Use /Library/Media/Updated

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostLibrarySeriesAddedRequest
	*/
	PostLibrarySeriesAdded(ctx context.Context) ApiPostLibrarySeriesAddedRequest

	// PostLibrarySeriesAddedExecute executes the request
	PostLibrarySeriesAddedExecute(r ApiPostLibrarySeriesAddedRequest) (*http.Response, error)

	/*
	PostLibrarySeriesUpdated Deprecated. Use /Library/Media/Updated

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostLibrarySeriesUpdatedRequest
	*/
	PostLibrarySeriesUpdated(ctx context.Context) ApiPostLibrarySeriesUpdatedRequest

	// PostLibrarySeriesUpdatedExecute executes the request
	PostLibrarySeriesUpdatedExecute(r ApiPostLibrarySeriesUpdatedRequest) (*http.Response, error)
}

// LibraryServiceAPIService LibraryServiceAPI service
type LibraryServiceAPIService service

type ApiDeleteItemsRequest struct {
	ctx context.Context
	ApiService LibraryServiceAPI
	ids *string
}

// Ids
func (r ApiDeleteItemsRequest) Ids(ids string) ApiDeleteItemsRequest {
	r.ids = &ids
	return r
}

func (r ApiDeleteItemsRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteItemsExecute(r)
}

/*
DeleteItems Deletes an item from the library and file system

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteItemsRequest
*/
func (a *LibraryServiceAPIService) DeleteItems(ctx context.Context) ApiDeleteItemsRequest {
	return ApiDeleteItemsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *LibraryServiceAPIService) DeleteItemsExecute(r ApiDeleteItemsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LibraryServiceAPIService.DeleteItems")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Items"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ids == nil {
		return nil, reportError("ids is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "Ids", r.ids, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteItemsByIdRequest struct {
	ctx context.Context
	ApiService LibraryServiceAPI
	id string
}

func (r ApiDeleteItemsByIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteItemsByIdExecute(r)
}

/*
DeleteItemsById Deletes an item from the library and file system

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Item Id
 @return ApiDeleteItemsByIdRequest
*/
func (a *LibraryServiceAPIService) DeleteItemsById(ctx context.Context, id string) ApiDeleteItemsByIdRequest {
	return ApiDeleteItemsByIdRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *LibraryServiceAPIService) DeleteItemsByIdExecute(r ApiDeleteItemsByIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LibraryServiceAPIService.DeleteItemsById")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Items/{Id}"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetAlbumsByIdSimilarRequest struct {
	ctx context.Context
	ApiService LibraryServiceAPI
	id string
	includeItemTypes *string
	enableImages *bool
	enableUserData *bool
	imageTypeLimit *int32
	enableImageTypes *string
	userId *string
	limit *int32
	fields *string
}

// Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
func (r ApiGetAlbumsByIdSimilarRequest) IncludeItemTypes(includeItemTypes string) ApiGetAlbumsByIdSimilarRequest {
	r.includeItemTypes = &includeItemTypes
	return r
}

// Optional, include image information in output
func (r ApiGetAlbumsByIdSimilarRequest) EnableImages(enableImages bool) ApiGetAlbumsByIdSimilarRequest {
	r.enableImages = &enableImages
	return r
}

// Optional, include user data
func (r ApiGetAlbumsByIdSimilarRequest) EnableUserData(enableUserData bool) ApiGetAlbumsByIdSimilarRequest {
	r.enableUserData = &enableUserData
	return r
}

// Optional, the max number of images to return, per image type
func (r ApiGetAlbumsByIdSimilarRequest) ImageTypeLimit(imageTypeLimit int32) ApiGetAlbumsByIdSimilarRequest {
	r.imageTypeLimit = &imageTypeLimit
	return r
}

// Optional. The image types to include in the output.
func (r ApiGetAlbumsByIdSimilarRequest) EnableImageTypes(enableImageTypes string) ApiGetAlbumsByIdSimilarRequest {
	r.enableImageTypes = &enableImageTypes
	return r
}

// Optional. Filter by user id, and attach user data
func (r ApiGetAlbumsByIdSimilarRequest) UserId(userId string) ApiGetAlbumsByIdSimilarRequest {
	r.userId = &userId
	return r
}

// Optional. The maximum number of records to return
func (r ApiGetAlbumsByIdSimilarRequest) Limit(limit int32) ApiGetAlbumsByIdSimilarRequest {
	r.limit = &limit
	return r
}

// Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
func (r ApiGetAlbumsByIdSimilarRequest) Fields(fields string) ApiGetAlbumsByIdSimilarRequest {
	r.fields = &fields
	return r
}

func (r ApiGetAlbumsByIdSimilarRequest) Execute() (*QueryResultBaseItemDto, *http.Response, error) {
	return r.ApiService.GetAlbumsByIdSimilarExecute(r)
}

/*
GetAlbumsByIdSimilar Finds albums similar to a given album.

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Item Id
 @return ApiGetAlbumsByIdSimilarRequest
*/
func (a *LibraryServiceAPIService) GetAlbumsByIdSimilar(ctx context.Context, id string) ApiGetAlbumsByIdSimilarRequest {
	return ApiGetAlbumsByIdSimilarRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return QueryResultBaseItemDto
func (a *LibraryServiceAPIService) GetAlbumsByIdSimilarExecute(r ApiGetAlbumsByIdSimilarRequest) (*QueryResultBaseItemDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QueryResultBaseItemDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LibraryServiceAPIService.GetAlbumsByIdSimilar")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Albums/{Id}/Similar"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.includeItemTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IncludeItemTypes", r.includeItemTypes, "form", "")
	}
	if r.enableImages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImages", r.enableImages, "form", "")
	}
	if r.enableUserData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableUserData", r.enableUserData, "form", "")
	}
	if r.imageTypeLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ImageTypeLimit", r.imageTypeLimit, "form", "")
	}
	if r.enableImageTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImageTypes", r.enableImageTypes, "form", "")
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "UserId", r.userId, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Limit", r.limit, "form", "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Fields", r.fields, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetArtistsByIdSimilarRequest struct {
	ctx context.Context
	ApiService LibraryServiceAPI
	id string
	includeItemTypes *string
	enableImages *bool
	enableUserData *bool
	imageTypeLimit *int32
	enableImageTypes *string
	userId *string
	limit *int32
	fields *string
}

// Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
func (r ApiGetArtistsByIdSimilarRequest) IncludeItemTypes(includeItemTypes string) ApiGetArtistsByIdSimilarRequest {
	r.includeItemTypes = &includeItemTypes
	return r
}

// Optional, include image information in output
func (r ApiGetArtistsByIdSimilarRequest) EnableImages(enableImages bool) ApiGetArtistsByIdSimilarRequest {
	r.enableImages = &enableImages
	return r
}

// Optional, include user data
func (r ApiGetArtistsByIdSimilarRequest) EnableUserData(enableUserData bool) ApiGetArtistsByIdSimilarRequest {
	r.enableUserData = &enableUserData
	return r
}

// Optional, the max number of images to return, per image type
func (r ApiGetArtistsByIdSimilarRequest) ImageTypeLimit(imageTypeLimit int32) ApiGetArtistsByIdSimilarRequest {
	r.imageTypeLimit = &imageTypeLimit
	return r
}

// Optional. The image types to include in the output.
func (r ApiGetArtistsByIdSimilarRequest) EnableImageTypes(enableImageTypes string) ApiGetArtistsByIdSimilarRequest {
	r.enableImageTypes = &enableImageTypes
	return r
}

// Optional. Filter by user id, and attach user data
func (r ApiGetArtistsByIdSimilarRequest) UserId(userId string) ApiGetArtistsByIdSimilarRequest {
	r.userId = &userId
	return r
}

// Optional. The maximum number of records to return
func (r ApiGetArtistsByIdSimilarRequest) Limit(limit int32) ApiGetArtistsByIdSimilarRequest {
	r.limit = &limit
	return r
}

// Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
func (r ApiGetArtistsByIdSimilarRequest) Fields(fields string) ApiGetArtistsByIdSimilarRequest {
	r.fields = &fields
	return r
}

func (r ApiGetArtistsByIdSimilarRequest) Execute() (*QueryResultBaseItemDto, *http.Response, error) {
	return r.ApiService.GetArtistsByIdSimilarExecute(r)
}

/*
GetArtistsByIdSimilar Finds albums similar to a given album.

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Item Id
 @return ApiGetArtistsByIdSimilarRequest
*/
func (a *LibraryServiceAPIService) GetArtistsByIdSimilar(ctx context.Context, id string) ApiGetArtistsByIdSimilarRequest {
	return ApiGetArtistsByIdSimilarRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return QueryResultBaseItemDto
func (a *LibraryServiceAPIService) GetArtistsByIdSimilarExecute(r ApiGetArtistsByIdSimilarRequest) (*QueryResultBaseItemDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QueryResultBaseItemDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LibraryServiceAPIService.GetArtistsByIdSimilar")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Artists/{Id}/Similar"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.includeItemTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IncludeItemTypes", r.includeItemTypes, "form", "")
	}
	if r.enableImages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImages", r.enableImages, "form", "")
	}
	if r.enableUserData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableUserData", r.enableUserData, "form", "")
	}
	if r.imageTypeLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ImageTypeLimit", r.imageTypeLimit, "form", "")
	}
	if r.enableImageTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImageTypes", r.enableImageTypes, "form", "")
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "UserId", r.userId, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Limit", r.limit, "form", "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Fields", r.fields, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetGamesByIdSimilarRequest struct {
	ctx context.Context
	ApiService LibraryServiceAPI
	id string
	includeItemTypes *string
	enableImages *bool
	enableUserData *bool
	imageTypeLimit *int32
	enableImageTypes *string
	userId *string
	limit *int32
	fields *string
}

// Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
func (r ApiGetGamesByIdSimilarRequest) IncludeItemTypes(includeItemTypes string) ApiGetGamesByIdSimilarRequest {
	r.includeItemTypes = &includeItemTypes
	return r
}

// Optional, include image information in output
func (r ApiGetGamesByIdSimilarRequest) EnableImages(enableImages bool) ApiGetGamesByIdSimilarRequest {
	r.enableImages = &enableImages
	return r
}

// Optional, include user data
func (r ApiGetGamesByIdSimilarRequest) EnableUserData(enableUserData bool) ApiGetGamesByIdSimilarRequest {
	r.enableUserData = &enableUserData
	return r
}

// Optional, the max number of images to return, per image type
func (r ApiGetGamesByIdSimilarRequest) ImageTypeLimit(imageTypeLimit int32) ApiGetGamesByIdSimilarRequest {
	r.imageTypeLimit = &imageTypeLimit
	return r
}

// Optional. The image types to include in the output.
func (r ApiGetGamesByIdSimilarRequest) EnableImageTypes(enableImageTypes string) ApiGetGamesByIdSimilarRequest {
	r.enableImageTypes = &enableImageTypes
	return r
}

// Optional. Filter by user id, and attach user data
func (r ApiGetGamesByIdSimilarRequest) UserId(userId string) ApiGetGamesByIdSimilarRequest {
	r.userId = &userId
	return r
}

// Optional. The maximum number of records to return
func (r ApiGetGamesByIdSimilarRequest) Limit(limit int32) ApiGetGamesByIdSimilarRequest {
	r.limit = &limit
	return r
}

// Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
func (r ApiGetGamesByIdSimilarRequest) Fields(fields string) ApiGetGamesByIdSimilarRequest {
	r.fields = &fields
	return r
}

func (r ApiGetGamesByIdSimilarRequest) Execute() (*QueryResultBaseItemDto, *http.Response, error) {
	return r.ApiService.GetGamesByIdSimilarExecute(r)
}

/*
GetGamesByIdSimilar Finds games similar to a given game.

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Item Id
 @return ApiGetGamesByIdSimilarRequest
*/
func (a *LibraryServiceAPIService) GetGamesByIdSimilar(ctx context.Context, id string) ApiGetGamesByIdSimilarRequest {
	return ApiGetGamesByIdSimilarRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return QueryResultBaseItemDto
func (a *LibraryServiceAPIService) GetGamesByIdSimilarExecute(r ApiGetGamesByIdSimilarRequest) (*QueryResultBaseItemDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QueryResultBaseItemDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LibraryServiceAPIService.GetGamesByIdSimilar")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Games/{Id}/Similar"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.includeItemTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IncludeItemTypes", r.includeItemTypes, "form", "")
	}
	if r.enableImages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImages", r.enableImages, "form", "")
	}
	if r.enableUserData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableUserData", r.enableUserData, "form", "")
	}
	if r.imageTypeLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ImageTypeLimit", r.imageTypeLimit, "form", "")
	}
	if r.enableImageTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImageTypes", r.enableImageTypes, "form", "")
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "UserId", r.userId, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Limit", r.limit, "form", "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Fields", r.fields, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetItemsByIdAncestorsRequest struct {
	ctx context.Context
	ApiService LibraryServiceAPI
	id string
	userId *string
}

// Optional. Filter by user id, and attach user data
func (r ApiGetItemsByIdAncestorsRequest) UserId(userId string) ApiGetItemsByIdAncestorsRequest {
	r.userId = &userId
	return r
}

func (r ApiGetItemsByIdAncestorsRequest) Execute() ([]BaseItemDto, *http.Response, error) {
	return r.ApiService.GetItemsByIdAncestorsExecute(r)
}

/*
GetItemsByIdAncestors Gets all parents of an item

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Item Id
 @return ApiGetItemsByIdAncestorsRequest
*/
func (a *LibraryServiceAPIService) GetItemsByIdAncestors(ctx context.Context, id string) ApiGetItemsByIdAncestorsRequest {
	return ApiGetItemsByIdAncestorsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return []BaseItemDto
func (a *LibraryServiceAPIService) GetItemsByIdAncestorsExecute(r ApiGetItemsByIdAncestorsRequest) ([]BaseItemDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []BaseItemDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LibraryServiceAPIService.GetItemsByIdAncestors")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Items/{Id}/Ancestors"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "UserId", r.userId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetItemsByIdCriticreviewsRequest struct {
	ctx context.Context
	ApiService LibraryServiceAPI
	id string
	startIndex *int32
	limit *int32
}

// Optional. The record index to start at. All items with a lower index will be dropped from the results.
func (r ApiGetItemsByIdCriticreviewsRequest) StartIndex(startIndex int32) ApiGetItemsByIdCriticreviewsRequest {
	r.startIndex = &startIndex
	return r
}

// Optional. The maximum number of records to return
func (r ApiGetItemsByIdCriticreviewsRequest) Limit(limit int32) ApiGetItemsByIdCriticreviewsRequest {
	r.limit = &limit
	return r
}

func (r ApiGetItemsByIdCriticreviewsRequest) Execute() (*QueryResultBaseItemDto, *http.Response, error) {
	return r.ApiService.GetItemsByIdCriticreviewsExecute(r)
}

/*
GetItemsByIdCriticreviews Gets critic reviews for an item

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Item Id
 @return ApiGetItemsByIdCriticreviewsRequest
*/
func (a *LibraryServiceAPIService) GetItemsByIdCriticreviews(ctx context.Context, id string) ApiGetItemsByIdCriticreviewsRequest {
	return ApiGetItemsByIdCriticreviewsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return QueryResultBaseItemDto
func (a *LibraryServiceAPIService) GetItemsByIdCriticreviewsExecute(r ApiGetItemsByIdCriticreviewsRequest) (*QueryResultBaseItemDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QueryResultBaseItemDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LibraryServiceAPIService.GetItemsByIdCriticreviews")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Items/{Id}/CriticReviews"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "StartIndex", r.startIndex, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Limit", r.limit, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetItemsByIdDeleteinfoRequest struct {
	ctx context.Context
	ApiService LibraryServiceAPI
	id string
}

func (r ApiGetItemsByIdDeleteinfoRequest) Execute() (*LibraryDeleteInfo, *http.Response, error) {
	return r.ApiService.GetItemsByIdDeleteinfoExecute(r)
}

/*
GetItemsByIdDeleteinfo Gets delete info for an item

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Item Id
 @return ApiGetItemsByIdDeleteinfoRequest
*/
func (a *LibraryServiceAPIService) GetItemsByIdDeleteinfo(ctx context.Context, id string) ApiGetItemsByIdDeleteinfoRequest {
	return ApiGetItemsByIdDeleteinfoRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return LibraryDeleteInfo
func (a *LibraryServiceAPIService) GetItemsByIdDeleteinfoExecute(r ApiGetItemsByIdDeleteinfoRequest) (*LibraryDeleteInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LibraryDeleteInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LibraryServiceAPIService.GetItemsByIdDeleteinfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Items/{Id}/DeleteInfo"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetItemsByIdDownloadRequest struct {
	ctx context.Context
	ApiService LibraryServiceAPI
	id string
}

func (r ApiGetItemsByIdDownloadRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetItemsByIdDownloadExecute(r)
}

/*
GetItemsByIdDownload Downloads item media

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Item Id
 @return ApiGetItemsByIdDownloadRequest
*/
func (a *LibraryServiceAPIService) GetItemsByIdDownload(ctx context.Context, id string) ApiGetItemsByIdDownloadRequest {
	return ApiGetItemsByIdDownloadRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *LibraryServiceAPIService) GetItemsByIdDownloadExecute(r ApiGetItemsByIdDownloadRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LibraryServiceAPIService.GetItemsByIdDownload")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Items/{Id}/Download"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetItemsByIdFileRequest struct {
	ctx context.Context
	ApiService LibraryServiceAPI
	id string
}

func (r ApiGetItemsByIdFileRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetItemsByIdFileExecute(r)
}

/*
GetItemsByIdFile Gets the original file of an item

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Item Id
 @return ApiGetItemsByIdFileRequest
*/
func (a *LibraryServiceAPIService) GetItemsByIdFile(ctx context.Context, id string) ApiGetItemsByIdFileRequest {
	return ApiGetItemsByIdFileRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *LibraryServiceAPIService) GetItemsByIdFileExecute(r ApiGetItemsByIdFileRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LibraryServiceAPIService.GetItemsByIdFile")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Items/{Id}/File"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetItemsByIdSimilarRequest struct {
	ctx context.Context
	ApiService LibraryServiceAPI
	id string
	includeItemTypes *string
	enableImages *bool
	enableUserData *bool
	imageTypeLimit *int32
	enableImageTypes *string
	userId *string
	limit *int32
	fields *string
}

// Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
func (r ApiGetItemsByIdSimilarRequest) IncludeItemTypes(includeItemTypes string) ApiGetItemsByIdSimilarRequest {
	r.includeItemTypes = &includeItemTypes
	return r
}

// Optional, include image information in output
func (r ApiGetItemsByIdSimilarRequest) EnableImages(enableImages bool) ApiGetItemsByIdSimilarRequest {
	r.enableImages = &enableImages
	return r
}

// Optional, include user data
func (r ApiGetItemsByIdSimilarRequest) EnableUserData(enableUserData bool) ApiGetItemsByIdSimilarRequest {
	r.enableUserData = &enableUserData
	return r
}

// Optional, the max number of images to return, per image type
func (r ApiGetItemsByIdSimilarRequest) ImageTypeLimit(imageTypeLimit int32) ApiGetItemsByIdSimilarRequest {
	r.imageTypeLimit = &imageTypeLimit
	return r
}

// Optional. The image types to include in the output.
func (r ApiGetItemsByIdSimilarRequest) EnableImageTypes(enableImageTypes string) ApiGetItemsByIdSimilarRequest {
	r.enableImageTypes = &enableImageTypes
	return r
}

// Optional. Filter by user id, and attach user data
func (r ApiGetItemsByIdSimilarRequest) UserId(userId string) ApiGetItemsByIdSimilarRequest {
	r.userId = &userId
	return r
}

// Optional. The maximum number of records to return
func (r ApiGetItemsByIdSimilarRequest) Limit(limit int32) ApiGetItemsByIdSimilarRequest {
	r.limit = &limit
	return r
}

// Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
func (r ApiGetItemsByIdSimilarRequest) Fields(fields string) ApiGetItemsByIdSimilarRequest {
	r.fields = &fields
	return r
}

func (r ApiGetItemsByIdSimilarRequest) Execute() (*QueryResultBaseItemDto, *http.Response, error) {
	return r.ApiService.GetItemsByIdSimilarExecute(r)
}

/*
GetItemsByIdSimilar Gets similar items

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Item Id
 @return ApiGetItemsByIdSimilarRequest
*/
func (a *LibraryServiceAPIService) GetItemsByIdSimilar(ctx context.Context, id string) ApiGetItemsByIdSimilarRequest {
	return ApiGetItemsByIdSimilarRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return QueryResultBaseItemDto
func (a *LibraryServiceAPIService) GetItemsByIdSimilarExecute(r ApiGetItemsByIdSimilarRequest) (*QueryResultBaseItemDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QueryResultBaseItemDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LibraryServiceAPIService.GetItemsByIdSimilar")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Items/{Id}/Similar"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.includeItemTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IncludeItemTypes", r.includeItemTypes, "form", "")
	}
	if r.enableImages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImages", r.enableImages, "form", "")
	}
	if r.enableUserData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableUserData", r.enableUserData, "form", "")
	}
	if r.imageTypeLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ImageTypeLimit", r.imageTypeLimit, "form", "")
	}
	if r.enableImageTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImageTypes", r.enableImageTypes, "form", "")
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "UserId", r.userId, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Limit", r.limit, "form", "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Fields", r.fields, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetItemsByIdThememediaRequest struct {
	ctx context.Context
	ApiService LibraryServiceAPI
	id string
	userId *string
	inheritFromParent *bool
}

// Optional. Filter by user id, and attach user data
func (r ApiGetItemsByIdThememediaRequest) UserId(userId string) ApiGetItemsByIdThememediaRequest {
	r.userId = &userId
	return r
}

// Determines whether or not parent items should be searched for theme media.
func (r ApiGetItemsByIdThememediaRequest) InheritFromParent(inheritFromParent bool) ApiGetItemsByIdThememediaRequest {
	r.inheritFromParent = &inheritFromParent
	return r
}

func (r ApiGetItemsByIdThememediaRequest) Execute() (*AllThemeMediaResult, *http.Response, error) {
	return r.ApiService.GetItemsByIdThememediaExecute(r)
}

/*
GetItemsByIdThememedia Gets theme videos and songs for an item

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Item Id
 @return ApiGetItemsByIdThememediaRequest
*/
func (a *LibraryServiceAPIService) GetItemsByIdThememedia(ctx context.Context, id string) ApiGetItemsByIdThememediaRequest {
	return ApiGetItemsByIdThememediaRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return AllThemeMediaResult
func (a *LibraryServiceAPIService) GetItemsByIdThememediaExecute(r ApiGetItemsByIdThememediaRequest) (*AllThemeMediaResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AllThemeMediaResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LibraryServiceAPIService.GetItemsByIdThememedia")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Items/{Id}/ThemeMedia"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "UserId", r.userId, "form", "")
	}
	if r.inheritFromParent != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "InheritFromParent", r.inheritFromParent, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetItemsByIdThemesongsRequest struct {
	ctx context.Context
	ApiService LibraryServiceAPI
	id string
	userId *string
	inheritFromParent *bool
}

// Optional. Filter by user id, and attach user data
func (r ApiGetItemsByIdThemesongsRequest) UserId(userId string) ApiGetItemsByIdThemesongsRequest {
	r.userId = &userId
	return r
}

// Determines whether or not parent items should be searched for theme media.
func (r ApiGetItemsByIdThemesongsRequest) InheritFromParent(inheritFromParent bool) ApiGetItemsByIdThemesongsRequest {
	r.inheritFromParent = &inheritFromParent
	return r
}

func (r ApiGetItemsByIdThemesongsRequest) Execute() (*ThemeMediaResult, *http.Response, error) {
	return r.ApiService.GetItemsByIdThemesongsExecute(r)
}

/*
GetItemsByIdThemesongs Gets theme songs for an item

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Item Id
 @return ApiGetItemsByIdThemesongsRequest
*/
func (a *LibraryServiceAPIService) GetItemsByIdThemesongs(ctx context.Context, id string) ApiGetItemsByIdThemesongsRequest {
	return ApiGetItemsByIdThemesongsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ThemeMediaResult
func (a *LibraryServiceAPIService) GetItemsByIdThemesongsExecute(r ApiGetItemsByIdThemesongsRequest) (*ThemeMediaResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ThemeMediaResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LibraryServiceAPIService.GetItemsByIdThemesongs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Items/{Id}/ThemeSongs"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "UserId", r.userId, "form", "")
	}
	if r.inheritFromParent != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "InheritFromParent", r.inheritFromParent, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetItemsByIdThemevideosRequest struct {
	ctx context.Context
	ApiService LibraryServiceAPI
	id string
	userId *string
	inheritFromParent *bool
}

// Optional. Filter by user id, and attach user data
func (r ApiGetItemsByIdThemevideosRequest) UserId(userId string) ApiGetItemsByIdThemevideosRequest {
	r.userId = &userId
	return r
}

// Determines whether or not parent items should be searched for theme media.
func (r ApiGetItemsByIdThemevideosRequest) InheritFromParent(inheritFromParent bool) ApiGetItemsByIdThemevideosRequest {
	r.inheritFromParent = &inheritFromParent
	return r
}

func (r ApiGetItemsByIdThemevideosRequest) Execute() (*ThemeMediaResult, *http.Response, error) {
	return r.ApiService.GetItemsByIdThemevideosExecute(r)
}

/*
GetItemsByIdThemevideos Gets theme videos for an item

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Item Id
 @return ApiGetItemsByIdThemevideosRequest
*/
func (a *LibraryServiceAPIService) GetItemsByIdThemevideos(ctx context.Context, id string) ApiGetItemsByIdThemevideosRequest {
	return ApiGetItemsByIdThemevideosRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ThemeMediaResult
func (a *LibraryServiceAPIService) GetItemsByIdThemevideosExecute(r ApiGetItemsByIdThemevideosRequest) (*ThemeMediaResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ThemeMediaResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LibraryServiceAPIService.GetItemsByIdThemevideos")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Items/{Id}/ThemeVideos"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "UserId", r.userId, "form", "")
	}
	if r.inheritFromParent != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "InheritFromParent", r.inheritFromParent, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetItemsCountsRequest struct {
	ctx context.Context
	ApiService LibraryServiceAPI
	userId *string
	isFavorite *bool
}

// Optional. Get counts from a specific user&#39;s library.
func (r ApiGetItemsCountsRequest) UserId(userId string) ApiGetItemsCountsRequest {
	r.userId = &userId
	return r
}

// Optional. Get counts of favorite items
func (r ApiGetItemsCountsRequest) IsFavorite(isFavorite bool) ApiGetItemsCountsRequest {
	r.isFavorite = &isFavorite
	return r
}

func (r ApiGetItemsCountsRequest) Execute() (*ItemCounts, *http.Response, error) {
	return r.ApiService.GetItemsCountsExecute(r)
}

/*
GetItemsCounts Method for GetItemsCounts

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetItemsCountsRequest
*/
func (a *LibraryServiceAPIService) GetItemsCounts(ctx context.Context) ApiGetItemsCountsRequest {
	return ApiGetItemsCountsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ItemCounts
func (a *LibraryServiceAPIService) GetItemsCountsExecute(r ApiGetItemsCountsRequest) (*ItemCounts, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ItemCounts
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LibraryServiceAPIService.GetItemsCounts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Items/Counts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "UserId", r.userId, "form", "")
	}
	if r.isFavorite != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsFavorite", r.isFavorite, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetLibrariesAvailableoptionsRequest struct {
	ctx context.Context
	ApiService LibraryServiceAPI
}

func (r ApiGetLibrariesAvailableoptionsRequest) Execute() (*LibraryLibraryOptionsResult, *http.Response, error) {
	return r.ApiService.GetLibrariesAvailableoptionsExecute(r)
}

/*
GetLibrariesAvailableoptions Method for GetLibrariesAvailableoptions

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetLibrariesAvailableoptionsRequest
*/
func (a *LibraryServiceAPIService) GetLibrariesAvailableoptions(ctx context.Context) ApiGetLibrariesAvailableoptionsRequest {
	return ApiGetLibrariesAvailableoptionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return LibraryLibraryOptionsResult
func (a *LibraryServiceAPIService) GetLibrariesAvailableoptionsExecute(r ApiGetLibrariesAvailableoptionsRequest) (*LibraryLibraryOptionsResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LibraryLibraryOptionsResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LibraryServiceAPIService.GetLibrariesAvailableoptions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Libraries/AvailableOptions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetLibraryMediafoldersRequest struct {
	ctx context.Context
	ApiService LibraryServiceAPI
	isHidden *bool
}

// Optional. Filter by folders that are marked hidden, or not.
func (r ApiGetLibraryMediafoldersRequest) IsHidden(isHidden bool) ApiGetLibraryMediafoldersRequest {
	r.isHidden = &isHidden
	return r
}

func (r ApiGetLibraryMediafoldersRequest) Execute() (*QueryResultBaseItemDto, *http.Response, error) {
	return r.ApiService.GetLibraryMediafoldersExecute(r)
}

/*
GetLibraryMediafolders Gets all user media folders.

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetLibraryMediafoldersRequest
*/
func (a *LibraryServiceAPIService) GetLibraryMediafolders(ctx context.Context) ApiGetLibraryMediafoldersRequest {
	return ApiGetLibraryMediafoldersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return QueryResultBaseItemDto
func (a *LibraryServiceAPIService) GetLibraryMediafoldersExecute(r ApiGetLibraryMediafoldersRequest) (*QueryResultBaseItemDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QueryResultBaseItemDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LibraryServiceAPIService.GetLibraryMediafolders")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Library/MediaFolders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.isHidden != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsHidden", r.isHidden, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetLibraryPhysicalpathsRequest struct {
	ctx context.Context
	ApiService LibraryServiceAPI
}

func (r ApiGetLibraryPhysicalpathsRequest) Execute() ([]string, *http.Response, error) {
	return r.ApiService.GetLibraryPhysicalpathsExecute(r)
}

/*
GetLibraryPhysicalpaths Gets a list of physical paths from virtual folders

Requires authentication as administrator

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetLibraryPhysicalpathsRequest
*/
func (a *LibraryServiceAPIService) GetLibraryPhysicalpaths(ctx context.Context) ApiGetLibraryPhysicalpathsRequest {
	return ApiGetLibraryPhysicalpathsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []string
func (a *LibraryServiceAPIService) GetLibraryPhysicalpathsExecute(r ApiGetLibraryPhysicalpathsRequest) ([]string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LibraryServiceAPIService.GetLibraryPhysicalpaths")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Library/PhysicalPaths"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetLibrarySelectablemediafoldersRequest struct {
	ctx context.Context
	ApiService LibraryServiceAPI
}

func (r ApiGetLibrarySelectablemediafoldersRequest) Execute() ([]LibraryMediaFolder, *http.Response, error) {
	return r.ApiService.GetLibrarySelectablemediafoldersExecute(r)
}

/*
GetLibrarySelectablemediafolders Gets all user media folders.

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetLibrarySelectablemediafoldersRequest
*/
func (a *LibraryServiceAPIService) GetLibrarySelectablemediafolders(ctx context.Context) ApiGetLibrarySelectablemediafoldersRequest {
	return ApiGetLibrarySelectablemediafoldersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []LibraryMediaFolder
func (a *LibraryServiceAPIService) GetLibrarySelectablemediafoldersExecute(r ApiGetLibrarySelectablemediafoldersRequest) ([]LibraryMediaFolder, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []LibraryMediaFolder
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LibraryServiceAPIService.GetLibrarySelectablemediafolders")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Library/SelectableMediaFolders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMoviesByIdSimilarRequest struct {
	ctx context.Context
	ApiService LibraryServiceAPI
	id string
	includeItemTypes *string
	enableImages *bool
	enableUserData *bool
	imageTypeLimit *int32
	enableImageTypes *string
	userId *string
	limit *int32
	fields *string
}

// Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
func (r ApiGetMoviesByIdSimilarRequest) IncludeItemTypes(includeItemTypes string) ApiGetMoviesByIdSimilarRequest {
	r.includeItemTypes = &includeItemTypes
	return r
}

// Optional, include image information in output
func (r ApiGetMoviesByIdSimilarRequest) EnableImages(enableImages bool) ApiGetMoviesByIdSimilarRequest {
	r.enableImages = &enableImages
	return r
}

// Optional, include user data
func (r ApiGetMoviesByIdSimilarRequest) EnableUserData(enableUserData bool) ApiGetMoviesByIdSimilarRequest {
	r.enableUserData = &enableUserData
	return r
}

// Optional, the max number of images to return, per image type
func (r ApiGetMoviesByIdSimilarRequest) ImageTypeLimit(imageTypeLimit int32) ApiGetMoviesByIdSimilarRequest {
	r.imageTypeLimit = &imageTypeLimit
	return r
}

// Optional. The image types to include in the output.
func (r ApiGetMoviesByIdSimilarRequest) EnableImageTypes(enableImageTypes string) ApiGetMoviesByIdSimilarRequest {
	r.enableImageTypes = &enableImageTypes
	return r
}

// Optional. Filter by user id, and attach user data
func (r ApiGetMoviesByIdSimilarRequest) UserId(userId string) ApiGetMoviesByIdSimilarRequest {
	r.userId = &userId
	return r
}

// Optional. The maximum number of records to return
func (r ApiGetMoviesByIdSimilarRequest) Limit(limit int32) ApiGetMoviesByIdSimilarRequest {
	r.limit = &limit
	return r
}

// Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
func (r ApiGetMoviesByIdSimilarRequest) Fields(fields string) ApiGetMoviesByIdSimilarRequest {
	r.fields = &fields
	return r
}

func (r ApiGetMoviesByIdSimilarRequest) Execute() (*QueryResultBaseItemDto, *http.Response, error) {
	return r.ApiService.GetMoviesByIdSimilarExecute(r)
}

/*
GetMoviesByIdSimilar Finds movies and trailers similar to a given movie.

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Item Id
 @return ApiGetMoviesByIdSimilarRequest
*/
func (a *LibraryServiceAPIService) GetMoviesByIdSimilar(ctx context.Context, id string) ApiGetMoviesByIdSimilarRequest {
	return ApiGetMoviesByIdSimilarRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return QueryResultBaseItemDto
func (a *LibraryServiceAPIService) GetMoviesByIdSimilarExecute(r ApiGetMoviesByIdSimilarRequest) (*QueryResultBaseItemDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QueryResultBaseItemDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LibraryServiceAPIService.GetMoviesByIdSimilar")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Movies/{Id}/Similar"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.includeItemTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IncludeItemTypes", r.includeItemTypes, "form", "")
	}
	if r.enableImages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImages", r.enableImages, "form", "")
	}
	if r.enableUserData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableUserData", r.enableUserData, "form", "")
	}
	if r.imageTypeLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ImageTypeLimit", r.imageTypeLimit, "form", "")
	}
	if r.enableImageTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImageTypes", r.enableImageTypes, "form", "")
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "UserId", r.userId, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Limit", r.limit, "form", "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Fields", r.fields, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetShowsByIdSimilarRequest struct {
	ctx context.Context
	ApiService LibraryServiceAPI
	id string
	includeItemTypes *string
	enableImages *bool
	enableUserData *bool
	imageTypeLimit *int32
	enableImageTypes *string
	userId *string
	limit *int32
	fields *string
}

// Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
func (r ApiGetShowsByIdSimilarRequest) IncludeItemTypes(includeItemTypes string) ApiGetShowsByIdSimilarRequest {
	r.includeItemTypes = &includeItemTypes
	return r
}

// Optional, include image information in output
func (r ApiGetShowsByIdSimilarRequest) EnableImages(enableImages bool) ApiGetShowsByIdSimilarRequest {
	r.enableImages = &enableImages
	return r
}

// Optional, include user data
func (r ApiGetShowsByIdSimilarRequest) EnableUserData(enableUserData bool) ApiGetShowsByIdSimilarRequest {
	r.enableUserData = &enableUserData
	return r
}

// Optional, the max number of images to return, per image type
func (r ApiGetShowsByIdSimilarRequest) ImageTypeLimit(imageTypeLimit int32) ApiGetShowsByIdSimilarRequest {
	r.imageTypeLimit = &imageTypeLimit
	return r
}

// Optional. The image types to include in the output.
func (r ApiGetShowsByIdSimilarRequest) EnableImageTypes(enableImageTypes string) ApiGetShowsByIdSimilarRequest {
	r.enableImageTypes = &enableImageTypes
	return r
}

// Optional. Filter by user id, and attach user data
func (r ApiGetShowsByIdSimilarRequest) UserId(userId string) ApiGetShowsByIdSimilarRequest {
	r.userId = &userId
	return r
}

// Optional. The maximum number of records to return
func (r ApiGetShowsByIdSimilarRequest) Limit(limit int32) ApiGetShowsByIdSimilarRequest {
	r.limit = &limit
	return r
}

// Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
func (r ApiGetShowsByIdSimilarRequest) Fields(fields string) ApiGetShowsByIdSimilarRequest {
	r.fields = &fields
	return r
}

func (r ApiGetShowsByIdSimilarRequest) Execute() (*QueryResultBaseItemDto, *http.Response, error) {
	return r.ApiService.GetShowsByIdSimilarExecute(r)
}

/*
GetShowsByIdSimilar Finds tv shows similar to a given one.

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Item Id
 @return ApiGetShowsByIdSimilarRequest
*/
func (a *LibraryServiceAPIService) GetShowsByIdSimilar(ctx context.Context, id string) ApiGetShowsByIdSimilarRequest {
	return ApiGetShowsByIdSimilarRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return QueryResultBaseItemDto
func (a *LibraryServiceAPIService) GetShowsByIdSimilarExecute(r ApiGetShowsByIdSimilarRequest) (*QueryResultBaseItemDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QueryResultBaseItemDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LibraryServiceAPIService.GetShowsByIdSimilar")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Shows/{Id}/Similar"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.includeItemTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IncludeItemTypes", r.includeItemTypes, "form", "")
	}
	if r.enableImages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImages", r.enableImages, "form", "")
	}
	if r.enableUserData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableUserData", r.enableUserData, "form", "")
	}
	if r.imageTypeLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ImageTypeLimit", r.imageTypeLimit, "form", "")
	}
	if r.enableImageTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImageTypes", r.enableImageTypes, "form", "")
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "UserId", r.userId, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Limit", r.limit, "form", "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Fields", r.fields, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTrailersByIdSimilarRequest struct {
	ctx context.Context
	ApiService LibraryServiceAPI
	id string
	includeItemTypes *string
	enableImages *bool
	enableUserData *bool
	imageTypeLimit *int32
	enableImageTypes *string
	userId *string
	limit *int32
	fields *string
}

// Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
func (r ApiGetTrailersByIdSimilarRequest) IncludeItemTypes(includeItemTypes string) ApiGetTrailersByIdSimilarRequest {
	r.includeItemTypes = &includeItemTypes
	return r
}

// Optional, include image information in output
func (r ApiGetTrailersByIdSimilarRequest) EnableImages(enableImages bool) ApiGetTrailersByIdSimilarRequest {
	r.enableImages = &enableImages
	return r
}

// Optional, include user data
func (r ApiGetTrailersByIdSimilarRequest) EnableUserData(enableUserData bool) ApiGetTrailersByIdSimilarRequest {
	r.enableUserData = &enableUserData
	return r
}

// Optional, the max number of images to return, per image type
func (r ApiGetTrailersByIdSimilarRequest) ImageTypeLimit(imageTypeLimit int32) ApiGetTrailersByIdSimilarRequest {
	r.imageTypeLimit = &imageTypeLimit
	return r
}

// Optional. The image types to include in the output.
func (r ApiGetTrailersByIdSimilarRequest) EnableImageTypes(enableImageTypes string) ApiGetTrailersByIdSimilarRequest {
	r.enableImageTypes = &enableImageTypes
	return r
}

// Optional. Filter by user id, and attach user data
func (r ApiGetTrailersByIdSimilarRequest) UserId(userId string) ApiGetTrailersByIdSimilarRequest {
	r.userId = &userId
	return r
}

// Optional. The maximum number of records to return
func (r ApiGetTrailersByIdSimilarRequest) Limit(limit int32) ApiGetTrailersByIdSimilarRequest {
	r.limit = &limit
	return r
}

// Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
func (r ApiGetTrailersByIdSimilarRequest) Fields(fields string) ApiGetTrailersByIdSimilarRequest {
	r.fields = &fields
	return r
}

func (r ApiGetTrailersByIdSimilarRequest) Execute() (*QueryResultBaseItemDto, *http.Response, error) {
	return r.ApiService.GetTrailersByIdSimilarExecute(r)
}

/*
GetTrailersByIdSimilar Finds movies and trailers similar to a given trailer.

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Item Id
 @return ApiGetTrailersByIdSimilarRequest
*/
func (a *LibraryServiceAPIService) GetTrailersByIdSimilar(ctx context.Context, id string) ApiGetTrailersByIdSimilarRequest {
	return ApiGetTrailersByIdSimilarRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return QueryResultBaseItemDto
func (a *LibraryServiceAPIService) GetTrailersByIdSimilarExecute(r ApiGetTrailersByIdSimilarRequest) (*QueryResultBaseItemDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QueryResultBaseItemDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LibraryServiceAPIService.GetTrailersByIdSimilar")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Trailers/{Id}/Similar"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.includeItemTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IncludeItemTypes", r.includeItemTypes, "form", "")
	}
	if r.enableImages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImages", r.enableImages, "form", "")
	}
	if r.enableUserData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableUserData", r.enableUserData, "form", "")
	}
	if r.imageTypeLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ImageTypeLimit", r.imageTypeLimit, "form", "")
	}
	if r.enableImageTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImageTypes", r.enableImageTypes, "form", "")
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "UserId", r.userId, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Limit", r.limit, "form", "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Fields", r.fields, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostLibraryMediaUpdatedRequest struct {
	ctx context.Context
	ApiService LibraryServiceAPI
	libraryPostUpdatedMedia *LibraryPostUpdatedMedia
}

// PostUpdatedMedia
func (r ApiPostLibraryMediaUpdatedRequest) LibraryPostUpdatedMedia(libraryPostUpdatedMedia LibraryPostUpdatedMedia) ApiPostLibraryMediaUpdatedRequest {
	r.libraryPostUpdatedMedia = &libraryPostUpdatedMedia
	return r
}

func (r ApiPostLibraryMediaUpdatedRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostLibraryMediaUpdatedExecute(r)
}

/*
PostLibraryMediaUpdated Reports that new movies have been added by an external source

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostLibraryMediaUpdatedRequest
*/
func (a *LibraryServiceAPIService) PostLibraryMediaUpdated(ctx context.Context) ApiPostLibraryMediaUpdatedRequest {
	return ApiPostLibraryMediaUpdatedRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *LibraryServiceAPIService) PostLibraryMediaUpdatedExecute(r ApiPostLibraryMediaUpdatedRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LibraryServiceAPIService.PostLibraryMediaUpdated")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Library/Media/Updated"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.libraryPostUpdatedMedia == nil {
		return nil, reportError("libraryPostUpdatedMedia is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.libraryPostUpdatedMedia
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostLibraryMoviesAddedRequest struct {
	ctx context.Context
	ApiService LibraryServiceAPI
}

func (r ApiPostLibraryMoviesAddedRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostLibraryMoviesAddedExecute(r)
}

/*
PostLibraryMoviesAdded Deprecated. Use /Library/Media/Updated

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostLibraryMoviesAddedRequest
*/
func (a *LibraryServiceAPIService) PostLibraryMoviesAdded(ctx context.Context) ApiPostLibraryMoviesAddedRequest {
	return ApiPostLibraryMoviesAddedRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *LibraryServiceAPIService) PostLibraryMoviesAddedExecute(r ApiPostLibraryMoviesAddedRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LibraryServiceAPIService.PostLibraryMoviesAdded")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Library/Movies/Added"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostLibraryMoviesUpdatedRequest struct {
	ctx context.Context
	ApiService LibraryServiceAPI
}

func (r ApiPostLibraryMoviesUpdatedRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostLibraryMoviesUpdatedExecute(r)
}

/*
PostLibraryMoviesUpdated Deprecated. Use /Library/Media/Updated

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostLibraryMoviesUpdatedRequest
*/
func (a *LibraryServiceAPIService) PostLibraryMoviesUpdated(ctx context.Context) ApiPostLibraryMoviesUpdatedRequest {
	return ApiPostLibraryMoviesUpdatedRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *LibraryServiceAPIService) PostLibraryMoviesUpdatedExecute(r ApiPostLibraryMoviesUpdatedRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LibraryServiceAPIService.PostLibraryMoviesUpdated")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Library/Movies/Updated"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostLibraryRefreshRequest struct {
	ctx context.Context
	ApiService LibraryServiceAPI
}

func (r ApiPostLibraryRefreshRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostLibraryRefreshExecute(r)
}

/*
PostLibraryRefresh Starts a library scan

Requires authentication as administrator

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostLibraryRefreshRequest
*/
func (a *LibraryServiceAPIService) PostLibraryRefresh(ctx context.Context) ApiPostLibraryRefreshRequest {
	return ApiPostLibraryRefreshRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *LibraryServiceAPIService) PostLibraryRefreshExecute(r ApiPostLibraryRefreshRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LibraryServiceAPIService.PostLibraryRefresh")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Library/Refresh"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostLibrarySeriesAddedRequest struct {
	ctx context.Context
	ApiService LibraryServiceAPI
}

func (r ApiPostLibrarySeriesAddedRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostLibrarySeriesAddedExecute(r)
}

/*
PostLibrarySeriesAdded Deprecated. Use /Library/Media/Updated

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostLibrarySeriesAddedRequest
*/
func (a *LibraryServiceAPIService) PostLibrarySeriesAdded(ctx context.Context) ApiPostLibrarySeriesAddedRequest {
	return ApiPostLibrarySeriesAddedRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *LibraryServiceAPIService) PostLibrarySeriesAddedExecute(r ApiPostLibrarySeriesAddedRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LibraryServiceAPIService.PostLibrarySeriesAdded")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Library/Series/Added"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostLibrarySeriesUpdatedRequest struct {
	ctx context.Context
	ApiService LibraryServiceAPI
}

func (r ApiPostLibrarySeriesUpdatedRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostLibrarySeriesUpdatedExecute(r)
}

/*
PostLibrarySeriesUpdated Deprecated. Use /Library/Media/Updated

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostLibrarySeriesUpdatedRequest
*/
func (a *LibraryServiceAPIService) PostLibrarySeriesUpdated(ctx context.Context) ApiPostLibrarySeriesUpdatedRequest {
	return ApiPostLibrarySeriesUpdatedRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *LibraryServiceAPIService) PostLibrarySeriesUpdatedExecute(r ApiPostLibrarySeriesUpdatedRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LibraryServiceAPIService.PostLibrarySeriesUpdated")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Library/Series/Updated"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
