/*
Emby Server API

Explore the Emby Server API

API version: 4.1.1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package api

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"os"
)


type UserActivityAPIAPI interface {

	/*
	GetUserUsageStatsByBreakdowntypeBreakdownreport Gets a breakdown of a usage metric

	No authentication required

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param breakdownType Breakdown type
	@return ApiGetUserUsageStatsByBreakdowntypeBreakdownreportRequest
	*/
	GetUserUsageStatsByBreakdowntypeBreakdownreport(ctx context.Context, breakdownType string) ApiGetUserUsageStatsByBreakdowntypeBreakdownreportRequest

	// GetUserUsageStatsByBreakdowntypeBreakdownreportExecute executes the request
	//  @return map[string]interface{}
	GetUserUsageStatsByBreakdowntypeBreakdownreportExecute(r ApiGetUserUsageStatsByBreakdowntypeBreakdownreportRequest) (map[string]interface{}, *http.Response, error)

	/*
	GetUserUsageStatsByUseridByDateGetitems Gets activity for {USER} for {Date} formatted as yyyy-MM-dd

	No authentication required

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userID User Id
	@param date UTC DateTime, Format yyyy-MM-dd
	@return ApiGetUserUsageStatsByUseridByDateGetitemsRequest
	*/
	GetUserUsageStatsByUseridByDateGetitems(ctx context.Context, userID string, date string) ApiGetUserUsageStatsByUseridByDateGetitemsRequest

	// GetUserUsageStatsByUseridByDateGetitemsExecute executes the request
	//  @return map[string]interface{}
	GetUserUsageStatsByUseridByDateGetitemsExecute(r ApiGetUserUsageStatsByUseridByDateGetitemsRequest) (map[string]interface{}, *http.Response, error)

	/*
	GetUserUsageStatsDurationhistogramreport Gets duration histogram

	No authentication required

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetUserUsageStatsDurationhistogramreportRequest
	*/
	GetUserUsageStatsDurationhistogramreport(ctx context.Context) ApiGetUserUsageStatsDurationhistogramreportRequest

	// GetUserUsageStatsDurationhistogramreportExecute executes the request
	//  @return map[string]interface{}
	GetUserUsageStatsDurationhistogramreportExecute(r ApiGetUserUsageStatsDurationhistogramreportRequest) (map[string]interface{}, *http.Response, error)

	/*
	GetUserUsageStatsHourlyreport Gets a report of the available activity per hour

	No authentication required

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetUserUsageStatsHourlyreportRequest
	*/
	GetUserUsageStatsHourlyreport(ctx context.Context) ApiGetUserUsageStatsHourlyreportRequest

	// GetUserUsageStatsHourlyreportExecute executes the request
	//  @return map[string]interface{}
	GetUserUsageStatsHourlyreportExecute(r ApiGetUserUsageStatsHourlyreportRequest) (map[string]interface{}, *http.Response, error)

	/*
	GetUserUsageStatsLoadBackup Loads a backup from a file

	No authentication required

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetUserUsageStatsLoadBackupRequest
	*/
	GetUserUsageStatsLoadBackup(ctx context.Context) ApiGetUserUsageStatsLoadBackupRequest

	// GetUserUsageStatsLoadBackupExecute executes the request
	//  @return map[string]interface{}
	GetUserUsageStatsLoadBackupExecute(r ApiGetUserUsageStatsLoadBackupRequest) (map[string]interface{}, *http.Response, error)

	/*
	GetUserUsageStatsMoviesreport Gets Movies counts

	No authentication required

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetUserUsageStatsMoviesreportRequest
	*/
	GetUserUsageStatsMoviesreport(ctx context.Context) ApiGetUserUsageStatsMoviesreportRequest

	// GetUserUsageStatsMoviesreportExecute executes the request
	//  @return map[string]interface{}
	GetUserUsageStatsMoviesreportExecute(r ApiGetUserUsageStatsMoviesreportRequest) (map[string]interface{}, *http.Response, error)

	/*
	GetUserUsageStatsPlayactivity Gets play activity for number of days

	No authentication required

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetUserUsageStatsPlayactivityRequest
	*/
	GetUserUsageStatsPlayactivity(ctx context.Context) ApiGetUserUsageStatsPlayactivityRequest

	// GetUserUsageStatsPlayactivityExecute executes the request
	//  @return map[string]interface{}
	GetUserUsageStatsPlayactivityExecute(r ApiGetUserUsageStatsPlayactivityRequest) (map[string]interface{}, *http.Response, error)

	/*
	GetUserUsageStatsProcessList Gets a list of process Info

	No authentication required

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetUserUsageStatsProcessListRequest
	*/
	GetUserUsageStatsProcessList(ctx context.Context) ApiGetUserUsageStatsProcessListRequest

	// GetUserUsageStatsProcessListExecute executes the request
	//  @return map[string]interface{}
	GetUserUsageStatsProcessListExecute(r ApiGetUserUsageStatsProcessListRequest) (map[string]interface{}, *http.Response, error)

	/*
	GetUserUsageStatsResourceUsage Gets Resource Usage Info

	No authentication required

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetUserUsageStatsResourceUsageRequest
	*/
	GetUserUsageStatsResourceUsage(ctx context.Context) ApiGetUserUsageStatsResourceUsageRequest

	// GetUserUsageStatsResourceUsageExecute executes the request
	//  @return map[string]interface{}
	GetUserUsageStatsResourceUsageExecute(r ApiGetUserUsageStatsResourceUsageRequest) (map[string]interface{}, *http.Response, error)

	/*
	GetUserUsageStatsSaveBackup Saves a backup of the playback report data to the backup path

	No authentication required

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetUserUsageStatsSaveBackupRequest
	*/
	GetUserUsageStatsSaveBackup(ctx context.Context) ApiGetUserUsageStatsSaveBackupRequest

	// GetUserUsageStatsSaveBackupExecute executes the request
	//  @return map[string]interface{}
	GetUserUsageStatsSaveBackupExecute(r ApiGetUserUsageStatsSaveBackupRequest) (map[string]interface{}, *http.Response, error)

	/*
	GetUserUsageStatsSessionList Gets Session Info

	No authentication required

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetUserUsageStatsSessionListRequest
	*/
	GetUserUsageStatsSessionList(ctx context.Context) ApiGetUserUsageStatsSessionListRequest

	// GetUserUsageStatsSessionListExecute executes the request
	//  @return map[string]interface{}
	GetUserUsageStatsSessionListExecute(r ApiGetUserUsageStatsSessionListRequest) (map[string]interface{}, *http.Response, error)

	/*
	GetUserUsageStatsTvshowsreport Gets TV Shows counts

	No authentication required

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetUserUsageStatsTvshowsreportRequest
	*/
	GetUserUsageStatsTvshowsreport(ctx context.Context) ApiGetUserUsageStatsTvshowsreportRequest

	// GetUserUsageStatsTvshowsreportExecute executes the request
	//  @return map[string]interface{}
	GetUserUsageStatsTvshowsreportExecute(r ApiGetUserUsageStatsTvshowsreportRequest) (map[string]interface{}, *http.Response, error)

	/*
	GetUserUsageStatsTypeFilterList Gets types filter list items

	No authentication required

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetUserUsageStatsTypeFilterListRequest
	*/
	GetUserUsageStatsTypeFilterList(ctx context.Context) ApiGetUserUsageStatsTypeFilterListRequest

	// GetUserUsageStatsTypeFilterListExecute executes the request
	//  @return map[string]interface{}
	GetUserUsageStatsTypeFilterListExecute(r ApiGetUserUsageStatsTypeFilterListRequest) (map[string]interface{}, *http.Response, error)

	/*
	GetUserUsageStatsUserActivity Gets a report of the available activity per hour

	No authentication required

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetUserUsageStatsUserActivityRequest
	*/
	GetUserUsageStatsUserActivity(ctx context.Context) ApiGetUserUsageStatsUserActivityRequest

	// GetUserUsageStatsUserActivityExecute executes the request
	//  @return map[string]interface{}
	GetUserUsageStatsUserActivityExecute(r ApiGetUserUsageStatsUserActivityRequest) (map[string]interface{}, *http.Response, error)

	/*
	GetUserUsageStatsUserList Get users

	No authentication required

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetUserUsageStatsUserListRequest
	*/
	GetUserUsageStatsUserList(ctx context.Context) ApiGetUserUsageStatsUserListRequest

	// GetUserUsageStatsUserListExecute executes the request
	//  @return map[string]interface{}
	GetUserUsageStatsUserListExecute(r ApiGetUserUsageStatsUserListRequest) (map[string]interface{}, *http.Response, error)

	/*
	GetUserUsageStatsUserManageByActionById Get users

	No authentication required

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param action action to perform
	@param id user Id to perform the action on
	@return ApiGetUserUsageStatsUserManageByActionByIdRequest
	*/
	GetUserUsageStatsUserManageByActionById(ctx context.Context, action string, id string) ApiGetUserUsageStatsUserManageByActionByIdRequest

	// GetUserUsageStatsUserManageByActionByIdExecute executes the request
	//  @return map[string]interface{}
	GetUserUsageStatsUserManageByActionByIdExecute(r ApiGetUserUsageStatsUserManageByActionByIdRequest) (map[string]interface{}, *http.Response, error)

	/*
	GetUserUsageStatsUserplaylist Gets a report of all played items for a user in a date period

	No authentication required

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetUserUsageStatsUserplaylistRequest
	*/
	GetUserUsageStatsUserplaylist(ctx context.Context) ApiGetUserUsageStatsUserplaylistRequest

	// GetUserUsageStatsUserplaylistExecute executes the request
	//  @return map[string]interface{}
	GetUserUsageStatsUserplaylistExecute(r ApiGetUserUsageStatsUserplaylistRequest) (map[string]interface{}, *http.Response, error)

	/*
	PostUserUsageStatsImportBackup Post a backup for importing

	No authentication required

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostUserUsageStatsImportBackupRequest
	*/
	PostUserUsageStatsImportBackup(ctx context.Context) ApiPostUserUsageStatsImportBackupRequest

	// PostUserUsageStatsImportBackupExecute executes the request
	PostUserUsageStatsImportBackupExecute(r ApiPostUserUsageStatsImportBackupRequest) (*http.Response, error)

	/*
	PostUserUsageStatsSubmitCustomQuery Submit an SQL query

	No authentication required

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostUserUsageStatsSubmitCustomQueryRequest
	*/
	PostUserUsageStatsSubmitCustomQuery(ctx context.Context) ApiPostUserUsageStatsSubmitCustomQueryRequest

	// PostUserUsageStatsSubmitCustomQueryExecute executes the request
	//  @return map[string]interface{}
	PostUserUsageStatsSubmitCustomQueryExecute(r ApiPostUserUsageStatsSubmitCustomQueryRequest) (map[string]interface{}, *http.Response, error)
}

// UserActivityAPIAPIService UserActivityAPIAPI service
type UserActivityAPIAPIService service

type ApiGetUserUsageStatsByBreakdowntypeBreakdownreportRequest struct {
	ctx context.Context
	ApiService UserActivityAPIAPI
	breakdownType string
	days *int32
	endDate *string
}

// Number of Days
func (r ApiGetUserUsageStatsByBreakdowntypeBreakdownreportRequest) Days(days int32) ApiGetUserUsageStatsByBreakdowntypeBreakdownreportRequest {
	r.days = &days
	return r
}

// End date of the report in yyyy-MM-dd format
func (r ApiGetUserUsageStatsByBreakdowntypeBreakdownreportRequest) EndDate(endDate string) ApiGetUserUsageStatsByBreakdowntypeBreakdownreportRequest {
	r.endDate = &endDate
	return r
}

func (r ApiGetUserUsageStatsByBreakdowntypeBreakdownreportRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetUserUsageStatsByBreakdowntypeBreakdownreportExecute(r)
}

/*
GetUserUsageStatsByBreakdowntypeBreakdownreport Gets a breakdown of a usage metric

No authentication required

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param breakdownType Breakdown type
 @return ApiGetUserUsageStatsByBreakdowntypeBreakdownreportRequest
*/
func (a *UserActivityAPIAPIService) GetUserUsageStatsByBreakdowntypeBreakdownreport(ctx context.Context, breakdownType string) ApiGetUserUsageStatsByBreakdowntypeBreakdownreportRequest {
	return ApiGetUserUsageStatsByBreakdowntypeBreakdownreportRequest{
		ApiService: a,
		ctx: ctx,
		breakdownType: breakdownType,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *UserActivityAPIAPIService) GetUserUsageStatsByBreakdowntypeBreakdownreportExecute(r ApiGetUserUsageStatsByBreakdowntypeBreakdownreportRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserActivityAPIAPIService.GetUserUsageStatsByBreakdowntypeBreakdownreport")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user_usage_stats/{BreakdownType}/BreakdownReport"
	localVarPath = strings.Replace(localVarPath, "{"+"BreakdownType"+"}", url.PathEscape(parameterValueToString(r.breakdownType, "breakdownType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.days != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "days", r.days, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUserUsageStatsByUseridByDateGetitemsRequest struct {
	ctx context.Context
	ApiService UserActivityAPIAPI
	userID string
	date string
	filter *string
}

// Comma separated list of media types to filter (movies,series)
func (r ApiGetUserUsageStatsByUseridByDateGetitemsRequest) Filter(filter string) ApiGetUserUsageStatsByUseridByDateGetitemsRequest {
	r.filter = &filter
	return r
}

func (r ApiGetUserUsageStatsByUseridByDateGetitemsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetUserUsageStatsByUseridByDateGetitemsExecute(r)
}

/*
GetUserUsageStatsByUseridByDateGetitems Gets activity for {USER} for {Date} formatted as yyyy-MM-dd

No authentication required

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userID User Id
 @param date UTC DateTime, Format yyyy-MM-dd
 @return ApiGetUserUsageStatsByUseridByDateGetitemsRequest
*/
func (a *UserActivityAPIAPIService) GetUserUsageStatsByUseridByDateGetitems(ctx context.Context, userID string, date string) ApiGetUserUsageStatsByUseridByDateGetitemsRequest {
	return ApiGetUserUsageStatsByUseridByDateGetitemsRequest{
		ApiService: a,
		ctx: ctx,
		userID: userID,
		date: date,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *UserActivityAPIAPIService) GetUserUsageStatsByUseridByDateGetitemsExecute(r ApiGetUserUsageStatsByUseridByDateGetitemsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserActivityAPIAPIService.GetUserUsageStatsByUseridByDateGetitems")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user_usage_stats/{UserID}/{Date}/GetItems"
	localVarPath = strings.Replace(localVarPath, "{"+"UserID"+"}", url.PathEscape(parameterValueToString(r.userID, "userID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Date"+"}", url.PathEscape(parameterValueToString(r.date, "date")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Filter", r.filter, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUserUsageStatsDurationhistogramreportRequest struct {
	ctx context.Context
	ApiService UserActivityAPIAPI
	days *int32
	endDate *string
	filter *string
}

// Number of Days
func (r ApiGetUserUsageStatsDurationhistogramreportRequest) Days(days int32) ApiGetUserUsageStatsDurationhistogramreportRequest {
	r.days = &days
	return r
}

// End date of the report in yyyy-MM-dd format
func (r ApiGetUserUsageStatsDurationhistogramreportRequest) EndDate(endDate string) ApiGetUserUsageStatsDurationhistogramreportRequest {
	r.endDate = &endDate
	return r
}

// Comma separated list of media types to filter (movies,series)
func (r ApiGetUserUsageStatsDurationhistogramreportRequest) Filter(filter string) ApiGetUserUsageStatsDurationhistogramreportRequest {
	r.filter = &filter
	return r
}

func (r ApiGetUserUsageStatsDurationhistogramreportRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetUserUsageStatsDurationhistogramreportExecute(r)
}

/*
GetUserUsageStatsDurationhistogramreport Gets duration histogram

No authentication required

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetUserUsageStatsDurationhistogramreportRequest
*/
func (a *UserActivityAPIAPIService) GetUserUsageStatsDurationhistogramreport(ctx context.Context) ApiGetUserUsageStatsDurationhistogramreportRequest {
	return ApiGetUserUsageStatsDurationhistogramreportRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *UserActivityAPIAPIService) GetUserUsageStatsDurationhistogramreportExecute(r ApiGetUserUsageStatsDurationhistogramreportRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserActivityAPIAPIService.GetUserUsageStatsDurationhistogramreport")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user_usage_stats/DurationHistogramReport"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.days != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "days", r.days, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUserUsageStatsHourlyreportRequest struct {
	ctx context.Context
	ApiService UserActivityAPIAPI
	days *int32
	endDate *string
	filter *string
}

// Number of Days
func (r ApiGetUserUsageStatsHourlyreportRequest) Days(days int32) ApiGetUserUsageStatsHourlyreportRequest {
	r.days = &days
	return r
}

// End date of the report in yyyy-MM-dd format
func (r ApiGetUserUsageStatsHourlyreportRequest) EndDate(endDate string) ApiGetUserUsageStatsHourlyreportRequest {
	r.endDate = &endDate
	return r
}

// Comma separated list of media types to filter (movies,series)
func (r ApiGetUserUsageStatsHourlyreportRequest) Filter(filter string) ApiGetUserUsageStatsHourlyreportRequest {
	r.filter = &filter
	return r
}

func (r ApiGetUserUsageStatsHourlyreportRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetUserUsageStatsHourlyreportExecute(r)
}

/*
GetUserUsageStatsHourlyreport Gets a report of the available activity per hour

No authentication required

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetUserUsageStatsHourlyreportRequest
*/
func (a *UserActivityAPIAPIService) GetUserUsageStatsHourlyreport(ctx context.Context) ApiGetUserUsageStatsHourlyreportRequest {
	return ApiGetUserUsageStatsHourlyreportRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *UserActivityAPIAPIService) GetUserUsageStatsHourlyreportExecute(r ApiGetUserUsageStatsHourlyreportRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserActivityAPIAPIService.GetUserUsageStatsHourlyreport")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user_usage_stats/HourlyReport"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.days != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "days", r.days, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUserUsageStatsLoadBackupRequest struct {
	ctx context.Context
	ApiService UserActivityAPIAPI
	backupfile *string
}

// File name of file to load
func (r ApiGetUserUsageStatsLoadBackupRequest) Backupfile(backupfile string) ApiGetUserUsageStatsLoadBackupRequest {
	r.backupfile = &backupfile
	return r
}

func (r ApiGetUserUsageStatsLoadBackupRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetUserUsageStatsLoadBackupExecute(r)
}

/*
GetUserUsageStatsLoadBackup Loads a backup from a file

No authentication required

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetUserUsageStatsLoadBackupRequest
*/
func (a *UserActivityAPIAPIService) GetUserUsageStatsLoadBackup(ctx context.Context) ApiGetUserUsageStatsLoadBackupRequest {
	return ApiGetUserUsageStatsLoadBackupRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *UserActivityAPIAPIService) GetUserUsageStatsLoadBackupExecute(r ApiGetUserUsageStatsLoadBackupRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserActivityAPIAPIService.GetUserUsageStatsLoadBackup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user_usage_stats/load_backup"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.backupfile == nil {
		return localVarReturnValue, nil, reportError("backupfile is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "backupfile", r.backupfile, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUserUsageStatsMoviesreportRequest struct {
	ctx context.Context
	ApiService UserActivityAPIAPI
	days *int32
	endDate *string
}

// Number of Days
func (r ApiGetUserUsageStatsMoviesreportRequest) Days(days int32) ApiGetUserUsageStatsMoviesreportRequest {
	r.days = &days
	return r
}

// End date of the report in yyyy-MM-dd format
func (r ApiGetUserUsageStatsMoviesreportRequest) EndDate(endDate string) ApiGetUserUsageStatsMoviesreportRequest {
	r.endDate = &endDate
	return r
}

func (r ApiGetUserUsageStatsMoviesreportRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetUserUsageStatsMoviesreportExecute(r)
}

/*
GetUserUsageStatsMoviesreport Gets Movies counts

No authentication required

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetUserUsageStatsMoviesreportRequest
*/
func (a *UserActivityAPIAPIService) GetUserUsageStatsMoviesreport(ctx context.Context) ApiGetUserUsageStatsMoviesreportRequest {
	return ApiGetUserUsageStatsMoviesreportRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *UserActivityAPIAPIService) GetUserUsageStatsMoviesreportExecute(r ApiGetUserUsageStatsMoviesreportRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserActivityAPIAPIService.GetUserUsageStatsMoviesreport")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user_usage_stats/MoviesReport"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.days != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "days", r.days, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUserUsageStatsPlayactivityRequest struct {
	ctx context.Context
	ApiService UserActivityAPIAPI
	days *int32
	endDate *string
	filter *string
	dataType *string
}

// Number of Days
func (r ApiGetUserUsageStatsPlayactivityRequest) Days(days int32) ApiGetUserUsageStatsPlayactivityRequest {
	r.days = &days
	return r
}

// End date of the report in yyyy-MM-dd format
func (r ApiGetUserUsageStatsPlayactivityRequest) EndDate(endDate string) ApiGetUserUsageStatsPlayactivityRequest {
	r.endDate = &endDate
	return r
}

// Comma separated list of media types to filter (movies,series)
func (r ApiGetUserUsageStatsPlayactivityRequest) Filter(filter string) ApiGetUserUsageStatsPlayactivityRequest {
	r.filter = &filter
	return r
}

// Data type to return (count,time)
func (r ApiGetUserUsageStatsPlayactivityRequest) DataType(dataType string) ApiGetUserUsageStatsPlayactivityRequest {
	r.dataType = &dataType
	return r
}

func (r ApiGetUserUsageStatsPlayactivityRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetUserUsageStatsPlayactivityExecute(r)
}

/*
GetUserUsageStatsPlayactivity Gets play activity for number of days

No authentication required

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetUserUsageStatsPlayactivityRequest
*/
func (a *UserActivityAPIAPIService) GetUserUsageStatsPlayactivity(ctx context.Context) ApiGetUserUsageStatsPlayactivityRequest {
	return ApiGetUserUsageStatsPlayactivityRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *UserActivityAPIAPIService) GetUserUsageStatsPlayactivityExecute(r ApiGetUserUsageStatsPlayactivityRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserActivityAPIAPIService.GetUserUsageStatsPlayactivity")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user_usage_stats/PlayActivity"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.days != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "days", r.days, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "form", "")
	}
	if r.dataType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "data_type", r.dataType, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUserUsageStatsProcessListRequest struct {
	ctx context.Context
	ApiService UserActivityAPIAPI
}

func (r ApiGetUserUsageStatsProcessListRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetUserUsageStatsProcessListExecute(r)
}

/*
GetUserUsageStatsProcessList Gets a list of process Info

No authentication required

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetUserUsageStatsProcessListRequest
*/
func (a *UserActivityAPIAPIService) GetUserUsageStatsProcessList(ctx context.Context) ApiGetUserUsageStatsProcessListRequest {
	return ApiGetUserUsageStatsProcessListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *UserActivityAPIAPIService) GetUserUsageStatsProcessListExecute(r ApiGetUserUsageStatsProcessListRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserActivityAPIAPIService.GetUserUsageStatsProcessList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user_usage_stats/process_list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUserUsageStatsResourceUsageRequest struct {
	ctx context.Context
	ApiService UserActivityAPIAPI
	hours *int32
}

// Number of Hours
func (r ApiGetUserUsageStatsResourceUsageRequest) Hours(hours int32) ApiGetUserUsageStatsResourceUsageRequest {
	r.hours = &hours
	return r
}

func (r ApiGetUserUsageStatsResourceUsageRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetUserUsageStatsResourceUsageExecute(r)
}

/*
GetUserUsageStatsResourceUsage Gets Resource Usage Info

No authentication required

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetUserUsageStatsResourceUsageRequest
*/
func (a *UserActivityAPIAPIService) GetUserUsageStatsResourceUsage(ctx context.Context) ApiGetUserUsageStatsResourceUsageRequest {
	return ApiGetUserUsageStatsResourceUsageRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *UserActivityAPIAPIService) GetUserUsageStatsResourceUsageExecute(r ApiGetUserUsageStatsResourceUsageRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserActivityAPIAPIService.GetUserUsageStatsResourceUsage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user_usage_stats/resource_usage"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.hours != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hours", r.hours, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUserUsageStatsSaveBackupRequest struct {
	ctx context.Context
	ApiService UserActivityAPIAPI
}

func (r ApiGetUserUsageStatsSaveBackupRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetUserUsageStatsSaveBackupExecute(r)
}

/*
GetUserUsageStatsSaveBackup Saves a backup of the playback report data to the backup path

No authentication required

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetUserUsageStatsSaveBackupRequest
*/
func (a *UserActivityAPIAPIService) GetUserUsageStatsSaveBackup(ctx context.Context) ApiGetUserUsageStatsSaveBackupRequest {
	return ApiGetUserUsageStatsSaveBackupRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *UserActivityAPIAPIService) GetUserUsageStatsSaveBackupExecute(r ApiGetUserUsageStatsSaveBackupRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserActivityAPIAPIService.GetUserUsageStatsSaveBackup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user_usage_stats/save_backup"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUserUsageStatsSessionListRequest struct {
	ctx context.Context
	ApiService UserActivityAPIAPI
}

func (r ApiGetUserUsageStatsSessionListRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetUserUsageStatsSessionListExecute(r)
}

/*
GetUserUsageStatsSessionList Gets Session Info

No authentication required

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetUserUsageStatsSessionListRequest
*/
func (a *UserActivityAPIAPIService) GetUserUsageStatsSessionList(ctx context.Context) ApiGetUserUsageStatsSessionListRequest {
	return ApiGetUserUsageStatsSessionListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *UserActivityAPIAPIService) GetUserUsageStatsSessionListExecute(r ApiGetUserUsageStatsSessionListRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserActivityAPIAPIService.GetUserUsageStatsSessionList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user_usage_stats/session_list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUserUsageStatsTvshowsreportRequest struct {
	ctx context.Context
	ApiService UserActivityAPIAPI
	days *int32
	endDate *string
}

// Number of Days
func (r ApiGetUserUsageStatsTvshowsreportRequest) Days(days int32) ApiGetUserUsageStatsTvshowsreportRequest {
	r.days = &days
	return r
}

// End date of the report in yyyy-MM-dd format
func (r ApiGetUserUsageStatsTvshowsreportRequest) EndDate(endDate string) ApiGetUserUsageStatsTvshowsreportRequest {
	r.endDate = &endDate
	return r
}

func (r ApiGetUserUsageStatsTvshowsreportRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetUserUsageStatsTvshowsreportExecute(r)
}

/*
GetUserUsageStatsTvshowsreport Gets TV Shows counts

No authentication required

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetUserUsageStatsTvshowsreportRequest
*/
func (a *UserActivityAPIAPIService) GetUserUsageStatsTvshowsreport(ctx context.Context) ApiGetUserUsageStatsTvshowsreportRequest {
	return ApiGetUserUsageStatsTvshowsreportRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *UserActivityAPIAPIService) GetUserUsageStatsTvshowsreportExecute(r ApiGetUserUsageStatsTvshowsreportRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserActivityAPIAPIService.GetUserUsageStatsTvshowsreport")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user_usage_stats/TvShowsReport"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.days != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "days", r.days, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUserUsageStatsTypeFilterListRequest struct {
	ctx context.Context
	ApiService UserActivityAPIAPI
}

func (r ApiGetUserUsageStatsTypeFilterListRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetUserUsageStatsTypeFilterListExecute(r)
}

/*
GetUserUsageStatsTypeFilterList Gets types filter list items

No authentication required

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetUserUsageStatsTypeFilterListRequest
*/
func (a *UserActivityAPIAPIService) GetUserUsageStatsTypeFilterList(ctx context.Context) ApiGetUserUsageStatsTypeFilterListRequest {
	return ApiGetUserUsageStatsTypeFilterListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *UserActivityAPIAPIService) GetUserUsageStatsTypeFilterListExecute(r ApiGetUserUsageStatsTypeFilterListRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserActivityAPIAPIService.GetUserUsageStatsTypeFilterList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user_usage_stats/type_filter_list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUserUsageStatsUserActivityRequest struct {
	ctx context.Context
	ApiService UserActivityAPIAPI
	days *int32
	endDate *string
}

// Number of Days
func (r ApiGetUserUsageStatsUserActivityRequest) Days(days int32) ApiGetUserUsageStatsUserActivityRequest {
	r.days = &days
	return r
}

// End date of the report in yyyy-MM-dd format
func (r ApiGetUserUsageStatsUserActivityRequest) EndDate(endDate string) ApiGetUserUsageStatsUserActivityRequest {
	r.endDate = &endDate
	return r
}

func (r ApiGetUserUsageStatsUserActivityRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetUserUsageStatsUserActivityExecute(r)
}

/*
GetUserUsageStatsUserActivity Gets a report of the available activity per hour

No authentication required

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetUserUsageStatsUserActivityRequest
*/
func (a *UserActivityAPIAPIService) GetUserUsageStatsUserActivity(ctx context.Context) ApiGetUserUsageStatsUserActivityRequest {
	return ApiGetUserUsageStatsUserActivityRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *UserActivityAPIAPIService) GetUserUsageStatsUserActivityExecute(r ApiGetUserUsageStatsUserActivityRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserActivityAPIAPIService.GetUserUsageStatsUserActivity")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user_usage_stats/user_activity"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.days != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "days", r.days, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUserUsageStatsUserListRequest struct {
	ctx context.Context
	ApiService UserActivityAPIAPI
}

func (r ApiGetUserUsageStatsUserListRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetUserUsageStatsUserListExecute(r)
}

/*
GetUserUsageStatsUserList Get users

No authentication required

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetUserUsageStatsUserListRequest
*/
func (a *UserActivityAPIAPIService) GetUserUsageStatsUserList(ctx context.Context) ApiGetUserUsageStatsUserListRequest {
	return ApiGetUserUsageStatsUserListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *UserActivityAPIAPIService) GetUserUsageStatsUserListExecute(r ApiGetUserUsageStatsUserListRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserActivityAPIAPIService.GetUserUsageStatsUserList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user_usage_stats/user_list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUserUsageStatsUserManageByActionByIdRequest struct {
	ctx context.Context
	ApiService UserActivityAPIAPI
	action string
	id string
}

func (r ApiGetUserUsageStatsUserManageByActionByIdRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetUserUsageStatsUserManageByActionByIdExecute(r)
}

/*
GetUserUsageStatsUserManageByActionById Get users

No authentication required

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param action action to perform
 @param id user Id to perform the action on
 @return ApiGetUserUsageStatsUserManageByActionByIdRequest
*/
func (a *UserActivityAPIAPIService) GetUserUsageStatsUserManageByActionById(ctx context.Context, action string, id string) ApiGetUserUsageStatsUserManageByActionByIdRequest {
	return ApiGetUserUsageStatsUserManageByActionByIdRequest{
		ApiService: a,
		ctx: ctx,
		action: action,
		id: id,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *UserActivityAPIAPIService) GetUserUsageStatsUserManageByActionByIdExecute(r ApiGetUserUsageStatsUserManageByActionByIdRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserActivityAPIAPIService.GetUserUsageStatsUserManageByActionById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user_usage_stats/user_manage/{Action}/{Id}"
	localVarPath = strings.Replace(localVarPath, "{"+"Action"+"}", url.PathEscape(parameterValueToString(r.action, "action")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUserUsageStatsUserplaylistRequest struct {
	ctx context.Context
	ApiService UserActivityAPIAPI
	userId *string
	days *int32
	endDate *string
	filter *string
}

// User Id
func (r ApiGetUserUsageStatsUserplaylistRequest) UserId(userId string) ApiGetUserUsageStatsUserplaylistRequest {
	r.userId = &userId
	return r
}

// Number of Days
func (r ApiGetUserUsageStatsUserplaylistRequest) Days(days int32) ApiGetUserUsageStatsUserplaylistRequest {
	r.days = &days
	return r
}

// End date of the report in yyyy-MM-dd format
func (r ApiGetUserUsageStatsUserplaylistRequest) EndDate(endDate string) ApiGetUserUsageStatsUserplaylistRequest {
	r.endDate = &endDate
	return r
}

// Comma separated list of media types to filter (movies,series)
func (r ApiGetUserUsageStatsUserplaylistRequest) Filter(filter string) ApiGetUserUsageStatsUserplaylistRequest {
	r.filter = &filter
	return r
}

func (r ApiGetUserUsageStatsUserplaylistRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetUserUsageStatsUserplaylistExecute(r)
}

/*
GetUserUsageStatsUserplaylist Gets a report of all played items for a user in a date period

No authentication required

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetUserUsageStatsUserplaylistRequest
*/
func (a *UserActivityAPIAPIService) GetUserUsageStatsUserplaylist(ctx context.Context) ApiGetUserUsageStatsUserplaylistRequest {
	return ApiGetUserUsageStatsUserplaylistRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *UserActivityAPIAPIService) GetUserUsageStatsUserplaylistExecute(r ApiGetUserUsageStatsUserplaylistRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserActivityAPIAPIService.GetUserUsageStatsUserplaylist")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user_usage_stats/UserPlaylist"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.userId == nil {
		return localVarReturnValue, nil, reportError("userId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "user_id", r.userId, "form", "")
	if r.days != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "days", r.days, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostUserUsageStatsImportBackupRequest struct {
	ctx context.Context
	ApiService UserActivityAPIAPI
	body *os.File
}

// Binary stream
func (r ApiPostUserUsageStatsImportBackupRequest) Body(body *os.File) ApiPostUserUsageStatsImportBackupRequest {
	r.body = body
	return r
}

func (r ApiPostUserUsageStatsImportBackupRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostUserUsageStatsImportBackupExecute(r)
}

/*
PostUserUsageStatsImportBackup Post a backup for importing

No authentication required

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostUserUsageStatsImportBackupRequest
*/
func (a *UserActivityAPIAPIService) PostUserUsageStatsImportBackup(ctx context.Context) ApiPostUserUsageStatsImportBackupRequest {
	return ApiPostUserUsageStatsImportBackupRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *UserActivityAPIAPIService) PostUserUsageStatsImportBackupExecute(r ApiPostUserUsageStatsImportBackupRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserActivityAPIAPIService.PostUserUsageStatsImportBackup")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user_usage_stats/import_backup"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/octet-stream"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostUserUsageStatsSubmitCustomQueryRequest struct {
	ctx context.Context
	ApiService UserActivityAPIAPI
	playbackReportingApiCustomQuery *PlaybackReportingApiCustomQuery
}

// CustomQuery
func (r ApiPostUserUsageStatsSubmitCustomQueryRequest) PlaybackReportingApiCustomQuery(playbackReportingApiCustomQuery PlaybackReportingApiCustomQuery) ApiPostUserUsageStatsSubmitCustomQueryRequest {
	r.playbackReportingApiCustomQuery = &playbackReportingApiCustomQuery
	return r
}

func (r ApiPostUserUsageStatsSubmitCustomQueryRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.PostUserUsageStatsSubmitCustomQueryExecute(r)
}

/*
PostUserUsageStatsSubmitCustomQuery Submit an SQL query

No authentication required

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostUserUsageStatsSubmitCustomQueryRequest
*/
func (a *UserActivityAPIAPIService) PostUserUsageStatsSubmitCustomQuery(ctx context.Context) ApiPostUserUsageStatsSubmitCustomQueryRequest {
	return ApiPostUserUsageStatsSubmitCustomQueryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *UserActivityAPIAPIService) PostUserUsageStatsSubmitCustomQueryExecute(r ApiPostUserUsageStatsSubmitCustomQueryRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserActivityAPIAPIService.PostUserUsageStatsSubmitCustomQuery")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user_usage_stats/submit_custom_query"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.playbackReportingApiCustomQuery == nil {
		return localVarReturnValue, nil, reportError("playbackReportingApiCustomQuery is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.playbackReportingApiCustomQuery
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
