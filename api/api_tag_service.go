/*
Emby Server API

Explore the Emby Server API

API version: 4.1.1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package api

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


type TagServiceAPI interface {

	/*
	GetArtistsPrefixes Gets items based on a query.

	No authentication required

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetArtistsPrefixesRequest
	*/
	GetArtistsPrefixes(ctx context.Context) ApiGetArtistsPrefixesRequest

	// GetArtistsPrefixesExecute executes the request
	//  @return []NameValuePair
	GetArtistsPrefixesExecute(r ApiGetArtistsPrefixesRequest) ([]NameValuePair, *http.Response, error)

	/*
	GetAudiocodecs Gets items based on a query.

	No authentication required

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetAudiocodecsRequest
	*/
	GetAudiocodecs(ctx context.Context) ApiGetAudiocodecsRequest

	// GetAudiocodecsExecute executes the request
	//  @return QueryResultUserLibraryTagItem
	GetAudiocodecsExecute(r ApiGetAudiocodecsRequest) (*QueryResultUserLibraryTagItem, *http.Response, error)

	/*
	GetContainers Gets items based on a query.

	No authentication required

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetContainersRequest
	*/
	GetContainers(ctx context.Context) ApiGetContainersRequest

	// GetContainersExecute executes the request
	//  @return QueryResultUserLibraryTagItem
	GetContainersExecute(r ApiGetContainersRequest) (*QueryResultUserLibraryTagItem, *http.Response, error)

	/*
	GetItemsPrefixes Gets items based on a query.

	No authentication required

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetItemsPrefixesRequest
	*/
	GetItemsPrefixes(ctx context.Context) ApiGetItemsPrefixesRequest

	// GetItemsPrefixesExecute executes the request
	//  @return []NameValuePair
	GetItemsPrefixesExecute(r ApiGetItemsPrefixesRequest) ([]NameValuePair, *http.Response, error)

	/*
	GetSubtitlecodecs Gets items based on a query.

	No authentication required

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetSubtitlecodecsRequest
	*/
	GetSubtitlecodecs(ctx context.Context) ApiGetSubtitlecodecsRequest

	// GetSubtitlecodecsExecute executes the request
	//  @return QueryResultUserLibraryTagItem
	GetSubtitlecodecsExecute(r ApiGetSubtitlecodecsRequest) (*QueryResultUserLibraryTagItem, *http.Response, error)

	/*
	GetTags Gets items based on a query.

	No authentication required

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetTagsRequest
	*/
	GetTags(ctx context.Context) ApiGetTagsRequest

	// GetTagsExecute executes the request
	//  @return QueryResultUserLibraryTagItem
	GetTagsExecute(r ApiGetTagsRequest) (*QueryResultUserLibraryTagItem, *http.Response, error)

	/*
	GetVideocodecs Gets items based on a query.

	No authentication required

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetVideocodecsRequest
	*/
	GetVideocodecs(ctx context.Context) ApiGetVideocodecsRequest

	// GetVideocodecsExecute executes the request
	//  @return QueryResultUserLibraryTagItem
	GetVideocodecsExecute(r ApiGetVideocodecsRequest) (*QueryResultUserLibraryTagItem, *http.Response, error)

	/*
	GetYears Gets items based on a query.

	No authentication required

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetYearsRequest
	*/
	GetYears(ctx context.Context) ApiGetYearsRequest

	// GetYearsExecute executes the request
	//  @return QueryResultUserLibraryTagItem
	GetYearsExecute(r ApiGetYearsRequest) (*QueryResultUserLibraryTagItem, *http.Response, error)
}

// TagServiceAPIService TagServiceAPI service
type TagServiceAPIService service

type ApiGetArtistsPrefixesRequest struct {
	ctx context.Context
	ApiService TagServiceAPI
	artistType *string
	maxOfficialRating *string
	hasThemeSong *bool
	hasThemeVideo *bool
	hasSubtitles *bool
	hasSpecialFeature *bool
	hasTrailer *bool
	adjacentTo *string
	minIndexNumber *int32
	minPlayers *int32
	maxPlayers *int32
	parentIndexNumber *int32
	hasParentalRating *bool
	isHD *bool
	locationTypes *string
	excludeLocationTypes *string
	isMissing *bool
	isUnaired *bool
	minCommunityRating *float64
	minCriticRating *float64
	airedDuringSeason *int32
	minPremiereDate *string
	minDateLastSaved *string
	minDateLastSavedForUser *string
	maxPremiereDate *string
	hasOverview *bool
	hasImdbId *bool
	hasTmdbId *bool
	hasTvdbId *bool
	excludeItemIds *string
	startIndex *int32
	limit *int32
	recursive *bool
	sortOrder *string
	parentId *string
	fields *string
	excludeItemTypes *string
	includeItemTypes *string
	anyProviderIdEquals *string
	filters *string
	isFavorite *bool
	isMovie *bool
	isSeries *bool
	isNews *bool
	isKids *bool
	isSports *bool
	mediaTypes *string
	imageTypes *string
	sortBy *string
	isPlayed *bool
	genres *string
	officialRatings *string
	tags *string
	years *string
	enableImages *bool
	enableUserData *bool
	imageTypeLimit *int32
	enableImageTypes *string
	person *string
	personIds *string
	personTypes *string
	studios *string
	studioIds *string
	artists *string
	artistIds *string
	albums *string
	ids *string
	videoTypes *string
	containers *string
	audioCodecs *string
	videoCodecs *string
	subtitleCodecs *string
	path *string
	userId *string
	minOfficialRating *string
	isLocked *bool
	isPlaceHolder *bool
	hasOfficialRating *bool
	groupItemsIntoCollections *bool
	is3D *bool
	seriesStatus *string
	nameStartsWithOrGreater *string
	nameStartsWith *string
	nameLessThan *string
}

// Artist or AlbumArtist
func (r ApiGetArtistsPrefixesRequest) ArtistType(artistType string) ApiGetArtistsPrefixesRequest {
	r.artistType = &artistType
	return r
}

// Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
func (r ApiGetArtistsPrefixesRequest) MaxOfficialRating(maxOfficialRating string) ApiGetArtistsPrefixesRequest {
	r.maxOfficialRating = &maxOfficialRating
	return r
}

// Optional filter by items with theme songs.
func (r ApiGetArtistsPrefixesRequest) HasThemeSong(hasThemeSong bool) ApiGetArtistsPrefixesRequest {
	r.hasThemeSong = &hasThemeSong
	return r
}

// Optional filter by items with theme videos.
func (r ApiGetArtistsPrefixesRequest) HasThemeVideo(hasThemeVideo bool) ApiGetArtistsPrefixesRequest {
	r.hasThemeVideo = &hasThemeVideo
	return r
}

// Optional filter by items with subtitles.
func (r ApiGetArtistsPrefixesRequest) HasSubtitles(hasSubtitles bool) ApiGetArtistsPrefixesRequest {
	r.hasSubtitles = &hasSubtitles
	return r
}

// Optional filter by items with special features.
func (r ApiGetArtistsPrefixesRequest) HasSpecialFeature(hasSpecialFeature bool) ApiGetArtistsPrefixesRequest {
	r.hasSpecialFeature = &hasSpecialFeature
	return r
}

// Optional filter by items with trailers.
func (r ApiGetArtistsPrefixesRequest) HasTrailer(hasTrailer bool) ApiGetArtistsPrefixesRequest {
	r.hasTrailer = &hasTrailer
	return r
}

// Optional. Return items that are siblings of a supplied item.
func (r ApiGetArtistsPrefixesRequest) AdjacentTo(adjacentTo string) ApiGetArtistsPrefixesRequest {
	r.adjacentTo = &adjacentTo
	return r
}

// Optional filter by minimum index number.
func (r ApiGetArtistsPrefixesRequest) MinIndexNumber(minIndexNumber int32) ApiGetArtistsPrefixesRequest {
	r.minIndexNumber = &minIndexNumber
	return r
}

// Optional filter by minimum number of game players.
func (r ApiGetArtistsPrefixesRequest) MinPlayers(minPlayers int32) ApiGetArtistsPrefixesRequest {
	r.minPlayers = &minPlayers
	return r
}

// Optional filter by maximum number of game players.
func (r ApiGetArtistsPrefixesRequest) MaxPlayers(maxPlayers int32) ApiGetArtistsPrefixesRequest {
	r.maxPlayers = &maxPlayers
	return r
}

// Optional filter by parent index number.
func (r ApiGetArtistsPrefixesRequest) ParentIndexNumber(parentIndexNumber int32) ApiGetArtistsPrefixesRequest {
	r.parentIndexNumber = &parentIndexNumber
	return r
}

// Optional filter by items that have or do not have a parental rating
func (r ApiGetArtistsPrefixesRequest) HasParentalRating(hasParentalRating bool) ApiGetArtistsPrefixesRequest {
	r.hasParentalRating = &hasParentalRating
	return r
}

// Optional filter by items that are HD or not.
func (r ApiGetArtistsPrefixesRequest) IsHD(isHD bool) ApiGetArtistsPrefixesRequest {
	r.isHD = &isHD
	return r
}

// Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
func (r ApiGetArtistsPrefixesRequest) LocationTypes(locationTypes string) ApiGetArtistsPrefixesRequest {
	r.locationTypes = &locationTypes
	return r
}

// Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
func (r ApiGetArtistsPrefixesRequest) ExcludeLocationTypes(excludeLocationTypes string) ApiGetArtistsPrefixesRequest {
	r.excludeLocationTypes = &excludeLocationTypes
	return r
}

// Optional filter by items that are missing episodes or not.
func (r ApiGetArtistsPrefixesRequest) IsMissing(isMissing bool) ApiGetArtistsPrefixesRequest {
	r.isMissing = &isMissing
	return r
}

// Optional filter by items that are unaired episodes or not.
func (r ApiGetArtistsPrefixesRequest) IsUnaired(isUnaired bool) ApiGetArtistsPrefixesRequest {
	r.isUnaired = &isUnaired
	return r
}

// Optional filter by minimum community rating.
func (r ApiGetArtistsPrefixesRequest) MinCommunityRating(minCommunityRating float64) ApiGetArtistsPrefixesRequest {
	r.minCommunityRating = &minCommunityRating
	return r
}

// Optional filter by minimum critic rating.
func (r ApiGetArtistsPrefixesRequest) MinCriticRating(minCriticRating float64) ApiGetArtistsPrefixesRequest {
	r.minCriticRating = &minCriticRating
	return r
}

// Gets all episodes that aired during a season, including specials.
func (r ApiGetArtistsPrefixesRequest) AiredDuringSeason(airedDuringSeason int32) ApiGetArtistsPrefixesRequest {
	r.airedDuringSeason = &airedDuringSeason
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r ApiGetArtistsPrefixesRequest) MinPremiereDate(minPremiereDate string) ApiGetArtistsPrefixesRequest {
	r.minPremiereDate = &minPremiereDate
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r ApiGetArtistsPrefixesRequest) MinDateLastSaved(minDateLastSaved string) ApiGetArtistsPrefixesRequest {
	r.minDateLastSaved = &minDateLastSaved
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r ApiGetArtistsPrefixesRequest) MinDateLastSavedForUser(minDateLastSavedForUser string) ApiGetArtistsPrefixesRequest {
	r.minDateLastSavedForUser = &minDateLastSavedForUser
	return r
}

// Optional. The maximum premiere date. Format &#x3D; ISO
func (r ApiGetArtistsPrefixesRequest) MaxPremiereDate(maxPremiereDate string) ApiGetArtistsPrefixesRequest {
	r.maxPremiereDate = &maxPremiereDate
	return r
}

// Optional filter by items that have an overview or not.
func (r ApiGetArtistsPrefixesRequest) HasOverview(hasOverview bool) ApiGetArtistsPrefixesRequest {
	r.hasOverview = &hasOverview
	return r
}

// Optional filter by items that have an imdb id or not.
func (r ApiGetArtistsPrefixesRequest) HasImdbId(hasImdbId bool) ApiGetArtistsPrefixesRequest {
	r.hasImdbId = &hasImdbId
	return r
}

// Optional filter by items that have a tmdb id or not.
func (r ApiGetArtistsPrefixesRequest) HasTmdbId(hasTmdbId bool) ApiGetArtistsPrefixesRequest {
	r.hasTmdbId = &hasTmdbId
	return r
}

// Optional filter by items that have a tvdb id or not.
func (r ApiGetArtistsPrefixesRequest) HasTvdbId(hasTvdbId bool) ApiGetArtistsPrefixesRequest {
	r.hasTvdbId = &hasTvdbId
	return r
}

// Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
func (r ApiGetArtistsPrefixesRequest) ExcludeItemIds(excludeItemIds string) ApiGetArtistsPrefixesRequest {
	r.excludeItemIds = &excludeItemIds
	return r
}

// Optional. The record index to start at. All items with a lower index will be dropped from the results.
func (r ApiGetArtistsPrefixesRequest) StartIndex(startIndex int32) ApiGetArtistsPrefixesRequest {
	r.startIndex = &startIndex
	return r
}

// Optional. The maximum number of records to return
func (r ApiGetArtistsPrefixesRequest) Limit(limit int32) ApiGetArtistsPrefixesRequest {
	r.limit = &limit
	return r
}

// When searching within folders, this determines whether or not the search will be recursive. true/false
func (r ApiGetArtistsPrefixesRequest) Recursive(recursive bool) ApiGetArtistsPrefixesRequest {
	r.recursive = &recursive
	return r
}

// Sort Order - Ascending,Descending
func (r ApiGetArtistsPrefixesRequest) SortOrder(sortOrder string) ApiGetArtistsPrefixesRequest {
	r.sortOrder = &sortOrder
	return r
}

// Specify this to localize the search to a specific item or folder. Omit to use the root
func (r ApiGetArtistsPrefixesRequest) ParentId(parentId string) ApiGetArtistsPrefixesRequest {
	r.parentId = &parentId
	return r
}

// Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
func (r ApiGetArtistsPrefixesRequest) Fields(fields string) ApiGetArtistsPrefixesRequest {
	r.fields = &fields
	return r
}

// Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
func (r ApiGetArtistsPrefixesRequest) ExcludeItemTypes(excludeItemTypes string) ApiGetArtistsPrefixesRequest {
	r.excludeItemTypes = &excludeItemTypes
	return r
}

// Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
func (r ApiGetArtistsPrefixesRequest) IncludeItemTypes(includeItemTypes string) ApiGetArtistsPrefixesRequest {
	r.includeItemTypes = &includeItemTypes
	return r
}

// Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form &#39;prov.id&#39;, e.g. &#39;imdb.tt123456&#39;. This allows multiple, comma delimeted value pairs.
func (r ApiGetArtistsPrefixesRequest) AnyProviderIdEquals(anyProviderIdEquals string) ApiGetArtistsPrefixesRequest {
	r.anyProviderIdEquals = &anyProviderIdEquals
	return r
}

// Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
func (r ApiGetArtistsPrefixesRequest) Filters(filters string) ApiGetArtistsPrefixesRequest {
	r.filters = &filters
	return r
}

// Optional filter by items that are marked as favorite, or not.
func (r ApiGetArtistsPrefixesRequest) IsFavorite(isFavorite bool) ApiGetArtistsPrefixesRequest {
	r.isFavorite = &isFavorite
	return r
}

// Optional filter for movies.
func (r ApiGetArtistsPrefixesRequest) IsMovie(isMovie bool) ApiGetArtistsPrefixesRequest {
	r.isMovie = &isMovie
	return r
}

// Optional filter for movies.
func (r ApiGetArtistsPrefixesRequest) IsSeries(isSeries bool) ApiGetArtistsPrefixesRequest {
	r.isSeries = &isSeries
	return r
}

// Optional filter for news.
func (r ApiGetArtistsPrefixesRequest) IsNews(isNews bool) ApiGetArtistsPrefixesRequest {
	r.isNews = &isNews
	return r
}

// Optional filter for kids.
func (r ApiGetArtistsPrefixesRequest) IsKids(isKids bool) ApiGetArtistsPrefixesRequest {
	r.isKids = &isKids
	return r
}

// Optional filter for sports.
func (r ApiGetArtistsPrefixesRequest) IsSports(isSports bool) ApiGetArtistsPrefixesRequest {
	r.isSports = &isSports
	return r
}

// Optional filter by MediaType. Allows multiple, comma delimited.
func (r ApiGetArtistsPrefixesRequest) MediaTypes(mediaTypes string) ApiGetArtistsPrefixesRequest {
	r.mediaTypes = &mediaTypes
	return r
}

// Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
func (r ApiGetArtistsPrefixesRequest) ImageTypes(imageTypes string) ApiGetArtistsPrefixesRequest {
	r.imageTypes = &imageTypes
	return r
}

// Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
func (r ApiGetArtistsPrefixesRequest) SortBy(sortBy string) ApiGetArtistsPrefixesRequest {
	r.sortBy = &sortBy
	return r
}

// Optional filter by items that are played, or not.
func (r ApiGetArtistsPrefixesRequest) IsPlayed(isPlayed bool) ApiGetArtistsPrefixesRequest {
	r.isPlayed = &isPlayed
	return r
}

// Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
func (r ApiGetArtistsPrefixesRequest) Genres(genres string) ApiGetArtistsPrefixesRequest {
	r.genres = &genres
	return r
}

// Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
func (r ApiGetArtistsPrefixesRequest) OfficialRatings(officialRatings string) ApiGetArtistsPrefixesRequest {
	r.officialRatings = &officialRatings
	return r
}

// Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
func (r ApiGetArtistsPrefixesRequest) Tags(tags string) ApiGetArtistsPrefixesRequest {
	r.tags = &tags
	return r
}

// Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
func (r ApiGetArtistsPrefixesRequest) Years(years string) ApiGetArtistsPrefixesRequest {
	r.years = &years
	return r
}

// Optional, include image information in output
func (r ApiGetArtistsPrefixesRequest) EnableImages(enableImages bool) ApiGetArtistsPrefixesRequest {
	r.enableImages = &enableImages
	return r
}

// Optional, include user data
func (r ApiGetArtistsPrefixesRequest) EnableUserData(enableUserData bool) ApiGetArtistsPrefixesRequest {
	r.enableUserData = &enableUserData
	return r
}

// Optional, the max number of images to return, per image type
func (r ApiGetArtistsPrefixesRequest) ImageTypeLimit(imageTypeLimit int32) ApiGetArtistsPrefixesRequest {
	r.imageTypeLimit = &imageTypeLimit
	return r
}

// Optional. The image types to include in the output.
func (r ApiGetArtistsPrefixesRequest) EnableImageTypes(enableImageTypes string) ApiGetArtistsPrefixesRequest {
	r.enableImageTypes = &enableImageTypes
	return r
}

// Optional. If specified, results will be filtered to include only those containing the specified person.
func (r ApiGetArtistsPrefixesRequest) Person(person string) ApiGetArtistsPrefixesRequest {
	r.person = &person
	return r
}

// Optional. If specified, results will be filtered to include only those containing the specified person.
func (r ApiGetArtistsPrefixesRequest) PersonIds(personIds string) ApiGetArtistsPrefixesRequest {
	r.personIds = &personIds
	return r
}

// Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
func (r ApiGetArtistsPrefixesRequest) PersonTypes(personTypes string) ApiGetArtistsPrefixesRequest {
	r.personTypes = &personTypes
	return r
}

// Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
func (r ApiGetArtistsPrefixesRequest) Studios(studios string) ApiGetArtistsPrefixesRequest {
	r.studios = &studios
	return r
}

// Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
func (r ApiGetArtistsPrefixesRequest) StudioIds(studioIds string) ApiGetArtistsPrefixesRequest {
	r.studioIds = &studioIds
	return r
}

// Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
func (r ApiGetArtistsPrefixesRequest) Artists(artists string) ApiGetArtistsPrefixesRequest {
	r.artists = &artists
	return r
}

// Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
func (r ApiGetArtistsPrefixesRequest) ArtistIds(artistIds string) ApiGetArtistsPrefixesRequest {
	r.artistIds = &artistIds
	return r
}

// Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
func (r ApiGetArtistsPrefixesRequest) Albums(albums string) ApiGetArtistsPrefixesRequest {
	r.albums = &albums
	return r
}

// Optional. If specific items are needed, specify a list of item id&#39;s to retrieve. This allows multiple, comma delimited.
func (r ApiGetArtistsPrefixesRequest) Ids(ids string) ApiGetArtistsPrefixesRequest {
	r.ids = &ids
	return r
}

// Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
func (r ApiGetArtistsPrefixesRequest) VideoTypes(videoTypes string) ApiGetArtistsPrefixesRequest {
	r.videoTypes = &videoTypes
	return r
}

// Optional filter by Container. Allows multiple, comma delimeted.
func (r ApiGetArtistsPrefixesRequest) Containers(containers string) ApiGetArtistsPrefixesRequest {
	r.containers = &containers
	return r
}

// Optional filter by AudioCodec. Allows multiple, comma delimeted.
func (r ApiGetArtistsPrefixesRequest) AudioCodecs(audioCodecs string) ApiGetArtistsPrefixesRequest {
	r.audioCodecs = &audioCodecs
	return r
}

// Optional filter by VideoCodec. Allows multiple, comma delimeted.
func (r ApiGetArtistsPrefixesRequest) VideoCodecs(videoCodecs string) ApiGetArtistsPrefixesRequest {
	r.videoCodecs = &videoCodecs
	return r
}

// Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
func (r ApiGetArtistsPrefixesRequest) SubtitleCodecs(subtitleCodecs string) ApiGetArtistsPrefixesRequest {
	r.subtitleCodecs = &subtitleCodecs
	return r
}

// Optional filter by Path.
func (r ApiGetArtistsPrefixesRequest) Path(path string) ApiGetArtistsPrefixesRequest {
	r.path = &path
	return r
}

// User Id
func (r ApiGetArtistsPrefixesRequest) UserId(userId string) ApiGetArtistsPrefixesRequest {
	r.userId = &userId
	return r
}

// Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
func (r ApiGetArtistsPrefixesRequest) MinOfficialRating(minOfficialRating string) ApiGetArtistsPrefixesRequest {
	r.minOfficialRating = &minOfficialRating
	return r
}

// Optional filter by items that are locked.
func (r ApiGetArtistsPrefixesRequest) IsLocked(isLocked bool) ApiGetArtistsPrefixesRequest {
	r.isLocked = &isLocked
	return r
}

// Optional filter by items that are placeholders
func (r ApiGetArtistsPrefixesRequest) IsPlaceHolder(isPlaceHolder bool) ApiGetArtistsPrefixesRequest {
	r.isPlaceHolder = &isPlaceHolder
	return r
}

// Optional filter by items that have official ratings
func (r ApiGetArtistsPrefixesRequest) HasOfficialRating(hasOfficialRating bool) ApiGetArtistsPrefixesRequest {
	r.hasOfficialRating = &hasOfficialRating
	return r
}

// Whether or not to hide items behind their boxsets.
func (r ApiGetArtistsPrefixesRequest) GroupItemsIntoCollections(groupItemsIntoCollections bool) ApiGetArtistsPrefixesRequest {
	r.groupItemsIntoCollections = &groupItemsIntoCollections
	return r
}

// Optional filter by items that are 3D, or not.
func (r ApiGetArtistsPrefixesRequest) Is3D(is3D bool) ApiGetArtistsPrefixesRequest {
	r.is3D = &is3D
	return r
}

// Optional filter by Series Status. Allows multiple, comma delimeted.
func (r ApiGetArtistsPrefixesRequest) SeriesStatus(seriesStatus string) ApiGetArtistsPrefixesRequest {
	r.seriesStatus = &seriesStatus
	return r
}

// Optional filter by items whose name is sorted equally or greater than a given input string.
func (r ApiGetArtistsPrefixesRequest) NameStartsWithOrGreater(nameStartsWithOrGreater string) ApiGetArtistsPrefixesRequest {
	r.nameStartsWithOrGreater = &nameStartsWithOrGreater
	return r
}

// Optional filter by items whose name is sorted equally than a given input string.
func (r ApiGetArtistsPrefixesRequest) NameStartsWith(nameStartsWith string) ApiGetArtistsPrefixesRequest {
	r.nameStartsWith = &nameStartsWith
	return r
}

// Optional filter by items whose name is equally or lesser than a given input string.
func (r ApiGetArtistsPrefixesRequest) NameLessThan(nameLessThan string) ApiGetArtistsPrefixesRequest {
	r.nameLessThan = &nameLessThan
	return r
}

func (r ApiGetArtistsPrefixesRequest) Execute() ([]NameValuePair, *http.Response, error) {
	return r.ApiService.GetArtistsPrefixesExecute(r)
}

/*
GetArtistsPrefixes Gets items based on a query.

No authentication required

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetArtistsPrefixesRequest
*/
func (a *TagServiceAPIService) GetArtistsPrefixes(ctx context.Context) ApiGetArtistsPrefixesRequest {
	return ApiGetArtistsPrefixesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []NameValuePair
func (a *TagServiceAPIService) GetArtistsPrefixesExecute(r ApiGetArtistsPrefixesRequest) ([]NameValuePair, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []NameValuePair
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TagServiceAPIService.GetArtistsPrefixes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Artists/Prefixes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.artistType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ArtistType", r.artistType, "form", "")
	}
	if r.maxOfficialRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxOfficialRating", r.maxOfficialRating, "form", "")
	}
	if r.hasThemeSong != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasThemeSong", r.hasThemeSong, "form", "")
	}
	if r.hasThemeVideo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasThemeVideo", r.hasThemeVideo, "form", "")
	}
	if r.hasSubtitles != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasSubtitles", r.hasSubtitles, "form", "")
	}
	if r.hasSpecialFeature != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasSpecialFeature", r.hasSpecialFeature, "form", "")
	}
	if r.hasTrailer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasTrailer", r.hasTrailer, "form", "")
	}
	if r.adjacentTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AdjacentTo", r.adjacentTo, "form", "")
	}
	if r.minIndexNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinIndexNumber", r.minIndexNumber, "form", "")
	}
	if r.minPlayers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinPlayers", r.minPlayers, "form", "")
	}
	if r.maxPlayers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxPlayers", r.maxPlayers, "form", "")
	}
	if r.parentIndexNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ParentIndexNumber", r.parentIndexNumber, "form", "")
	}
	if r.hasParentalRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasParentalRating", r.hasParentalRating, "form", "")
	}
	if r.isHD != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsHD", r.isHD, "form", "")
	}
	if r.locationTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "LocationTypes", r.locationTypes, "form", "")
	}
	if r.excludeLocationTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ExcludeLocationTypes", r.excludeLocationTypes, "form", "")
	}
	if r.isMissing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsMissing", r.isMissing, "form", "")
	}
	if r.isUnaired != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsUnaired", r.isUnaired, "form", "")
	}
	if r.minCommunityRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinCommunityRating", r.minCommunityRating, "form", "")
	}
	if r.minCriticRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinCriticRating", r.minCriticRating, "form", "")
	}
	if r.airedDuringSeason != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AiredDuringSeason", r.airedDuringSeason, "form", "")
	}
	if r.minPremiereDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinPremiereDate", r.minPremiereDate, "form", "")
	}
	if r.minDateLastSaved != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinDateLastSaved", r.minDateLastSaved, "form", "")
	}
	if r.minDateLastSavedForUser != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinDateLastSavedForUser", r.minDateLastSavedForUser, "form", "")
	}
	if r.maxPremiereDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxPremiereDate", r.maxPremiereDate, "form", "")
	}
	if r.hasOverview != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasOverview", r.hasOverview, "form", "")
	}
	if r.hasImdbId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasImdbId", r.hasImdbId, "form", "")
	}
	if r.hasTmdbId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasTmdbId", r.hasTmdbId, "form", "")
	}
	if r.hasTvdbId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasTvdbId", r.hasTvdbId, "form", "")
	}
	if r.excludeItemIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ExcludeItemIds", r.excludeItemIds, "form", "")
	}
	if r.startIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "StartIndex", r.startIndex, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Limit", r.limit, "form", "")
	}
	if r.recursive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Recursive", r.recursive, "form", "")
	}
	if r.sortOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SortOrder", r.sortOrder, "form", "")
	}
	if r.parentId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ParentId", r.parentId, "form", "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Fields", r.fields, "form", "")
	}
	if r.excludeItemTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ExcludeItemTypes", r.excludeItemTypes, "form", "")
	}
	if r.includeItemTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IncludeItemTypes", r.includeItemTypes, "form", "")
	}
	if r.anyProviderIdEquals != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AnyProviderIdEquals", r.anyProviderIdEquals, "form", "")
	}
	if r.filters != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Filters", r.filters, "form", "")
	}
	if r.isFavorite != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsFavorite", r.isFavorite, "form", "")
	}
	if r.isMovie != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsMovie", r.isMovie, "form", "")
	}
	if r.isSeries != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsSeries", r.isSeries, "form", "")
	}
	if r.isNews != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsNews", r.isNews, "form", "")
	}
	if r.isKids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsKids", r.isKids, "form", "")
	}
	if r.isSports != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsSports", r.isSports, "form", "")
	}
	if r.mediaTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MediaTypes", r.mediaTypes, "form", "")
	}
	if r.imageTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ImageTypes", r.imageTypes, "form", "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SortBy", r.sortBy, "form", "")
	}
	if r.isPlayed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsPlayed", r.isPlayed, "form", "")
	}
	if r.genres != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Genres", r.genres, "form", "")
	}
	if r.officialRatings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "OfficialRatings", r.officialRatings, "form", "")
	}
	if r.tags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Tags", r.tags, "form", "")
	}
	if r.years != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Years", r.years, "form", "")
	}
	if r.enableImages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImages", r.enableImages, "form", "")
	}
	if r.enableUserData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableUserData", r.enableUserData, "form", "")
	}
	if r.imageTypeLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ImageTypeLimit", r.imageTypeLimit, "form", "")
	}
	if r.enableImageTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImageTypes", r.enableImageTypes, "form", "")
	}
	if r.person != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Person", r.person, "form", "")
	}
	if r.personIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "PersonIds", r.personIds, "form", "")
	}
	if r.personTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "PersonTypes", r.personTypes, "form", "")
	}
	if r.studios != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Studios", r.studios, "form", "")
	}
	if r.studioIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "StudioIds", r.studioIds, "form", "")
	}
	if r.artists != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Artists", r.artists, "form", "")
	}
	if r.artistIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ArtistIds", r.artistIds, "form", "")
	}
	if r.albums != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Albums", r.albums, "form", "")
	}
	if r.ids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Ids", r.ids, "form", "")
	}
	if r.videoTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "VideoTypes", r.videoTypes, "form", "")
	}
	if r.containers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Containers", r.containers, "form", "")
	}
	if r.audioCodecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AudioCodecs", r.audioCodecs, "form", "")
	}
	if r.videoCodecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "VideoCodecs", r.videoCodecs, "form", "")
	}
	if r.subtitleCodecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SubtitleCodecs", r.subtitleCodecs, "form", "")
	}
	if r.path != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Path", r.path, "form", "")
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "UserId", r.userId, "form", "")
	}
	if r.minOfficialRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinOfficialRating", r.minOfficialRating, "form", "")
	}
	if r.isLocked != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsLocked", r.isLocked, "form", "")
	}
	if r.isPlaceHolder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsPlaceHolder", r.isPlaceHolder, "form", "")
	}
	if r.hasOfficialRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasOfficialRating", r.hasOfficialRating, "form", "")
	}
	if r.groupItemsIntoCollections != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "GroupItemsIntoCollections", r.groupItemsIntoCollections, "form", "")
	}
	if r.is3D != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Is3D", r.is3D, "form", "")
	}
	if r.seriesStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SeriesStatus", r.seriesStatus, "form", "")
	}
	if r.nameStartsWithOrGreater != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "NameStartsWithOrGreater", r.nameStartsWithOrGreater, "form", "")
	}
	if r.nameStartsWith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "NameStartsWith", r.nameStartsWith, "form", "")
	}
	if r.nameLessThan != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "NameLessThan", r.nameLessThan, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAudiocodecsRequest struct {
	ctx context.Context
	ApiService TagServiceAPI
	artistType *string
	maxOfficialRating *string
	hasThemeSong *bool
	hasThemeVideo *bool
	hasSubtitles *bool
	hasSpecialFeature *bool
	hasTrailer *bool
	adjacentTo *string
	minIndexNumber *int32
	minPlayers *int32
	maxPlayers *int32
	parentIndexNumber *int32
	hasParentalRating *bool
	isHD *bool
	locationTypes *string
	excludeLocationTypes *string
	isMissing *bool
	isUnaired *bool
	minCommunityRating *float64
	minCriticRating *float64
	airedDuringSeason *int32
	minPremiereDate *string
	minDateLastSaved *string
	minDateLastSavedForUser *string
	maxPremiereDate *string
	hasOverview *bool
	hasImdbId *bool
	hasTmdbId *bool
	hasTvdbId *bool
	excludeItemIds *string
	startIndex *int32
	limit *int32
	recursive *bool
	sortOrder *string
	parentId *string
	fields *string
	excludeItemTypes *string
	includeItemTypes *string
	anyProviderIdEquals *string
	filters *string
	isFavorite *bool
	isMovie *bool
	isSeries *bool
	isNews *bool
	isKids *bool
	isSports *bool
	mediaTypes *string
	imageTypes *string
	sortBy *string
	isPlayed *bool
	genres *string
	officialRatings *string
	tags *string
	years *string
	enableImages *bool
	enableUserData *bool
	imageTypeLimit *int32
	enableImageTypes *string
	person *string
	personIds *string
	personTypes *string
	studios *string
	studioIds *string
	artists *string
	artistIds *string
	albums *string
	ids *string
	videoTypes *string
	containers *string
	audioCodecs *string
	videoCodecs *string
	subtitleCodecs *string
	path *string
	userId *string
	minOfficialRating *string
	isLocked *bool
	isPlaceHolder *bool
	hasOfficialRating *bool
	groupItemsIntoCollections *bool
	is3D *bool
	seriesStatus *string
	nameStartsWithOrGreater *string
	nameStartsWith *string
	nameLessThan *string
}

// Artist or AlbumArtist
func (r ApiGetAudiocodecsRequest) ArtistType(artistType string) ApiGetAudiocodecsRequest {
	r.artistType = &artistType
	return r
}

// Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
func (r ApiGetAudiocodecsRequest) MaxOfficialRating(maxOfficialRating string) ApiGetAudiocodecsRequest {
	r.maxOfficialRating = &maxOfficialRating
	return r
}

// Optional filter by items with theme songs.
func (r ApiGetAudiocodecsRequest) HasThemeSong(hasThemeSong bool) ApiGetAudiocodecsRequest {
	r.hasThemeSong = &hasThemeSong
	return r
}

// Optional filter by items with theme videos.
func (r ApiGetAudiocodecsRequest) HasThemeVideo(hasThemeVideo bool) ApiGetAudiocodecsRequest {
	r.hasThemeVideo = &hasThemeVideo
	return r
}

// Optional filter by items with subtitles.
func (r ApiGetAudiocodecsRequest) HasSubtitles(hasSubtitles bool) ApiGetAudiocodecsRequest {
	r.hasSubtitles = &hasSubtitles
	return r
}

// Optional filter by items with special features.
func (r ApiGetAudiocodecsRequest) HasSpecialFeature(hasSpecialFeature bool) ApiGetAudiocodecsRequest {
	r.hasSpecialFeature = &hasSpecialFeature
	return r
}

// Optional filter by items with trailers.
func (r ApiGetAudiocodecsRequest) HasTrailer(hasTrailer bool) ApiGetAudiocodecsRequest {
	r.hasTrailer = &hasTrailer
	return r
}

// Optional. Return items that are siblings of a supplied item.
func (r ApiGetAudiocodecsRequest) AdjacentTo(adjacentTo string) ApiGetAudiocodecsRequest {
	r.adjacentTo = &adjacentTo
	return r
}

// Optional filter by minimum index number.
func (r ApiGetAudiocodecsRequest) MinIndexNumber(minIndexNumber int32) ApiGetAudiocodecsRequest {
	r.minIndexNumber = &minIndexNumber
	return r
}

// Optional filter by minimum number of game players.
func (r ApiGetAudiocodecsRequest) MinPlayers(minPlayers int32) ApiGetAudiocodecsRequest {
	r.minPlayers = &minPlayers
	return r
}

// Optional filter by maximum number of game players.
func (r ApiGetAudiocodecsRequest) MaxPlayers(maxPlayers int32) ApiGetAudiocodecsRequest {
	r.maxPlayers = &maxPlayers
	return r
}

// Optional filter by parent index number.
func (r ApiGetAudiocodecsRequest) ParentIndexNumber(parentIndexNumber int32) ApiGetAudiocodecsRequest {
	r.parentIndexNumber = &parentIndexNumber
	return r
}

// Optional filter by items that have or do not have a parental rating
func (r ApiGetAudiocodecsRequest) HasParentalRating(hasParentalRating bool) ApiGetAudiocodecsRequest {
	r.hasParentalRating = &hasParentalRating
	return r
}

// Optional filter by items that are HD or not.
func (r ApiGetAudiocodecsRequest) IsHD(isHD bool) ApiGetAudiocodecsRequest {
	r.isHD = &isHD
	return r
}

// Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
func (r ApiGetAudiocodecsRequest) LocationTypes(locationTypes string) ApiGetAudiocodecsRequest {
	r.locationTypes = &locationTypes
	return r
}

// Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
func (r ApiGetAudiocodecsRequest) ExcludeLocationTypes(excludeLocationTypes string) ApiGetAudiocodecsRequest {
	r.excludeLocationTypes = &excludeLocationTypes
	return r
}

// Optional filter by items that are missing episodes or not.
func (r ApiGetAudiocodecsRequest) IsMissing(isMissing bool) ApiGetAudiocodecsRequest {
	r.isMissing = &isMissing
	return r
}

// Optional filter by items that are unaired episodes or not.
func (r ApiGetAudiocodecsRequest) IsUnaired(isUnaired bool) ApiGetAudiocodecsRequest {
	r.isUnaired = &isUnaired
	return r
}

// Optional filter by minimum community rating.
func (r ApiGetAudiocodecsRequest) MinCommunityRating(minCommunityRating float64) ApiGetAudiocodecsRequest {
	r.minCommunityRating = &minCommunityRating
	return r
}

// Optional filter by minimum critic rating.
func (r ApiGetAudiocodecsRequest) MinCriticRating(minCriticRating float64) ApiGetAudiocodecsRequest {
	r.minCriticRating = &minCriticRating
	return r
}

// Gets all episodes that aired during a season, including specials.
func (r ApiGetAudiocodecsRequest) AiredDuringSeason(airedDuringSeason int32) ApiGetAudiocodecsRequest {
	r.airedDuringSeason = &airedDuringSeason
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r ApiGetAudiocodecsRequest) MinPremiereDate(minPremiereDate string) ApiGetAudiocodecsRequest {
	r.minPremiereDate = &minPremiereDate
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r ApiGetAudiocodecsRequest) MinDateLastSaved(minDateLastSaved string) ApiGetAudiocodecsRequest {
	r.minDateLastSaved = &minDateLastSaved
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r ApiGetAudiocodecsRequest) MinDateLastSavedForUser(minDateLastSavedForUser string) ApiGetAudiocodecsRequest {
	r.minDateLastSavedForUser = &minDateLastSavedForUser
	return r
}

// Optional. The maximum premiere date. Format &#x3D; ISO
func (r ApiGetAudiocodecsRequest) MaxPremiereDate(maxPremiereDate string) ApiGetAudiocodecsRequest {
	r.maxPremiereDate = &maxPremiereDate
	return r
}

// Optional filter by items that have an overview or not.
func (r ApiGetAudiocodecsRequest) HasOverview(hasOverview bool) ApiGetAudiocodecsRequest {
	r.hasOverview = &hasOverview
	return r
}

// Optional filter by items that have an imdb id or not.
func (r ApiGetAudiocodecsRequest) HasImdbId(hasImdbId bool) ApiGetAudiocodecsRequest {
	r.hasImdbId = &hasImdbId
	return r
}

// Optional filter by items that have a tmdb id or not.
func (r ApiGetAudiocodecsRequest) HasTmdbId(hasTmdbId bool) ApiGetAudiocodecsRequest {
	r.hasTmdbId = &hasTmdbId
	return r
}

// Optional filter by items that have a tvdb id or not.
func (r ApiGetAudiocodecsRequest) HasTvdbId(hasTvdbId bool) ApiGetAudiocodecsRequest {
	r.hasTvdbId = &hasTvdbId
	return r
}

// Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
func (r ApiGetAudiocodecsRequest) ExcludeItemIds(excludeItemIds string) ApiGetAudiocodecsRequest {
	r.excludeItemIds = &excludeItemIds
	return r
}

// Optional. The record index to start at. All items with a lower index will be dropped from the results.
func (r ApiGetAudiocodecsRequest) StartIndex(startIndex int32) ApiGetAudiocodecsRequest {
	r.startIndex = &startIndex
	return r
}

// Optional. The maximum number of records to return
func (r ApiGetAudiocodecsRequest) Limit(limit int32) ApiGetAudiocodecsRequest {
	r.limit = &limit
	return r
}

// When searching within folders, this determines whether or not the search will be recursive. true/false
func (r ApiGetAudiocodecsRequest) Recursive(recursive bool) ApiGetAudiocodecsRequest {
	r.recursive = &recursive
	return r
}

// Sort Order - Ascending,Descending
func (r ApiGetAudiocodecsRequest) SortOrder(sortOrder string) ApiGetAudiocodecsRequest {
	r.sortOrder = &sortOrder
	return r
}

// Specify this to localize the search to a specific item or folder. Omit to use the root
func (r ApiGetAudiocodecsRequest) ParentId(parentId string) ApiGetAudiocodecsRequest {
	r.parentId = &parentId
	return r
}

// Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
func (r ApiGetAudiocodecsRequest) Fields(fields string) ApiGetAudiocodecsRequest {
	r.fields = &fields
	return r
}

// Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
func (r ApiGetAudiocodecsRequest) ExcludeItemTypes(excludeItemTypes string) ApiGetAudiocodecsRequest {
	r.excludeItemTypes = &excludeItemTypes
	return r
}

// Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
func (r ApiGetAudiocodecsRequest) IncludeItemTypes(includeItemTypes string) ApiGetAudiocodecsRequest {
	r.includeItemTypes = &includeItemTypes
	return r
}

// Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form &#39;prov.id&#39;, e.g. &#39;imdb.tt123456&#39;. This allows multiple, comma delimeted value pairs.
func (r ApiGetAudiocodecsRequest) AnyProviderIdEquals(anyProviderIdEquals string) ApiGetAudiocodecsRequest {
	r.anyProviderIdEquals = &anyProviderIdEquals
	return r
}

// Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
func (r ApiGetAudiocodecsRequest) Filters(filters string) ApiGetAudiocodecsRequest {
	r.filters = &filters
	return r
}

// Optional filter by items that are marked as favorite, or not.
func (r ApiGetAudiocodecsRequest) IsFavorite(isFavorite bool) ApiGetAudiocodecsRequest {
	r.isFavorite = &isFavorite
	return r
}

// Optional filter for movies.
func (r ApiGetAudiocodecsRequest) IsMovie(isMovie bool) ApiGetAudiocodecsRequest {
	r.isMovie = &isMovie
	return r
}

// Optional filter for movies.
func (r ApiGetAudiocodecsRequest) IsSeries(isSeries bool) ApiGetAudiocodecsRequest {
	r.isSeries = &isSeries
	return r
}

// Optional filter for news.
func (r ApiGetAudiocodecsRequest) IsNews(isNews bool) ApiGetAudiocodecsRequest {
	r.isNews = &isNews
	return r
}

// Optional filter for kids.
func (r ApiGetAudiocodecsRequest) IsKids(isKids bool) ApiGetAudiocodecsRequest {
	r.isKids = &isKids
	return r
}

// Optional filter for sports.
func (r ApiGetAudiocodecsRequest) IsSports(isSports bool) ApiGetAudiocodecsRequest {
	r.isSports = &isSports
	return r
}

// Optional filter by MediaType. Allows multiple, comma delimited.
func (r ApiGetAudiocodecsRequest) MediaTypes(mediaTypes string) ApiGetAudiocodecsRequest {
	r.mediaTypes = &mediaTypes
	return r
}

// Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
func (r ApiGetAudiocodecsRequest) ImageTypes(imageTypes string) ApiGetAudiocodecsRequest {
	r.imageTypes = &imageTypes
	return r
}

// Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
func (r ApiGetAudiocodecsRequest) SortBy(sortBy string) ApiGetAudiocodecsRequest {
	r.sortBy = &sortBy
	return r
}

// Optional filter by items that are played, or not.
func (r ApiGetAudiocodecsRequest) IsPlayed(isPlayed bool) ApiGetAudiocodecsRequest {
	r.isPlayed = &isPlayed
	return r
}

// Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
func (r ApiGetAudiocodecsRequest) Genres(genres string) ApiGetAudiocodecsRequest {
	r.genres = &genres
	return r
}

// Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
func (r ApiGetAudiocodecsRequest) OfficialRatings(officialRatings string) ApiGetAudiocodecsRequest {
	r.officialRatings = &officialRatings
	return r
}

// Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
func (r ApiGetAudiocodecsRequest) Tags(tags string) ApiGetAudiocodecsRequest {
	r.tags = &tags
	return r
}

// Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
func (r ApiGetAudiocodecsRequest) Years(years string) ApiGetAudiocodecsRequest {
	r.years = &years
	return r
}

// Optional, include image information in output
func (r ApiGetAudiocodecsRequest) EnableImages(enableImages bool) ApiGetAudiocodecsRequest {
	r.enableImages = &enableImages
	return r
}

// Optional, include user data
func (r ApiGetAudiocodecsRequest) EnableUserData(enableUserData bool) ApiGetAudiocodecsRequest {
	r.enableUserData = &enableUserData
	return r
}

// Optional, the max number of images to return, per image type
func (r ApiGetAudiocodecsRequest) ImageTypeLimit(imageTypeLimit int32) ApiGetAudiocodecsRequest {
	r.imageTypeLimit = &imageTypeLimit
	return r
}

// Optional. The image types to include in the output.
func (r ApiGetAudiocodecsRequest) EnableImageTypes(enableImageTypes string) ApiGetAudiocodecsRequest {
	r.enableImageTypes = &enableImageTypes
	return r
}

// Optional. If specified, results will be filtered to include only those containing the specified person.
func (r ApiGetAudiocodecsRequest) Person(person string) ApiGetAudiocodecsRequest {
	r.person = &person
	return r
}

// Optional. If specified, results will be filtered to include only those containing the specified person.
func (r ApiGetAudiocodecsRequest) PersonIds(personIds string) ApiGetAudiocodecsRequest {
	r.personIds = &personIds
	return r
}

// Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
func (r ApiGetAudiocodecsRequest) PersonTypes(personTypes string) ApiGetAudiocodecsRequest {
	r.personTypes = &personTypes
	return r
}

// Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
func (r ApiGetAudiocodecsRequest) Studios(studios string) ApiGetAudiocodecsRequest {
	r.studios = &studios
	return r
}

// Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
func (r ApiGetAudiocodecsRequest) StudioIds(studioIds string) ApiGetAudiocodecsRequest {
	r.studioIds = &studioIds
	return r
}

// Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
func (r ApiGetAudiocodecsRequest) Artists(artists string) ApiGetAudiocodecsRequest {
	r.artists = &artists
	return r
}

// Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
func (r ApiGetAudiocodecsRequest) ArtistIds(artistIds string) ApiGetAudiocodecsRequest {
	r.artistIds = &artistIds
	return r
}

// Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
func (r ApiGetAudiocodecsRequest) Albums(albums string) ApiGetAudiocodecsRequest {
	r.albums = &albums
	return r
}

// Optional. If specific items are needed, specify a list of item id&#39;s to retrieve. This allows multiple, comma delimited.
func (r ApiGetAudiocodecsRequest) Ids(ids string) ApiGetAudiocodecsRequest {
	r.ids = &ids
	return r
}

// Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
func (r ApiGetAudiocodecsRequest) VideoTypes(videoTypes string) ApiGetAudiocodecsRequest {
	r.videoTypes = &videoTypes
	return r
}

// Optional filter by Container. Allows multiple, comma delimeted.
func (r ApiGetAudiocodecsRequest) Containers(containers string) ApiGetAudiocodecsRequest {
	r.containers = &containers
	return r
}

// Optional filter by AudioCodec. Allows multiple, comma delimeted.
func (r ApiGetAudiocodecsRequest) AudioCodecs(audioCodecs string) ApiGetAudiocodecsRequest {
	r.audioCodecs = &audioCodecs
	return r
}

// Optional filter by VideoCodec. Allows multiple, comma delimeted.
func (r ApiGetAudiocodecsRequest) VideoCodecs(videoCodecs string) ApiGetAudiocodecsRequest {
	r.videoCodecs = &videoCodecs
	return r
}

// Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
func (r ApiGetAudiocodecsRequest) SubtitleCodecs(subtitleCodecs string) ApiGetAudiocodecsRequest {
	r.subtitleCodecs = &subtitleCodecs
	return r
}

// Optional filter by Path.
func (r ApiGetAudiocodecsRequest) Path(path string) ApiGetAudiocodecsRequest {
	r.path = &path
	return r
}

// User Id
func (r ApiGetAudiocodecsRequest) UserId(userId string) ApiGetAudiocodecsRequest {
	r.userId = &userId
	return r
}

// Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
func (r ApiGetAudiocodecsRequest) MinOfficialRating(minOfficialRating string) ApiGetAudiocodecsRequest {
	r.minOfficialRating = &minOfficialRating
	return r
}

// Optional filter by items that are locked.
func (r ApiGetAudiocodecsRequest) IsLocked(isLocked bool) ApiGetAudiocodecsRequest {
	r.isLocked = &isLocked
	return r
}

// Optional filter by items that are placeholders
func (r ApiGetAudiocodecsRequest) IsPlaceHolder(isPlaceHolder bool) ApiGetAudiocodecsRequest {
	r.isPlaceHolder = &isPlaceHolder
	return r
}

// Optional filter by items that have official ratings
func (r ApiGetAudiocodecsRequest) HasOfficialRating(hasOfficialRating bool) ApiGetAudiocodecsRequest {
	r.hasOfficialRating = &hasOfficialRating
	return r
}

// Whether or not to hide items behind their boxsets.
func (r ApiGetAudiocodecsRequest) GroupItemsIntoCollections(groupItemsIntoCollections bool) ApiGetAudiocodecsRequest {
	r.groupItemsIntoCollections = &groupItemsIntoCollections
	return r
}

// Optional filter by items that are 3D, or not.
func (r ApiGetAudiocodecsRequest) Is3D(is3D bool) ApiGetAudiocodecsRequest {
	r.is3D = &is3D
	return r
}

// Optional filter by Series Status. Allows multiple, comma delimeted.
func (r ApiGetAudiocodecsRequest) SeriesStatus(seriesStatus string) ApiGetAudiocodecsRequest {
	r.seriesStatus = &seriesStatus
	return r
}

// Optional filter by items whose name is sorted equally or greater than a given input string.
func (r ApiGetAudiocodecsRequest) NameStartsWithOrGreater(nameStartsWithOrGreater string) ApiGetAudiocodecsRequest {
	r.nameStartsWithOrGreater = &nameStartsWithOrGreater
	return r
}

// Optional filter by items whose name is sorted equally than a given input string.
func (r ApiGetAudiocodecsRequest) NameStartsWith(nameStartsWith string) ApiGetAudiocodecsRequest {
	r.nameStartsWith = &nameStartsWith
	return r
}

// Optional filter by items whose name is equally or lesser than a given input string.
func (r ApiGetAudiocodecsRequest) NameLessThan(nameLessThan string) ApiGetAudiocodecsRequest {
	r.nameLessThan = &nameLessThan
	return r
}

func (r ApiGetAudiocodecsRequest) Execute() (*QueryResultUserLibraryTagItem, *http.Response, error) {
	return r.ApiService.GetAudiocodecsExecute(r)
}

/*
GetAudiocodecs Gets items based on a query.

No authentication required

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAudiocodecsRequest
*/
func (a *TagServiceAPIService) GetAudiocodecs(ctx context.Context) ApiGetAudiocodecsRequest {
	return ApiGetAudiocodecsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return QueryResultUserLibraryTagItem
func (a *TagServiceAPIService) GetAudiocodecsExecute(r ApiGetAudiocodecsRequest) (*QueryResultUserLibraryTagItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QueryResultUserLibraryTagItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TagServiceAPIService.GetAudiocodecs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/AudioCodecs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.artistType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ArtistType", r.artistType, "form", "")
	}
	if r.maxOfficialRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxOfficialRating", r.maxOfficialRating, "form", "")
	}
	if r.hasThemeSong != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasThemeSong", r.hasThemeSong, "form", "")
	}
	if r.hasThemeVideo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasThemeVideo", r.hasThemeVideo, "form", "")
	}
	if r.hasSubtitles != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasSubtitles", r.hasSubtitles, "form", "")
	}
	if r.hasSpecialFeature != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasSpecialFeature", r.hasSpecialFeature, "form", "")
	}
	if r.hasTrailer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasTrailer", r.hasTrailer, "form", "")
	}
	if r.adjacentTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AdjacentTo", r.adjacentTo, "form", "")
	}
	if r.minIndexNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinIndexNumber", r.minIndexNumber, "form", "")
	}
	if r.minPlayers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinPlayers", r.minPlayers, "form", "")
	}
	if r.maxPlayers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxPlayers", r.maxPlayers, "form", "")
	}
	if r.parentIndexNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ParentIndexNumber", r.parentIndexNumber, "form", "")
	}
	if r.hasParentalRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasParentalRating", r.hasParentalRating, "form", "")
	}
	if r.isHD != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsHD", r.isHD, "form", "")
	}
	if r.locationTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "LocationTypes", r.locationTypes, "form", "")
	}
	if r.excludeLocationTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ExcludeLocationTypes", r.excludeLocationTypes, "form", "")
	}
	if r.isMissing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsMissing", r.isMissing, "form", "")
	}
	if r.isUnaired != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsUnaired", r.isUnaired, "form", "")
	}
	if r.minCommunityRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinCommunityRating", r.minCommunityRating, "form", "")
	}
	if r.minCriticRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinCriticRating", r.minCriticRating, "form", "")
	}
	if r.airedDuringSeason != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AiredDuringSeason", r.airedDuringSeason, "form", "")
	}
	if r.minPremiereDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinPremiereDate", r.minPremiereDate, "form", "")
	}
	if r.minDateLastSaved != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinDateLastSaved", r.minDateLastSaved, "form", "")
	}
	if r.minDateLastSavedForUser != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinDateLastSavedForUser", r.minDateLastSavedForUser, "form", "")
	}
	if r.maxPremiereDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxPremiereDate", r.maxPremiereDate, "form", "")
	}
	if r.hasOverview != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasOverview", r.hasOverview, "form", "")
	}
	if r.hasImdbId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasImdbId", r.hasImdbId, "form", "")
	}
	if r.hasTmdbId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasTmdbId", r.hasTmdbId, "form", "")
	}
	if r.hasTvdbId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasTvdbId", r.hasTvdbId, "form", "")
	}
	if r.excludeItemIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ExcludeItemIds", r.excludeItemIds, "form", "")
	}
	if r.startIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "StartIndex", r.startIndex, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Limit", r.limit, "form", "")
	}
	if r.recursive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Recursive", r.recursive, "form", "")
	}
	if r.sortOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SortOrder", r.sortOrder, "form", "")
	}
	if r.parentId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ParentId", r.parentId, "form", "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Fields", r.fields, "form", "")
	}
	if r.excludeItemTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ExcludeItemTypes", r.excludeItemTypes, "form", "")
	}
	if r.includeItemTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IncludeItemTypes", r.includeItemTypes, "form", "")
	}
	if r.anyProviderIdEquals != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AnyProviderIdEquals", r.anyProviderIdEquals, "form", "")
	}
	if r.filters != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Filters", r.filters, "form", "")
	}
	if r.isFavorite != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsFavorite", r.isFavorite, "form", "")
	}
	if r.isMovie != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsMovie", r.isMovie, "form", "")
	}
	if r.isSeries != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsSeries", r.isSeries, "form", "")
	}
	if r.isNews != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsNews", r.isNews, "form", "")
	}
	if r.isKids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsKids", r.isKids, "form", "")
	}
	if r.isSports != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsSports", r.isSports, "form", "")
	}
	if r.mediaTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MediaTypes", r.mediaTypes, "form", "")
	}
	if r.imageTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ImageTypes", r.imageTypes, "form", "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SortBy", r.sortBy, "form", "")
	}
	if r.isPlayed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsPlayed", r.isPlayed, "form", "")
	}
	if r.genres != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Genres", r.genres, "form", "")
	}
	if r.officialRatings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "OfficialRatings", r.officialRatings, "form", "")
	}
	if r.tags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Tags", r.tags, "form", "")
	}
	if r.years != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Years", r.years, "form", "")
	}
	if r.enableImages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImages", r.enableImages, "form", "")
	}
	if r.enableUserData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableUserData", r.enableUserData, "form", "")
	}
	if r.imageTypeLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ImageTypeLimit", r.imageTypeLimit, "form", "")
	}
	if r.enableImageTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImageTypes", r.enableImageTypes, "form", "")
	}
	if r.person != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Person", r.person, "form", "")
	}
	if r.personIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "PersonIds", r.personIds, "form", "")
	}
	if r.personTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "PersonTypes", r.personTypes, "form", "")
	}
	if r.studios != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Studios", r.studios, "form", "")
	}
	if r.studioIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "StudioIds", r.studioIds, "form", "")
	}
	if r.artists != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Artists", r.artists, "form", "")
	}
	if r.artistIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ArtistIds", r.artistIds, "form", "")
	}
	if r.albums != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Albums", r.albums, "form", "")
	}
	if r.ids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Ids", r.ids, "form", "")
	}
	if r.videoTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "VideoTypes", r.videoTypes, "form", "")
	}
	if r.containers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Containers", r.containers, "form", "")
	}
	if r.audioCodecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AudioCodecs", r.audioCodecs, "form", "")
	}
	if r.videoCodecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "VideoCodecs", r.videoCodecs, "form", "")
	}
	if r.subtitleCodecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SubtitleCodecs", r.subtitleCodecs, "form", "")
	}
	if r.path != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Path", r.path, "form", "")
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "UserId", r.userId, "form", "")
	}
	if r.minOfficialRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinOfficialRating", r.minOfficialRating, "form", "")
	}
	if r.isLocked != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsLocked", r.isLocked, "form", "")
	}
	if r.isPlaceHolder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsPlaceHolder", r.isPlaceHolder, "form", "")
	}
	if r.hasOfficialRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasOfficialRating", r.hasOfficialRating, "form", "")
	}
	if r.groupItemsIntoCollections != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "GroupItemsIntoCollections", r.groupItemsIntoCollections, "form", "")
	}
	if r.is3D != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Is3D", r.is3D, "form", "")
	}
	if r.seriesStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SeriesStatus", r.seriesStatus, "form", "")
	}
	if r.nameStartsWithOrGreater != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "NameStartsWithOrGreater", r.nameStartsWithOrGreater, "form", "")
	}
	if r.nameStartsWith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "NameStartsWith", r.nameStartsWith, "form", "")
	}
	if r.nameLessThan != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "NameLessThan", r.nameLessThan, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetContainersRequest struct {
	ctx context.Context
	ApiService TagServiceAPI
	artistType *string
	maxOfficialRating *string
	hasThemeSong *bool
	hasThemeVideo *bool
	hasSubtitles *bool
	hasSpecialFeature *bool
	hasTrailer *bool
	adjacentTo *string
	minIndexNumber *int32
	minPlayers *int32
	maxPlayers *int32
	parentIndexNumber *int32
	hasParentalRating *bool
	isHD *bool
	locationTypes *string
	excludeLocationTypes *string
	isMissing *bool
	isUnaired *bool
	minCommunityRating *float64
	minCriticRating *float64
	airedDuringSeason *int32
	minPremiereDate *string
	minDateLastSaved *string
	minDateLastSavedForUser *string
	maxPremiereDate *string
	hasOverview *bool
	hasImdbId *bool
	hasTmdbId *bool
	hasTvdbId *bool
	excludeItemIds *string
	startIndex *int32
	limit *int32
	recursive *bool
	sortOrder *string
	parentId *string
	fields *string
	excludeItemTypes *string
	includeItemTypes *string
	anyProviderIdEquals *string
	filters *string
	isFavorite *bool
	isMovie *bool
	isSeries *bool
	isNews *bool
	isKids *bool
	isSports *bool
	mediaTypes *string
	imageTypes *string
	sortBy *string
	isPlayed *bool
	genres *string
	officialRatings *string
	tags *string
	years *string
	enableImages *bool
	enableUserData *bool
	imageTypeLimit *int32
	enableImageTypes *string
	person *string
	personIds *string
	personTypes *string
	studios *string
	studioIds *string
	artists *string
	artistIds *string
	albums *string
	ids *string
	videoTypes *string
	containers *string
	audioCodecs *string
	videoCodecs *string
	subtitleCodecs *string
	path *string
	userId *string
	minOfficialRating *string
	isLocked *bool
	isPlaceHolder *bool
	hasOfficialRating *bool
	groupItemsIntoCollections *bool
	is3D *bool
	seriesStatus *string
	nameStartsWithOrGreater *string
	nameStartsWith *string
	nameLessThan *string
}

// Artist or AlbumArtist
func (r ApiGetContainersRequest) ArtistType(artistType string) ApiGetContainersRequest {
	r.artistType = &artistType
	return r
}

// Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
func (r ApiGetContainersRequest) MaxOfficialRating(maxOfficialRating string) ApiGetContainersRequest {
	r.maxOfficialRating = &maxOfficialRating
	return r
}

// Optional filter by items with theme songs.
func (r ApiGetContainersRequest) HasThemeSong(hasThemeSong bool) ApiGetContainersRequest {
	r.hasThemeSong = &hasThemeSong
	return r
}

// Optional filter by items with theme videos.
func (r ApiGetContainersRequest) HasThemeVideo(hasThemeVideo bool) ApiGetContainersRequest {
	r.hasThemeVideo = &hasThemeVideo
	return r
}

// Optional filter by items with subtitles.
func (r ApiGetContainersRequest) HasSubtitles(hasSubtitles bool) ApiGetContainersRequest {
	r.hasSubtitles = &hasSubtitles
	return r
}

// Optional filter by items with special features.
func (r ApiGetContainersRequest) HasSpecialFeature(hasSpecialFeature bool) ApiGetContainersRequest {
	r.hasSpecialFeature = &hasSpecialFeature
	return r
}

// Optional filter by items with trailers.
func (r ApiGetContainersRequest) HasTrailer(hasTrailer bool) ApiGetContainersRequest {
	r.hasTrailer = &hasTrailer
	return r
}

// Optional. Return items that are siblings of a supplied item.
func (r ApiGetContainersRequest) AdjacentTo(adjacentTo string) ApiGetContainersRequest {
	r.adjacentTo = &adjacentTo
	return r
}

// Optional filter by minimum index number.
func (r ApiGetContainersRequest) MinIndexNumber(minIndexNumber int32) ApiGetContainersRequest {
	r.minIndexNumber = &minIndexNumber
	return r
}

// Optional filter by minimum number of game players.
func (r ApiGetContainersRequest) MinPlayers(minPlayers int32) ApiGetContainersRequest {
	r.minPlayers = &minPlayers
	return r
}

// Optional filter by maximum number of game players.
func (r ApiGetContainersRequest) MaxPlayers(maxPlayers int32) ApiGetContainersRequest {
	r.maxPlayers = &maxPlayers
	return r
}

// Optional filter by parent index number.
func (r ApiGetContainersRequest) ParentIndexNumber(parentIndexNumber int32) ApiGetContainersRequest {
	r.parentIndexNumber = &parentIndexNumber
	return r
}

// Optional filter by items that have or do not have a parental rating
func (r ApiGetContainersRequest) HasParentalRating(hasParentalRating bool) ApiGetContainersRequest {
	r.hasParentalRating = &hasParentalRating
	return r
}

// Optional filter by items that are HD or not.
func (r ApiGetContainersRequest) IsHD(isHD bool) ApiGetContainersRequest {
	r.isHD = &isHD
	return r
}

// Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
func (r ApiGetContainersRequest) LocationTypes(locationTypes string) ApiGetContainersRequest {
	r.locationTypes = &locationTypes
	return r
}

// Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
func (r ApiGetContainersRequest) ExcludeLocationTypes(excludeLocationTypes string) ApiGetContainersRequest {
	r.excludeLocationTypes = &excludeLocationTypes
	return r
}

// Optional filter by items that are missing episodes or not.
func (r ApiGetContainersRequest) IsMissing(isMissing bool) ApiGetContainersRequest {
	r.isMissing = &isMissing
	return r
}

// Optional filter by items that are unaired episodes or not.
func (r ApiGetContainersRequest) IsUnaired(isUnaired bool) ApiGetContainersRequest {
	r.isUnaired = &isUnaired
	return r
}

// Optional filter by minimum community rating.
func (r ApiGetContainersRequest) MinCommunityRating(minCommunityRating float64) ApiGetContainersRequest {
	r.minCommunityRating = &minCommunityRating
	return r
}

// Optional filter by minimum critic rating.
func (r ApiGetContainersRequest) MinCriticRating(minCriticRating float64) ApiGetContainersRequest {
	r.minCriticRating = &minCriticRating
	return r
}

// Gets all episodes that aired during a season, including specials.
func (r ApiGetContainersRequest) AiredDuringSeason(airedDuringSeason int32) ApiGetContainersRequest {
	r.airedDuringSeason = &airedDuringSeason
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r ApiGetContainersRequest) MinPremiereDate(minPremiereDate string) ApiGetContainersRequest {
	r.minPremiereDate = &minPremiereDate
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r ApiGetContainersRequest) MinDateLastSaved(minDateLastSaved string) ApiGetContainersRequest {
	r.minDateLastSaved = &minDateLastSaved
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r ApiGetContainersRequest) MinDateLastSavedForUser(minDateLastSavedForUser string) ApiGetContainersRequest {
	r.minDateLastSavedForUser = &minDateLastSavedForUser
	return r
}

// Optional. The maximum premiere date. Format &#x3D; ISO
func (r ApiGetContainersRequest) MaxPremiereDate(maxPremiereDate string) ApiGetContainersRequest {
	r.maxPremiereDate = &maxPremiereDate
	return r
}

// Optional filter by items that have an overview or not.
func (r ApiGetContainersRequest) HasOverview(hasOverview bool) ApiGetContainersRequest {
	r.hasOverview = &hasOverview
	return r
}

// Optional filter by items that have an imdb id or not.
func (r ApiGetContainersRequest) HasImdbId(hasImdbId bool) ApiGetContainersRequest {
	r.hasImdbId = &hasImdbId
	return r
}

// Optional filter by items that have a tmdb id or not.
func (r ApiGetContainersRequest) HasTmdbId(hasTmdbId bool) ApiGetContainersRequest {
	r.hasTmdbId = &hasTmdbId
	return r
}

// Optional filter by items that have a tvdb id or not.
func (r ApiGetContainersRequest) HasTvdbId(hasTvdbId bool) ApiGetContainersRequest {
	r.hasTvdbId = &hasTvdbId
	return r
}

// Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
func (r ApiGetContainersRequest) ExcludeItemIds(excludeItemIds string) ApiGetContainersRequest {
	r.excludeItemIds = &excludeItemIds
	return r
}

// Optional. The record index to start at. All items with a lower index will be dropped from the results.
func (r ApiGetContainersRequest) StartIndex(startIndex int32) ApiGetContainersRequest {
	r.startIndex = &startIndex
	return r
}

// Optional. The maximum number of records to return
func (r ApiGetContainersRequest) Limit(limit int32) ApiGetContainersRequest {
	r.limit = &limit
	return r
}

// When searching within folders, this determines whether or not the search will be recursive. true/false
func (r ApiGetContainersRequest) Recursive(recursive bool) ApiGetContainersRequest {
	r.recursive = &recursive
	return r
}

// Sort Order - Ascending,Descending
func (r ApiGetContainersRequest) SortOrder(sortOrder string) ApiGetContainersRequest {
	r.sortOrder = &sortOrder
	return r
}

// Specify this to localize the search to a specific item or folder. Omit to use the root
func (r ApiGetContainersRequest) ParentId(parentId string) ApiGetContainersRequest {
	r.parentId = &parentId
	return r
}

// Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
func (r ApiGetContainersRequest) Fields(fields string) ApiGetContainersRequest {
	r.fields = &fields
	return r
}

// Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
func (r ApiGetContainersRequest) ExcludeItemTypes(excludeItemTypes string) ApiGetContainersRequest {
	r.excludeItemTypes = &excludeItemTypes
	return r
}

// Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
func (r ApiGetContainersRequest) IncludeItemTypes(includeItemTypes string) ApiGetContainersRequest {
	r.includeItemTypes = &includeItemTypes
	return r
}

// Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form &#39;prov.id&#39;, e.g. &#39;imdb.tt123456&#39;. This allows multiple, comma delimeted value pairs.
func (r ApiGetContainersRequest) AnyProviderIdEquals(anyProviderIdEquals string) ApiGetContainersRequest {
	r.anyProviderIdEquals = &anyProviderIdEquals
	return r
}

// Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
func (r ApiGetContainersRequest) Filters(filters string) ApiGetContainersRequest {
	r.filters = &filters
	return r
}

// Optional filter by items that are marked as favorite, or not.
func (r ApiGetContainersRequest) IsFavorite(isFavorite bool) ApiGetContainersRequest {
	r.isFavorite = &isFavorite
	return r
}

// Optional filter for movies.
func (r ApiGetContainersRequest) IsMovie(isMovie bool) ApiGetContainersRequest {
	r.isMovie = &isMovie
	return r
}

// Optional filter for movies.
func (r ApiGetContainersRequest) IsSeries(isSeries bool) ApiGetContainersRequest {
	r.isSeries = &isSeries
	return r
}

// Optional filter for news.
func (r ApiGetContainersRequest) IsNews(isNews bool) ApiGetContainersRequest {
	r.isNews = &isNews
	return r
}

// Optional filter for kids.
func (r ApiGetContainersRequest) IsKids(isKids bool) ApiGetContainersRequest {
	r.isKids = &isKids
	return r
}

// Optional filter for sports.
func (r ApiGetContainersRequest) IsSports(isSports bool) ApiGetContainersRequest {
	r.isSports = &isSports
	return r
}

// Optional filter by MediaType. Allows multiple, comma delimited.
func (r ApiGetContainersRequest) MediaTypes(mediaTypes string) ApiGetContainersRequest {
	r.mediaTypes = &mediaTypes
	return r
}

// Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
func (r ApiGetContainersRequest) ImageTypes(imageTypes string) ApiGetContainersRequest {
	r.imageTypes = &imageTypes
	return r
}

// Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
func (r ApiGetContainersRequest) SortBy(sortBy string) ApiGetContainersRequest {
	r.sortBy = &sortBy
	return r
}

// Optional filter by items that are played, or not.
func (r ApiGetContainersRequest) IsPlayed(isPlayed bool) ApiGetContainersRequest {
	r.isPlayed = &isPlayed
	return r
}

// Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
func (r ApiGetContainersRequest) Genres(genres string) ApiGetContainersRequest {
	r.genres = &genres
	return r
}

// Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
func (r ApiGetContainersRequest) OfficialRatings(officialRatings string) ApiGetContainersRequest {
	r.officialRatings = &officialRatings
	return r
}

// Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
func (r ApiGetContainersRequest) Tags(tags string) ApiGetContainersRequest {
	r.tags = &tags
	return r
}

// Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
func (r ApiGetContainersRequest) Years(years string) ApiGetContainersRequest {
	r.years = &years
	return r
}

// Optional, include image information in output
func (r ApiGetContainersRequest) EnableImages(enableImages bool) ApiGetContainersRequest {
	r.enableImages = &enableImages
	return r
}

// Optional, include user data
func (r ApiGetContainersRequest) EnableUserData(enableUserData bool) ApiGetContainersRequest {
	r.enableUserData = &enableUserData
	return r
}

// Optional, the max number of images to return, per image type
func (r ApiGetContainersRequest) ImageTypeLimit(imageTypeLimit int32) ApiGetContainersRequest {
	r.imageTypeLimit = &imageTypeLimit
	return r
}

// Optional. The image types to include in the output.
func (r ApiGetContainersRequest) EnableImageTypes(enableImageTypes string) ApiGetContainersRequest {
	r.enableImageTypes = &enableImageTypes
	return r
}

// Optional. If specified, results will be filtered to include only those containing the specified person.
func (r ApiGetContainersRequest) Person(person string) ApiGetContainersRequest {
	r.person = &person
	return r
}

// Optional. If specified, results will be filtered to include only those containing the specified person.
func (r ApiGetContainersRequest) PersonIds(personIds string) ApiGetContainersRequest {
	r.personIds = &personIds
	return r
}

// Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
func (r ApiGetContainersRequest) PersonTypes(personTypes string) ApiGetContainersRequest {
	r.personTypes = &personTypes
	return r
}

// Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
func (r ApiGetContainersRequest) Studios(studios string) ApiGetContainersRequest {
	r.studios = &studios
	return r
}

// Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
func (r ApiGetContainersRequest) StudioIds(studioIds string) ApiGetContainersRequest {
	r.studioIds = &studioIds
	return r
}

// Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
func (r ApiGetContainersRequest) Artists(artists string) ApiGetContainersRequest {
	r.artists = &artists
	return r
}

// Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
func (r ApiGetContainersRequest) ArtistIds(artistIds string) ApiGetContainersRequest {
	r.artistIds = &artistIds
	return r
}

// Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
func (r ApiGetContainersRequest) Albums(albums string) ApiGetContainersRequest {
	r.albums = &albums
	return r
}

// Optional. If specific items are needed, specify a list of item id&#39;s to retrieve. This allows multiple, comma delimited.
func (r ApiGetContainersRequest) Ids(ids string) ApiGetContainersRequest {
	r.ids = &ids
	return r
}

// Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
func (r ApiGetContainersRequest) VideoTypes(videoTypes string) ApiGetContainersRequest {
	r.videoTypes = &videoTypes
	return r
}

// Optional filter by Container. Allows multiple, comma delimeted.
func (r ApiGetContainersRequest) Containers(containers string) ApiGetContainersRequest {
	r.containers = &containers
	return r
}

// Optional filter by AudioCodec. Allows multiple, comma delimeted.
func (r ApiGetContainersRequest) AudioCodecs(audioCodecs string) ApiGetContainersRequest {
	r.audioCodecs = &audioCodecs
	return r
}

// Optional filter by VideoCodec. Allows multiple, comma delimeted.
func (r ApiGetContainersRequest) VideoCodecs(videoCodecs string) ApiGetContainersRequest {
	r.videoCodecs = &videoCodecs
	return r
}

// Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
func (r ApiGetContainersRequest) SubtitleCodecs(subtitleCodecs string) ApiGetContainersRequest {
	r.subtitleCodecs = &subtitleCodecs
	return r
}

// Optional filter by Path.
func (r ApiGetContainersRequest) Path(path string) ApiGetContainersRequest {
	r.path = &path
	return r
}

// User Id
func (r ApiGetContainersRequest) UserId(userId string) ApiGetContainersRequest {
	r.userId = &userId
	return r
}

// Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
func (r ApiGetContainersRequest) MinOfficialRating(minOfficialRating string) ApiGetContainersRequest {
	r.minOfficialRating = &minOfficialRating
	return r
}

// Optional filter by items that are locked.
func (r ApiGetContainersRequest) IsLocked(isLocked bool) ApiGetContainersRequest {
	r.isLocked = &isLocked
	return r
}

// Optional filter by items that are placeholders
func (r ApiGetContainersRequest) IsPlaceHolder(isPlaceHolder bool) ApiGetContainersRequest {
	r.isPlaceHolder = &isPlaceHolder
	return r
}

// Optional filter by items that have official ratings
func (r ApiGetContainersRequest) HasOfficialRating(hasOfficialRating bool) ApiGetContainersRequest {
	r.hasOfficialRating = &hasOfficialRating
	return r
}

// Whether or not to hide items behind their boxsets.
func (r ApiGetContainersRequest) GroupItemsIntoCollections(groupItemsIntoCollections bool) ApiGetContainersRequest {
	r.groupItemsIntoCollections = &groupItemsIntoCollections
	return r
}

// Optional filter by items that are 3D, or not.
func (r ApiGetContainersRequest) Is3D(is3D bool) ApiGetContainersRequest {
	r.is3D = &is3D
	return r
}

// Optional filter by Series Status. Allows multiple, comma delimeted.
func (r ApiGetContainersRequest) SeriesStatus(seriesStatus string) ApiGetContainersRequest {
	r.seriesStatus = &seriesStatus
	return r
}

// Optional filter by items whose name is sorted equally or greater than a given input string.
func (r ApiGetContainersRequest) NameStartsWithOrGreater(nameStartsWithOrGreater string) ApiGetContainersRequest {
	r.nameStartsWithOrGreater = &nameStartsWithOrGreater
	return r
}

// Optional filter by items whose name is sorted equally than a given input string.
func (r ApiGetContainersRequest) NameStartsWith(nameStartsWith string) ApiGetContainersRequest {
	r.nameStartsWith = &nameStartsWith
	return r
}

// Optional filter by items whose name is equally or lesser than a given input string.
func (r ApiGetContainersRequest) NameLessThan(nameLessThan string) ApiGetContainersRequest {
	r.nameLessThan = &nameLessThan
	return r
}

func (r ApiGetContainersRequest) Execute() (*QueryResultUserLibraryTagItem, *http.Response, error) {
	return r.ApiService.GetContainersExecute(r)
}

/*
GetContainers Gets items based on a query.

No authentication required

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetContainersRequest
*/
func (a *TagServiceAPIService) GetContainers(ctx context.Context) ApiGetContainersRequest {
	return ApiGetContainersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return QueryResultUserLibraryTagItem
func (a *TagServiceAPIService) GetContainersExecute(r ApiGetContainersRequest) (*QueryResultUserLibraryTagItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QueryResultUserLibraryTagItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TagServiceAPIService.GetContainers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Containers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.artistType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ArtistType", r.artistType, "form", "")
	}
	if r.maxOfficialRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxOfficialRating", r.maxOfficialRating, "form", "")
	}
	if r.hasThemeSong != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasThemeSong", r.hasThemeSong, "form", "")
	}
	if r.hasThemeVideo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasThemeVideo", r.hasThemeVideo, "form", "")
	}
	if r.hasSubtitles != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasSubtitles", r.hasSubtitles, "form", "")
	}
	if r.hasSpecialFeature != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasSpecialFeature", r.hasSpecialFeature, "form", "")
	}
	if r.hasTrailer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasTrailer", r.hasTrailer, "form", "")
	}
	if r.adjacentTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AdjacentTo", r.adjacentTo, "form", "")
	}
	if r.minIndexNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinIndexNumber", r.minIndexNumber, "form", "")
	}
	if r.minPlayers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinPlayers", r.minPlayers, "form", "")
	}
	if r.maxPlayers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxPlayers", r.maxPlayers, "form", "")
	}
	if r.parentIndexNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ParentIndexNumber", r.parentIndexNumber, "form", "")
	}
	if r.hasParentalRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasParentalRating", r.hasParentalRating, "form", "")
	}
	if r.isHD != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsHD", r.isHD, "form", "")
	}
	if r.locationTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "LocationTypes", r.locationTypes, "form", "")
	}
	if r.excludeLocationTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ExcludeLocationTypes", r.excludeLocationTypes, "form", "")
	}
	if r.isMissing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsMissing", r.isMissing, "form", "")
	}
	if r.isUnaired != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsUnaired", r.isUnaired, "form", "")
	}
	if r.minCommunityRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinCommunityRating", r.minCommunityRating, "form", "")
	}
	if r.minCriticRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinCriticRating", r.minCriticRating, "form", "")
	}
	if r.airedDuringSeason != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AiredDuringSeason", r.airedDuringSeason, "form", "")
	}
	if r.minPremiereDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinPremiereDate", r.minPremiereDate, "form", "")
	}
	if r.minDateLastSaved != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinDateLastSaved", r.minDateLastSaved, "form", "")
	}
	if r.minDateLastSavedForUser != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinDateLastSavedForUser", r.minDateLastSavedForUser, "form", "")
	}
	if r.maxPremiereDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxPremiereDate", r.maxPremiereDate, "form", "")
	}
	if r.hasOverview != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasOverview", r.hasOverview, "form", "")
	}
	if r.hasImdbId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasImdbId", r.hasImdbId, "form", "")
	}
	if r.hasTmdbId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasTmdbId", r.hasTmdbId, "form", "")
	}
	if r.hasTvdbId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasTvdbId", r.hasTvdbId, "form", "")
	}
	if r.excludeItemIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ExcludeItemIds", r.excludeItemIds, "form", "")
	}
	if r.startIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "StartIndex", r.startIndex, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Limit", r.limit, "form", "")
	}
	if r.recursive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Recursive", r.recursive, "form", "")
	}
	if r.sortOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SortOrder", r.sortOrder, "form", "")
	}
	if r.parentId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ParentId", r.parentId, "form", "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Fields", r.fields, "form", "")
	}
	if r.excludeItemTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ExcludeItemTypes", r.excludeItemTypes, "form", "")
	}
	if r.includeItemTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IncludeItemTypes", r.includeItemTypes, "form", "")
	}
	if r.anyProviderIdEquals != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AnyProviderIdEquals", r.anyProviderIdEquals, "form", "")
	}
	if r.filters != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Filters", r.filters, "form", "")
	}
	if r.isFavorite != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsFavorite", r.isFavorite, "form", "")
	}
	if r.isMovie != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsMovie", r.isMovie, "form", "")
	}
	if r.isSeries != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsSeries", r.isSeries, "form", "")
	}
	if r.isNews != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsNews", r.isNews, "form", "")
	}
	if r.isKids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsKids", r.isKids, "form", "")
	}
	if r.isSports != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsSports", r.isSports, "form", "")
	}
	if r.mediaTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MediaTypes", r.mediaTypes, "form", "")
	}
	if r.imageTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ImageTypes", r.imageTypes, "form", "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SortBy", r.sortBy, "form", "")
	}
	if r.isPlayed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsPlayed", r.isPlayed, "form", "")
	}
	if r.genres != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Genres", r.genres, "form", "")
	}
	if r.officialRatings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "OfficialRatings", r.officialRatings, "form", "")
	}
	if r.tags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Tags", r.tags, "form", "")
	}
	if r.years != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Years", r.years, "form", "")
	}
	if r.enableImages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImages", r.enableImages, "form", "")
	}
	if r.enableUserData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableUserData", r.enableUserData, "form", "")
	}
	if r.imageTypeLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ImageTypeLimit", r.imageTypeLimit, "form", "")
	}
	if r.enableImageTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImageTypes", r.enableImageTypes, "form", "")
	}
	if r.person != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Person", r.person, "form", "")
	}
	if r.personIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "PersonIds", r.personIds, "form", "")
	}
	if r.personTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "PersonTypes", r.personTypes, "form", "")
	}
	if r.studios != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Studios", r.studios, "form", "")
	}
	if r.studioIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "StudioIds", r.studioIds, "form", "")
	}
	if r.artists != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Artists", r.artists, "form", "")
	}
	if r.artistIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ArtistIds", r.artistIds, "form", "")
	}
	if r.albums != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Albums", r.albums, "form", "")
	}
	if r.ids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Ids", r.ids, "form", "")
	}
	if r.videoTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "VideoTypes", r.videoTypes, "form", "")
	}
	if r.containers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Containers", r.containers, "form", "")
	}
	if r.audioCodecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AudioCodecs", r.audioCodecs, "form", "")
	}
	if r.videoCodecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "VideoCodecs", r.videoCodecs, "form", "")
	}
	if r.subtitleCodecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SubtitleCodecs", r.subtitleCodecs, "form", "")
	}
	if r.path != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Path", r.path, "form", "")
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "UserId", r.userId, "form", "")
	}
	if r.minOfficialRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinOfficialRating", r.minOfficialRating, "form", "")
	}
	if r.isLocked != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsLocked", r.isLocked, "form", "")
	}
	if r.isPlaceHolder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsPlaceHolder", r.isPlaceHolder, "form", "")
	}
	if r.hasOfficialRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasOfficialRating", r.hasOfficialRating, "form", "")
	}
	if r.groupItemsIntoCollections != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "GroupItemsIntoCollections", r.groupItemsIntoCollections, "form", "")
	}
	if r.is3D != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Is3D", r.is3D, "form", "")
	}
	if r.seriesStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SeriesStatus", r.seriesStatus, "form", "")
	}
	if r.nameStartsWithOrGreater != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "NameStartsWithOrGreater", r.nameStartsWithOrGreater, "form", "")
	}
	if r.nameStartsWith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "NameStartsWith", r.nameStartsWith, "form", "")
	}
	if r.nameLessThan != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "NameLessThan", r.nameLessThan, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetItemsPrefixesRequest struct {
	ctx context.Context
	ApiService TagServiceAPI
	artistType *string
	maxOfficialRating *string
	hasThemeSong *bool
	hasThemeVideo *bool
	hasSubtitles *bool
	hasSpecialFeature *bool
	hasTrailer *bool
	adjacentTo *string
	minIndexNumber *int32
	minPlayers *int32
	maxPlayers *int32
	parentIndexNumber *int32
	hasParentalRating *bool
	isHD *bool
	locationTypes *string
	excludeLocationTypes *string
	isMissing *bool
	isUnaired *bool
	minCommunityRating *float64
	minCriticRating *float64
	airedDuringSeason *int32
	minPremiereDate *string
	minDateLastSaved *string
	minDateLastSavedForUser *string
	maxPremiereDate *string
	hasOverview *bool
	hasImdbId *bool
	hasTmdbId *bool
	hasTvdbId *bool
	excludeItemIds *string
	startIndex *int32
	limit *int32
	recursive *bool
	sortOrder *string
	parentId *string
	fields *string
	excludeItemTypes *string
	includeItemTypes *string
	anyProviderIdEquals *string
	filters *string
	isFavorite *bool
	isMovie *bool
	isSeries *bool
	isNews *bool
	isKids *bool
	isSports *bool
	mediaTypes *string
	imageTypes *string
	sortBy *string
	isPlayed *bool
	genres *string
	officialRatings *string
	tags *string
	years *string
	enableImages *bool
	enableUserData *bool
	imageTypeLimit *int32
	enableImageTypes *string
	person *string
	personIds *string
	personTypes *string
	studios *string
	studioIds *string
	artists *string
	artistIds *string
	albums *string
	ids *string
	videoTypes *string
	containers *string
	audioCodecs *string
	videoCodecs *string
	subtitleCodecs *string
	path *string
	userId *string
	minOfficialRating *string
	isLocked *bool
	isPlaceHolder *bool
	hasOfficialRating *bool
	groupItemsIntoCollections *bool
	is3D *bool
	seriesStatus *string
	nameStartsWithOrGreater *string
	nameStartsWith *string
	nameLessThan *string
}

// Artist or AlbumArtist
func (r ApiGetItemsPrefixesRequest) ArtistType(artistType string) ApiGetItemsPrefixesRequest {
	r.artistType = &artistType
	return r
}

// Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
func (r ApiGetItemsPrefixesRequest) MaxOfficialRating(maxOfficialRating string) ApiGetItemsPrefixesRequest {
	r.maxOfficialRating = &maxOfficialRating
	return r
}

// Optional filter by items with theme songs.
func (r ApiGetItemsPrefixesRequest) HasThemeSong(hasThemeSong bool) ApiGetItemsPrefixesRequest {
	r.hasThemeSong = &hasThemeSong
	return r
}

// Optional filter by items with theme videos.
func (r ApiGetItemsPrefixesRequest) HasThemeVideo(hasThemeVideo bool) ApiGetItemsPrefixesRequest {
	r.hasThemeVideo = &hasThemeVideo
	return r
}

// Optional filter by items with subtitles.
func (r ApiGetItemsPrefixesRequest) HasSubtitles(hasSubtitles bool) ApiGetItemsPrefixesRequest {
	r.hasSubtitles = &hasSubtitles
	return r
}

// Optional filter by items with special features.
func (r ApiGetItemsPrefixesRequest) HasSpecialFeature(hasSpecialFeature bool) ApiGetItemsPrefixesRequest {
	r.hasSpecialFeature = &hasSpecialFeature
	return r
}

// Optional filter by items with trailers.
func (r ApiGetItemsPrefixesRequest) HasTrailer(hasTrailer bool) ApiGetItemsPrefixesRequest {
	r.hasTrailer = &hasTrailer
	return r
}

// Optional. Return items that are siblings of a supplied item.
func (r ApiGetItemsPrefixesRequest) AdjacentTo(adjacentTo string) ApiGetItemsPrefixesRequest {
	r.adjacentTo = &adjacentTo
	return r
}

// Optional filter by minimum index number.
func (r ApiGetItemsPrefixesRequest) MinIndexNumber(minIndexNumber int32) ApiGetItemsPrefixesRequest {
	r.minIndexNumber = &minIndexNumber
	return r
}

// Optional filter by minimum number of game players.
func (r ApiGetItemsPrefixesRequest) MinPlayers(minPlayers int32) ApiGetItemsPrefixesRequest {
	r.minPlayers = &minPlayers
	return r
}

// Optional filter by maximum number of game players.
func (r ApiGetItemsPrefixesRequest) MaxPlayers(maxPlayers int32) ApiGetItemsPrefixesRequest {
	r.maxPlayers = &maxPlayers
	return r
}

// Optional filter by parent index number.
func (r ApiGetItemsPrefixesRequest) ParentIndexNumber(parentIndexNumber int32) ApiGetItemsPrefixesRequest {
	r.parentIndexNumber = &parentIndexNumber
	return r
}

// Optional filter by items that have or do not have a parental rating
func (r ApiGetItemsPrefixesRequest) HasParentalRating(hasParentalRating bool) ApiGetItemsPrefixesRequest {
	r.hasParentalRating = &hasParentalRating
	return r
}

// Optional filter by items that are HD or not.
func (r ApiGetItemsPrefixesRequest) IsHD(isHD bool) ApiGetItemsPrefixesRequest {
	r.isHD = &isHD
	return r
}

// Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
func (r ApiGetItemsPrefixesRequest) LocationTypes(locationTypes string) ApiGetItemsPrefixesRequest {
	r.locationTypes = &locationTypes
	return r
}

// Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
func (r ApiGetItemsPrefixesRequest) ExcludeLocationTypes(excludeLocationTypes string) ApiGetItemsPrefixesRequest {
	r.excludeLocationTypes = &excludeLocationTypes
	return r
}

// Optional filter by items that are missing episodes or not.
func (r ApiGetItemsPrefixesRequest) IsMissing(isMissing bool) ApiGetItemsPrefixesRequest {
	r.isMissing = &isMissing
	return r
}

// Optional filter by items that are unaired episodes or not.
func (r ApiGetItemsPrefixesRequest) IsUnaired(isUnaired bool) ApiGetItemsPrefixesRequest {
	r.isUnaired = &isUnaired
	return r
}

// Optional filter by minimum community rating.
func (r ApiGetItemsPrefixesRequest) MinCommunityRating(minCommunityRating float64) ApiGetItemsPrefixesRequest {
	r.minCommunityRating = &minCommunityRating
	return r
}

// Optional filter by minimum critic rating.
func (r ApiGetItemsPrefixesRequest) MinCriticRating(minCriticRating float64) ApiGetItemsPrefixesRequest {
	r.minCriticRating = &minCriticRating
	return r
}

// Gets all episodes that aired during a season, including specials.
func (r ApiGetItemsPrefixesRequest) AiredDuringSeason(airedDuringSeason int32) ApiGetItemsPrefixesRequest {
	r.airedDuringSeason = &airedDuringSeason
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r ApiGetItemsPrefixesRequest) MinPremiereDate(minPremiereDate string) ApiGetItemsPrefixesRequest {
	r.minPremiereDate = &minPremiereDate
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r ApiGetItemsPrefixesRequest) MinDateLastSaved(minDateLastSaved string) ApiGetItemsPrefixesRequest {
	r.minDateLastSaved = &minDateLastSaved
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r ApiGetItemsPrefixesRequest) MinDateLastSavedForUser(minDateLastSavedForUser string) ApiGetItemsPrefixesRequest {
	r.minDateLastSavedForUser = &minDateLastSavedForUser
	return r
}

// Optional. The maximum premiere date. Format &#x3D; ISO
func (r ApiGetItemsPrefixesRequest) MaxPremiereDate(maxPremiereDate string) ApiGetItemsPrefixesRequest {
	r.maxPremiereDate = &maxPremiereDate
	return r
}

// Optional filter by items that have an overview or not.
func (r ApiGetItemsPrefixesRequest) HasOverview(hasOverview bool) ApiGetItemsPrefixesRequest {
	r.hasOverview = &hasOverview
	return r
}

// Optional filter by items that have an imdb id or not.
func (r ApiGetItemsPrefixesRequest) HasImdbId(hasImdbId bool) ApiGetItemsPrefixesRequest {
	r.hasImdbId = &hasImdbId
	return r
}

// Optional filter by items that have a tmdb id or not.
func (r ApiGetItemsPrefixesRequest) HasTmdbId(hasTmdbId bool) ApiGetItemsPrefixesRequest {
	r.hasTmdbId = &hasTmdbId
	return r
}

// Optional filter by items that have a tvdb id or not.
func (r ApiGetItemsPrefixesRequest) HasTvdbId(hasTvdbId bool) ApiGetItemsPrefixesRequest {
	r.hasTvdbId = &hasTvdbId
	return r
}

// Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
func (r ApiGetItemsPrefixesRequest) ExcludeItemIds(excludeItemIds string) ApiGetItemsPrefixesRequest {
	r.excludeItemIds = &excludeItemIds
	return r
}

// Optional. The record index to start at. All items with a lower index will be dropped from the results.
func (r ApiGetItemsPrefixesRequest) StartIndex(startIndex int32) ApiGetItemsPrefixesRequest {
	r.startIndex = &startIndex
	return r
}

// Optional. The maximum number of records to return
func (r ApiGetItemsPrefixesRequest) Limit(limit int32) ApiGetItemsPrefixesRequest {
	r.limit = &limit
	return r
}

// When searching within folders, this determines whether or not the search will be recursive. true/false
func (r ApiGetItemsPrefixesRequest) Recursive(recursive bool) ApiGetItemsPrefixesRequest {
	r.recursive = &recursive
	return r
}

// Sort Order - Ascending,Descending
func (r ApiGetItemsPrefixesRequest) SortOrder(sortOrder string) ApiGetItemsPrefixesRequest {
	r.sortOrder = &sortOrder
	return r
}

// Specify this to localize the search to a specific item or folder. Omit to use the root
func (r ApiGetItemsPrefixesRequest) ParentId(parentId string) ApiGetItemsPrefixesRequest {
	r.parentId = &parentId
	return r
}

// Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
func (r ApiGetItemsPrefixesRequest) Fields(fields string) ApiGetItemsPrefixesRequest {
	r.fields = &fields
	return r
}

// Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
func (r ApiGetItemsPrefixesRequest) ExcludeItemTypes(excludeItemTypes string) ApiGetItemsPrefixesRequest {
	r.excludeItemTypes = &excludeItemTypes
	return r
}

// Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
func (r ApiGetItemsPrefixesRequest) IncludeItemTypes(includeItemTypes string) ApiGetItemsPrefixesRequest {
	r.includeItemTypes = &includeItemTypes
	return r
}

// Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form &#39;prov.id&#39;, e.g. &#39;imdb.tt123456&#39;. This allows multiple, comma delimeted value pairs.
func (r ApiGetItemsPrefixesRequest) AnyProviderIdEquals(anyProviderIdEquals string) ApiGetItemsPrefixesRequest {
	r.anyProviderIdEquals = &anyProviderIdEquals
	return r
}

// Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
func (r ApiGetItemsPrefixesRequest) Filters(filters string) ApiGetItemsPrefixesRequest {
	r.filters = &filters
	return r
}

// Optional filter by items that are marked as favorite, or not.
func (r ApiGetItemsPrefixesRequest) IsFavorite(isFavorite bool) ApiGetItemsPrefixesRequest {
	r.isFavorite = &isFavorite
	return r
}

// Optional filter for movies.
func (r ApiGetItemsPrefixesRequest) IsMovie(isMovie bool) ApiGetItemsPrefixesRequest {
	r.isMovie = &isMovie
	return r
}

// Optional filter for movies.
func (r ApiGetItemsPrefixesRequest) IsSeries(isSeries bool) ApiGetItemsPrefixesRequest {
	r.isSeries = &isSeries
	return r
}

// Optional filter for news.
func (r ApiGetItemsPrefixesRequest) IsNews(isNews bool) ApiGetItemsPrefixesRequest {
	r.isNews = &isNews
	return r
}

// Optional filter for kids.
func (r ApiGetItemsPrefixesRequest) IsKids(isKids bool) ApiGetItemsPrefixesRequest {
	r.isKids = &isKids
	return r
}

// Optional filter for sports.
func (r ApiGetItemsPrefixesRequest) IsSports(isSports bool) ApiGetItemsPrefixesRequest {
	r.isSports = &isSports
	return r
}

// Optional filter by MediaType. Allows multiple, comma delimited.
func (r ApiGetItemsPrefixesRequest) MediaTypes(mediaTypes string) ApiGetItemsPrefixesRequest {
	r.mediaTypes = &mediaTypes
	return r
}

// Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
func (r ApiGetItemsPrefixesRequest) ImageTypes(imageTypes string) ApiGetItemsPrefixesRequest {
	r.imageTypes = &imageTypes
	return r
}

// Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
func (r ApiGetItemsPrefixesRequest) SortBy(sortBy string) ApiGetItemsPrefixesRequest {
	r.sortBy = &sortBy
	return r
}

// Optional filter by items that are played, or not.
func (r ApiGetItemsPrefixesRequest) IsPlayed(isPlayed bool) ApiGetItemsPrefixesRequest {
	r.isPlayed = &isPlayed
	return r
}

// Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
func (r ApiGetItemsPrefixesRequest) Genres(genres string) ApiGetItemsPrefixesRequest {
	r.genres = &genres
	return r
}

// Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
func (r ApiGetItemsPrefixesRequest) OfficialRatings(officialRatings string) ApiGetItemsPrefixesRequest {
	r.officialRatings = &officialRatings
	return r
}

// Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
func (r ApiGetItemsPrefixesRequest) Tags(tags string) ApiGetItemsPrefixesRequest {
	r.tags = &tags
	return r
}

// Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
func (r ApiGetItemsPrefixesRequest) Years(years string) ApiGetItemsPrefixesRequest {
	r.years = &years
	return r
}

// Optional, include image information in output
func (r ApiGetItemsPrefixesRequest) EnableImages(enableImages bool) ApiGetItemsPrefixesRequest {
	r.enableImages = &enableImages
	return r
}

// Optional, include user data
func (r ApiGetItemsPrefixesRequest) EnableUserData(enableUserData bool) ApiGetItemsPrefixesRequest {
	r.enableUserData = &enableUserData
	return r
}

// Optional, the max number of images to return, per image type
func (r ApiGetItemsPrefixesRequest) ImageTypeLimit(imageTypeLimit int32) ApiGetItemsPrefixesRequest {
	r.imageTypeLimit = &imageTypeLimit
	return r
}

// Optional. The image types to include in the output.
func (r ApiGetItemsPrefixesRequest) EnableImageTypes(enableImageTypes string) ApiGetItemsPrefixesRequest {
	r.enableImageTypes = &enableImageTypes
	return r
}

// Optional. If specified, results will be filtered to include only those containing the specified person.
func (r ApiGetItemsPrefixesRequest) Person(person string) ApiGetItemsPrefixesRequest {
	r.person = &person
	return r
}

// Optional. If specified, results will be filtered to include only those containing the specified person.
func (r ApiGetItemsPrefixesRequest) PersonIds(personIds string) ApiGetItemsPrefixesRequest {
	r.personIds = &personIds
	return r
}

// Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
func (r ApiGetItemsPrefixesRequest) PersonTypes(personTypes string) ApiGetItemsPrefixesRequest {
	r.personTypes = &personTypes
	return r
}

// Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
func (r ApiGetItemsPrefixesRequest) Studios(studios string) ApiGetItemsPrefixesRequest {
	r.studios = &studios
	return r
}

// Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
func (r ApiGetItemsPrefixesRequest) StudioIds(studioIds string) ApiGetItemsPrefixesRequest {
	r.studioIds = &studioIds
	return r
}

// Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
func (r ApiGetItemsPrefixesRequest) Artists(artists string) ApiGetItemsPrefixesRequest {
	r.artists = &artists
	return r
}

// Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
func (r ApiGetItemsPrefixesRequest) ArtistIds(artistIds string) ApiGetItemsPrefixesRequest {
	r.artistIds = &artistIds
	return r
}

// Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
func (r ApiGetItemsPrefixesRequest) Albums(albums string) ApiGetItemsPrefixesRequest {
	r.albums = &albums
	return r
}

// Optional. If specific items are needed, specify a list of item id&#39;s to retrieve. This allows multiple, comma delimited.
func (r ApiGetItemsPrefixesRequest) Ids(ids string) ApiGetItemsPrefixesRequest {
	r.ids = &ids
	return r
}

// Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
func (r ApiGetItemsPrefixesRequest) VideoTypes(videoTypes string) ApiGetItemsPrefixesRequest {
	r.videoTypes = &videoTypes
	return r
}

// Optional filter by Container. Allows multiple, comma delimeted.
func (r ApiGetItemsPrefixesRequest) Containers(containers string) ApiGetItemsPrefixesRequest {
	r.containers = &containers
	return r
}

// Optional filter by AudioCodec. Allows multiple, comma delimeted.
func (r ApiGetItemsPrefixesRequest) AudioCodecs(audioCodecs string) ApiGetItemsPrefixesRequest {
	r.audioCodecs = &audioCodecs
	return r
}

// Optional filter by VideoCodec. Allows multiple, comma delimeted.
func (r ApiGetItemsPrefixesRequest) VideoCodecs(videoCodecs string) ApiGetItemsPrefixesRequest {
	r.videoCodecs = &videoCodecs
	return r
}

// Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
func (r ApiGetItemsPrefixesRequest) SubtitleCodecs(subtitleCodecs string) ApiGetItemsPrefixesRequest {
	r.subtitleCodecs = &subtitleCodecs
	return r
}

// Optional filter by Path.
func (r ApiGetItemsPrefixesRequest) Path(path string) ApiGetItemsPrefixesRequest {
	r.path = &path
	return r
}

// User Id
func (r ApiGetItemsPrefixesRequest) UserId(userId string) ApiGetItemsPrefixesRequest {
	r.userId = &userId
	return r
}

// Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
func (r ApiGetItemsPrefixesRequest) MinOfficialRating(minOfficialRating string) ApiGetItemsPrefixesRequest {
	r.minOfficialRating = &minOfficialRating
	return r
}

// Optional filter by items that are locked.
func (r ApiGetItemsPrefixesRequest) IsLocked(isLocked bool) ApiGetItemsPrefixesRequest {
	r.isLocked = &isLocked
	return r
}

// Optional filter by items that are placeholders
func (r ApiGetItemsPrefixesRequest) IsPlaceHolder(isPlaceHolder bool) ApiGetItemsPrefixesRequest {
	r.isPlaceHolder = &isPlaceHolder
	return r
}

// Optional filter by items that have official ratings
func (r ApiGetItemsPrefixesRequest) HasOfficialRating(hasOfficialRating bool) ApiGetItemsPrefixesRequest {
	r.hasOfficialRating = &hasOfficialRating
	return r
}

// Whether or not to hide items behind their boxsets.
func (r ApiGetItemsPrefixesRequest) GroupItemsIntoCollections(groupItemsIntoCollections bool) ApiGetItemsPrefixesRequest {
	r.groupItemsIntoCollections = &groupItemsIntoCollections
	return r
}

// Optional filter by items that are 3D, or not.
func (r ApiGetItemsPrefixesRequest) Is3D(is3D bool) ApiGetItemsPrefixesRequest {
	r.is3D = &is3D
	return r
}

// Optional filter by Series Status. Allows multiple, comma delimeted.
func (r ApiGetItemsPrefixesRequest) SeriesStatus(seriesStatus string) ApiGetItemsPrefixesRequest {
	r.seriesStatus = &seriesStatus
	return r
}

// Optional filter by items whose name is sorted equally or greater than a given input string.
func (r ApiGetItemsPrefixesRequest) NameStartsWithOrGreater(nameStartsWithOrGreater string) ApiGetItemsPrefixesRequest {
	r.nameStartsWithOrGreater = &nameStartsWithOrGreater
	return r
}

// Optional filter by items whose name is sorted equally than a given input string.
func (r ApiGetItemsPrefixesRequest) NameStartsWith(nameStartsWith string) ApiGetItemsPrefixesRequest {
	r.nameStartsWith = &nameStartsWith
	return r
}

// Optional filter by items whose name is equally or lesser than a given input string.
func (r ApiGetItemsPrefixesRequest) NameLessThan(nameLessThan string) ApiGetItemsPrefixesRequest {
	r.nameLessThan = &nameLessThan
	return r
}

func (r ApiGetItemsPrefixesRequest) Execute() ([]NameValuePair, *http.Response, error) {
	return r.ApiService.GetItemsPrefixesExecute(r)
}

/*
GetItemsPrefixes Gets items based on a query.

No authentication required

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetItemsPrefixesRequest
*/
func (a *TagServiceAPIService) GetItemsPrefixes(ctx context.Context) ApiGetItemsPrefixesRequest {
	return ApiGetItemsPrefixesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []NameValuePair
func (a *TagServiceAPIService) GetItemsPrefixesExecute(r ApiGetItemsPrefixesRequest) ([]NameValuePair, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []NameValuePair
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TagServiceAPIService.GetItemsPrefixes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Items/Prefixes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.artistType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ArtistType", r.artistType, "form", "")
	}
	if r.maxOfficialRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxOfficialRating", r.maxOfficialRating, "form", "")
	}
	if r.hasThemeSong != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasThemeSong", r.hasThemeSong, "form", "")
	}
	if r.hasThemeVideo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasThemeVideo", r.hasThemeVideo, "form", "")
	}
	if r.hasSubtitles != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasSubtitles", r.hasSubtitles, "form", "")
	}
	if r.hasSpecialFeature != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasSpecialFeature", r.hasSpecialFeature, "form", "")
	}
	if r.hasTrailer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasTrailer", r.hasTrailer, "form", "")
	}
	if r.adjacentTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AdjacentTo", r.adjacentTo, "form", "")
	}
	if r.minIndexNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinIndexNumber", r.minIndexNumber, "form", "")
	}
	if r.minPlayers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinPlayers", r.minPlayers, "form", "")
	}
	if r.maxPlayers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxPlayers", r.maxPlayers, "form", "")
	}
	if r.parentIndexNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ParentIndexNumber", r.parentIndexNumber, "form", "")
	}
	if r.hasParentalRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasParentalRating", r.hasParentalRating, "form", "")
	}
	if r.isHD != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsHD", r.isHD, "form", "")
	}
	if r.locationTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "LocationTypes", r.locationTypes, "form", "")
	}
	if r.excludeLocationTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ExcludeLocationTypes", r.excludeLocationTypes, "form", "")
	}
	if r.isMissing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsMissing", r.isMissing, "form", "")
	}
	if r.isUnaired != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsUnaired", r.isUnaired, "form", "")
	}
	if r.minCommunityRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinCommunityRating", r.minCommunityRating, "form", "")
	}
	if r.minCriticRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinCriticRating", r.minCriticRating, "form", "")
	}
	if r.airedDuringSeason != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AiredDuringSeason", r.airedDuringSeason, "form", "")
	}
	if r.minPremiereDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinPremiereDate", r.minPremiereDate, "form", "")
	}
	if r.minDateLastSaved != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinDateLastSaved", r.minDateLastSaved, "form", "")
	}
	if r.minDateLastSavedForUser != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinDateLastSavedForUser", r.minDateLastSavedForUser, "form", "")
	}
	if r.maxPremiereDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxPremiereDate", r.maxPremiereDate, "form", "")
	}
	if r.hasOverview != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasOverview", r.hasOverview, "form", "")
	}
	if r.hasImdbId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasImdbId", r.hasImdbId, "form", "")
	}
	if r.hasTmdbId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasTmdbId", r.hasTmdbId, "form", "")
	}
	if r.hasTvdbId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasTvdbId", r.hasTvdbId, "form", "")
	}
	if r.excludeItemIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ExcludeItemIds", r.excludeItemIds, "form", "")
	}
	if r.startIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "StartIndex", r.startIndex, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Limit", r.limit, "form", "")
	}
	if r.recursive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Recursive", r.recursive, "form", "")
	}
	if r.sortOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SortOrder", r.sortOrder, "form", "")
	}
	if r.parentId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ParentId", r.parentId, "form", "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Fields", r.fields, "form", "")
	}
	if r.excludeItemTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ExcludeItemTypes", r.excludeItemTypes, "form", "")
	}
	if r.includeItemTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IncludeItemTypes", r.includeItemTypes, "form", "")
	}
	if r.anyProviderIdEquals != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AnyProviderIdEquals", r.anyProviderIdEquals, "form", "")
	}
	if r.filters != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Filters", r.filters, "form", "")
	}
	if r.isFavorite != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsFavorite", r.isFavorite, "form", "")
	}
	if r.isMovie != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsMovie", r.isMovie, "form", "")
	}
	if r.isSeries != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsSeries", r.isSeries, "form", "")
	}
	if r.isNews != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsNews", r.isNews, "form", "")
	}
	if r.isKids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsKids", r.isKids, "form", "")
	}
	if r.isSports != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsSports", r.isSports, "form", "")
	}
	if r.mediaTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MediaTypes", r.mediaTypes, "form", "")
	}
	if r.imageTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ImageTypes", r.imageTypes, "form", "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SortBy", r.sortBy, "form", "")
	}
	if r.isPlayed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsPlayed", r.isPlayed, "form", "")
	}
	if r.genres != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Genres", r.genres, "form", "")
	}
	if r.officialRatings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "OfficialRatings", r.officialRatings, "form", "")
	}
	if r.tags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Tags", r.tags, "form", "")
	}
	if r.years != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Years", r.years, "form", "")
	}
	if r.enableImages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImages", r.enableImages, "form", "")
	}
	if r.enableUserData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableUserData", r.enableUserData, "form", "")
	}
	if r.imageTypeLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ImageTypeLimit", r.imageTypeLimit, "form", "")
	}
	if r.enableImageTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImageTypes", r.enableImageTypes, "form", "")
	}
	if r.person != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Person", r.person, "form", "")
	}
	if r.personIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "PersonIds", r.personIds, "form", "")
	}
	if r.personTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "PersonTypes", r.personTypes, "form", "")
	}
	if r.studios != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Studios", r.studios, "form", "")
	}
	if r.studioIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "StudioIds", r.studioIds, "form", "")
	}
	if r.artists != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Artists", r.artists, "form", "")
	}
	if r.artistIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ArtistIds", r.artistIds, "form", "")
	}
	if r.albums != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Albums", r.albums, "form", "")
	}
	if r.ids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Ids", r.ids, "form", "")
	}
	if r.videoTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "VideoTypes", r.videoTypes, "form", "")
	}
	if r.containers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Containers", r.containers, "form", "")
	}
	if r.audioCodecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AudioCodecs", r.audioCodecs, "form", "")
	}
	if r.videoCodecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "VideoCodecs", r.videoCodecs, "form", "")
	}
	if r.subtitleCodecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SubtitleCodecs", r.subtitleCodecs, "form", "")
	}
	if r.path != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Path", r.path, "form", "")
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "UserId", r.userId, "form", "")
	}
	if r.minOfficialRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinOfficialRating", r.minOfficialRating, "form", "")
	}
	if r.isLocked != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsLocked", r.isLocked, "form", "")
	}
	if r.isPlaceHolder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsPlaceHolder", r.isPlaceHolder, "form", "")
	}
	if r.hasOfficialRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasOfficialRating", r.hasOfficialRating, "form", "")
	}
	if r.groupItemsIntoCollections != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "GroupItemsIntoCollections", r.groupItemsIntoCollections, "form", "")
	}
	if r.is3D != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Is3D", r.is3D, "form", "")
	}
	if r.seriesStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SeriesStatus", r.seriesStatus, "form", "")
	}
	if r.nameStartsWithOrGreater != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "NameStartsWithOrGreater", r.nameStartsWithOrGreater, "form", "")
	}
	if r.nameStartsWith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "NameStartsWith", r.nameStartsWith, "form", "")
	}
	if r.nameLessThan != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "NameLessThan", r.nameLessThan, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSubtitlecodecsRequest struct {
	ctx context.Context
	ApiService TagServiceAPI
	artistType *string
	maxOfficialRating *string
	hasThemeSong *bool
	hasThemeVideo *bool
	hasSubtitles *bool
	hasSpecialFeature *bool
	hasTrailer *bool
	adjacentTo *string
	minIndexNumber *int32
	minPlayers *int32
	maxPlayers *int32
	parentIndexNumber *int32
	hasParentalRating *bool
	isHD *bool
	locationTypes *string
	excludeLocationTypes *string
	isMissing *bool
	isUnaired *bool
	minCommunityRating *float64
	minCriticRating *float64
	airedDuringSeason *int32
	minPremiereDate *string
	minDateLastSaved *string
	minDateLastSavedForUser *string
	maxPremiereDate *string
	hasOverview *bool
	hasImdbId *bool
	hasTmdbId *bool
	hasTvdbId *bool
	excludeItemIds *string
	startIndex *int32
	limit *int32
	recursive *bool
	sortOrder *string
	parentId *string
	fields *string
	excludeItemTypes *string
	includeItemTypes *string
	anyProviderIdEquals *string
	filters *string
	isFavorite *bool
	isMovie *bool
	isSeries *bool
	isNews *bool
	isKids *bool
	isSports *bool
	mediaTypes *string
	imageTypes *string
	sortBy *string
	isPlayed *bool
	genres *string
	officialRatings *string
	tags *string
	years *string
	enableImages *bool
	enableUserData *bool
	imageTypeLimit *int32
	enableImageTypes *string
	person *string
	personIds *string
	personTypes *string
	studios *string
	studioIds *string
	artists *string
	artistIds *string
	albums *string
	ids *string
	videoTypes *string
	containers *string
	audioCodecs *string
	videoCodecs *string
	subtitleCodecs *string
	path *string
	userId *string
	minOfficialRating *string
	isLocked *bool
	isPlaceHolder *bool
	hasOfficialRating *bool
	groupItemsIntoCollections *bool
	is3D *bool
	seriesStatus *string
	nameStartsWithOrGreater *string
	nameStartsWith *string
	nameLessThan *string
}

// Artist or AlbumArtist
func (r ApiGetSubtitlecodecsRequest) ArtistType(artistType string) ApiGetSubtitlecodecsRequest {
	r.artistType = &artistType
	return r
}

// Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
func (r ApiGetSubtitlecodecsRequest) MaxOfficialRating(maxOfficialRating string) ApiGetSubtitlecodecsRequest {
	r.maxOfficialRating = &maxOfficialRating
	return r
}

// Optional filter by items with theme songs.
func (r ApiGetSubtitlecodecsRequest) HasThemeSong(hasThemeSong bool) ApiGetSubtitlecodecsRequest {
	r.hasThemeSong = &hasThemeSong
	return r
}

// Optional filter by items with theme videos.
func (r ApiGetSubtitlecodecsRequest) HasThemeVideo(hasThemeVideo bool) ApiGetSubtitlecodecsRequest {
	r.hasThemeVideo = &hasThemeVideo
	return r
}

// Optional filter by items with subtitles.
func (r ApiGetSubtitlecodecsRequest) HasSubtitles(hasSubtitles bool) ApiGetSubtitlecodecsRequest {
	r.hasSubtitles = &hasSubtitles
	return r
}

// Optional filter by items with special features.
func (r ApiGetSubtitlecodecsRequest) HasSpecialFeature(hasSpecialFeature bool) ApiGetSubtitlecodecsRequest {
	r.hasSpecialFeature = &hasSpecialFeature
	return r
}

// Optional filter by items with trailers.
func (r ApiGetSubtitlecodecsRequest) HasTrailer(hasTrailer bool) ApiGetSubtitlecodecsRequest {
	r.hasTrailer = &hasTrailer
	return r
}

// Optional. Return items that are siblings of a supplied item.
func (r ApiGetSubtitlecodecsRequest) AdjacentTo(adjacentTo string) ApiGetSubtitlecodecsRequest {
	r.adjacentTo = &adjacentTo
	return r
}

// Optional filter by minimum index number.
func (r ApiGetSubtitlecodecsRequest) MinIndexNumber(minIndexNumber int32) ApiGetSubtitlecodecsRequest {
	r.minIndexNumber = &minIndexNumber
	return r
}

// Optional filter by minimum number of game players.
func (r ApiGetSubtitlecodecsRequest) MinPlayers(minPlayers int32) ApiGetSubtitlecodecsRequest {
	r.minPlayers = &minPlayers
	return r
}

// Optional filter by maximum number of game players.
func (r ApiGetSubtitlecodecsRequest) MaxPlayers(maxPlayers int32) ApiGetSubtitlecodecsRequest {
	r.maxPlayers = &maxPlayers
	return r
}

// Optional filter by parent index number.
func (r ApiGetSubtitlecodecsRequest) ParentIndexNumber(parentIndexNumber int32) ApiGetSubtitlecodecsRequest {
	r.parentIndexNumber = &parentIndexNumber
	return r
}

// Optional filter by items that have or do not have a parental rating
func (r ApiGetSubtitlecodecsRequest) HasParentalRating(hasParentalRating bool) ApiGetSubtitlecodecsRequest {
	r.hasParentalRating = &hasParentalRating
	return r
}

// Optional filter by items that are HD or not.
func (r ApiGetSubtitlecodecsRequest) IsHD(isHD bool) ApiGetSubtitlecodecsRequest {
	r.isHD = &isHD
	return r
}

// Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
func (r ApiGetSubtitlecodecsRequest) LocationTypes(locationTypes string) ApiGetSubtitlecodecsRequest {
	r.locationTypes = &locationTypes
	return r
}

// Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
func (r ApiGetSubtitlecodecsRequest) ExcludeLocationTypes(excludeLocationTypes string) ApiGetSubtitlecodecsRequest {
	r.excludeLocationTypes = &excludeLocationTypes
	return r
}

// Optional filter by items that are missing episodes or not.
func (r ApiGetSubtitlecodecsRequest) IsMissing(isMissing bool) ApiGetSubtitlecodecsRequest {
	r.isMissing = &isMissing
	return r
}

// Optional filter by items that are unaired episodes or not.
func (r ApiGetSubtitlecodecsRequest) IsUnaired(isUnaired bool) ApiGetSubtitlecodecsRequest {
	r.isUnaired = &isUnaired
	return r
}

// Optional filter by minimum community rating.
func (r ApiGetSubtitlecodecsRequest) MinCommunityRating(minCommunityRating float64) ApiGetSubtitlecodecsRequest {
	r.minCommunityRating = &minCommunityRating
	return r
}

// Optional filter by minimum critic rating.
func (r ApiGetSubtitlecodecsRequest) MinCriticRating(minCriticRating float64) ApiGetSubtitlecodecsRequest {
	r.minCriticRating = &minCriticRating
	return r
}

// Gets all episodes that aired during a season, including specials.
func (r ApiGetSubtitlecodecsRequest) AiredDuringSeason(airedDuringSeason int32) ApiGetSubtitlecodecsRequest {
	r.airedDuringSeason = &airedDuringSeason
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r ApiGetSubtitlecodecsRequest) MinPremiereDate(minPremiereDate string) ApiGetSubtitlecodecsRequest {
	r.minPremiereDate = &minPremiereDate
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r ApiGetSubtitlecodecsRequest) MinDateLastSaved(minDateLastSaved string) ApiGetSubtitlecodecsRequest {
	r.minDateLastSaved = &minDateLastSaved
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r ApiGetSubtitlecodecsRequest) MinDateLastSavedForUser(minDateLastSavedForUser string) ApiGetSubtitlecodecsRequest {
	r.minDateLastSavedForUser = &minDateLastSavedForUser
	return r
}

// Optional. The maximum premiere date. Format &#x3D; ISO
func (r ApiGetSubtitlecodecsRequest) MaxPremiereDate(maxPremiereDate string) ApiGetSubtitlecodecsRequest {
	r.maxPremiereDate = &maxPremiereDate
	return r
}

// Optional filter by items that have an overview or not.
func (r ApiGetSubtitlecodecsRequest) HasOverview(hasOverview bool) ApiGetSubtitlecodecsRequest {
	r.hasOverview = &hasOverview
	return r
}

// Optional filter by items that have an imdb id or not.
func (r ApiGetSubtitlecodecsRequest) HasImdbId(hasImdbId bool) ApiGetSubtitlecodecsRequest {
	r.hasImdbId = &hasImdbId
	return r
}

// Optional filter by items that have a tmdb id or not.
func (r ApiGetSubtitlecodecsRequest) HasTmdbId(hasTmdbId bool) ApiGetSubtitlecodecsRequest {
	r.hasTmdbId = &hasTmdbId
	return r
}

// Optional filter by items that have a tvdb id or not.
func (r ApiGetSubtitlecodecsRequest) HasTvdbId(hasTvdbId bool) ApiGetSubtitlecodecsRequest {
	r.hasTvdbId = &hasTvdbId
	return r
}

// Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
func (r ApiGetSubtitlecodecsRequest) ExcludeItemIds(excludeItemIds string) ApiGetSubtitlecodecsRequest {
	r.excludeItemIds = &excludeItemIds
	return r
}

// Optional. The record index to start at. All items with a lower index will be dropped from the results.
func (r ApiGetSubtitlecodecsRequest) StartIndex(startIndex int32) ApiGetSubtitlecodecsRequest {
	r.startIndex = &startIndex
	return r
}

// Optional. The maximum number of records to return
func (r ApiGetSubtitlecodecsRequest) Limit(limit int32) ApiGetSubtitlecodecsRequest {
	r.limit = &limit
	return r
}

// When searching within folders, this determines whether or not the search will be recursive. true/false
func (r ApiGetSubtitlecodecsRequest) Recursive(recursive bool) ApiGetSubtitlecodecsRequest {
	r.recursive = &recursive
	return r
}

// Sort Order - Ascending,Descending
func (r ApiGetSubtitlecodecsRequest) SortOrder(sortOrder string) ApiGetSubtitlecodecsRequest {
	r.sortOrder = &sortOrder
	return r
}

// Specify this to localize the search to a specific item or folder. Omit to use the root
func (r ApiGetSubtitlecodecsRequest) ParentId(parentId string) ApiGetSubtitlecodecsRequest {
	r.parentId = &parentId
	return r
}

// Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
func (r ApiGetSubtitlecodecsRequest) Fields(fields string) ApiGetSubtitlecodecsRequest {
	r.fields = &fields
	return r
}

// Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
func (r ApiGetSubtitlecodecsRequest) ExcludeItemTypes(excludeItemTypes string) ApiGetSubtitlecodecsRequest {
	r.excludeItemTypes = &excludeItemTypes
	return r
}

// Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
func (r ApiGetSubtitlecodecsRequest) IncludeItemTypes(includeItemTypes string) ApiGetSubtitlecodecsRequest {
	r.includeItemTypes = &includeItemTypes
	return r
}

// Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form &#39;prov.id&#39;, e.g. &#39;imdb.tt123456&#39;. This allows multiple, comma delimeted value pairs.
func (r ApiGetSubtitlecodecsRequest) AnyProviderIdEquals(anyProviderIdEquals string) ApiGetSubtitlecodecsRequest {
	r.anyProviderIdEquals = &anyProviderIdEquals
	return r
}

// Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
func (r ApiGetSubtitlecodecsRequest) Filters(filters string) ApiGetSubtitlecodecsRequest {
	r.filters = &filters
	return r
}

// Optional filter by items that are marked as favorite, or not.
func (r ApiGetSubtitlecodecsRequest) IsFavorite(isFavorite bool) ApiGetSubtitlecodecsRequest {
	r.isFavorite = &isFavorite
	return r
}

// Optional filter for movies.
func (r ApiGetSubtitlecodecsRequest) IsMovie(isMovie bool) ApiGetSubtitlecodecsRequest {
	r.isMovie = &isMovie
	return r
}

// Optional filter for movies.
func (r ApiGetSubtitlecodecsRequest) IsSeries(isSeries bool) ApiGetSubtitlecodecsRequest {
	r.isSeries = &isSeries
	return r
}

// Optional filter for news.
func (r ApiGetSubtitlecodecsRequest) IsNews(isNews bool) ApiGetSubtitlecodecsRequest {
	r.isNews = &isNews
	return r
}

// Optional filter for kids.
func (r ApiGetSubtitlecodecsRequest) IsKids(isKids bool) ApiGetSubtitlecodecsRequest {
	r.isKids = &isKids
	return r
}

// Optional filter for sports.
func (r ApiGetSubtitlecodecsRequest) IsSports(isSports bool) ApiGetSubtitlecodecsRequest {
	r.isSports = &isSports
	return r
}

// Optional filter by MediaType. Allows multiple, comma delimited.
func (r ApiGetSubtitlecodecsRequest) MediaTypes(mediaTypes string) ApiGetSubtitlecodecsRequest {
	r.mediaTypes = &mediaTypes
	return r
}

// Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
func (r ApiGetSubtitlecodecsRequest) ImageTypes(imageTypes string) ApiGetSubtitlecodecsRequest {
	r.imageTypes = &imageTypes
	return r
}

// Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
func (r ApiGetSubtitlecodecsRequest) SortBy(sortBy string) ApiGetSubtitlecodecsRequest {
	r.sortBy = &sortBy
	return r
}

// Optional filter by items that are played, or not.
func (r ApiGetSubtitlecodecsRequest) IsPlayed(isPlayed bool) ApiGetSubtitlecodecsRequest {
	r.isPlayed = &isPlayed
	return r
}

// Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
func (r ApiGetSubtitlecodecsRequest) Genres(genres string) ApiGetSubtitlecodecsRequest {
	r.genres = &genres
	return r
}

// Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
func (r ApiGetSubtitlecodecsRequest) OfficialRatings(officialRatings string) ApiGetSubtitlecodecsRequest {
	r.officialRatings = &officialRatings
	return r
}

// Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
func (r ApiGetSubtitlecodecsRequest) Tags(tags string) ApiGetSubtitlecodecsRequest {
	r.tags = &tags
	return r
}

// Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
func (r ApiGetSubtitlecodecsRequest) Years(years string) ApiGetSubtitlecodecsRequest {
	r.years = &years
	return r
}

// Optional, include image information in output
func (r ApiGetSubtitlecodecsRequest) EnableImages(enableImages bool) ApiGetSubtitlecodecsRequest {
	r.enableImages = &enableImages
	return r
}

// Optional, include user data
func (r ApiGetSubtitlecodecsRequest) EnableUserData(enableUserData bool) ApiGetSubtitlecodecsRequest {
	r.enableUserData = &enableUserData
	return r
}

// Optional, the max number of images to return, per image type
func (r ApiGetSubtitlecodecsRequest) ImageTypeLimit(imageTypeLimit int32) ApiGetSubtitlecodecsRequest {
	r.imageTypeLimit = &imageTypeLimit
	return r
}

// Optional. The image types to include in the output.
func (r ApiGetSubtitlecodecsRequest) EnableImageTypes(enableImageTypes string) ApiGetSubtitlecodecsRequest {
	r.enableImageTypes = &enableImageTypes
	return r
}

// Optional. If specified, results will be filtered to include only those containing the specified person.
func (r ApiGetSubtitlecodecsRequest) Person(person string) ApiGetSubtitlecodecsRequest {
	r.person = &person
	return r
}

// Optional. If specified, results will be filtered to include only those containing the specified person.
func (r ApiGetSubtitlecodecsRequest) PersonIds(personIds string) ApiGetSubtitlecodecsRequest {
	r.personIds = &personIds
	return r
}

// Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
func (r ApiGetSubtitlecodecsRequest) PersonTypes(personTypes string) ApiGetSubtitlecodecsRequest {
	r.personTypes = &personTypes
	return r
}

// Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
func (r ApiGetSubtitlecodecsRequest) Studios(studios string) ApiGetSubtitlecodecsRequest {
	r.studios = &studios
	return r
}

// Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
func (r ApiGetSubtitlecodecsRequest) StudioIds(studioIds string) ApiGetSubtitlecodecsRequest {
	r.studioIds = &studioIds
	return r
}

// Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
func (r ApiGetSubtitlecodecsRequest) Artists(artists string) ApiGetSubtitlecodecsRequest {
	r.artists = &artists
	return r
}

// Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
func (r ApiGetSubtitlecodecsRequest) ArtistIds(artistIds string) ApiGetSubtitlecodecsRequest {
	r.artistIds = &artistIds
	return r
}

// Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
func (r ApiGetSubtitlecodecsRequest) Albums(albums string) ApiGetSubtitlecodecsRequest {
	r.albums = &albums
	return r
}

// Optional. If specific items are needed, specify a list of item id&#39;s to retrieve. This allows multiple, comma delimited.
func (r ApiGetSubtitlecodecsRequest) Ids(ids string) ApiGetSubtitlecodecsRequest {
	r.ids = &ids
	return r
}

// Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
func (r ApiGetSubtitlecodecsRequest) VideoTypes(videoTypes string) ApiGetSubtitlecodecsRequest {
	r.videoTypes = &videoTypes
	return r
}

// Optional filter by Container. Allows multiple, comma delimeted.
func (r ApiGetSubtitlecodecsRequest) Containers(containers string) ApiGetSubtitlecodecsRequest {
	r.containers = &containers
	return r
}

// Optional filter by AudioCodec. Allows multiple, comma delimeted.
func (r ApiGetSubtitlecodecsRequest) AudioCodecs(audioCodecs string) ApiGetSubtitlecodecsRequest {
	r.audioCodecs = &audioCodecs
	return r
}

// Optional filter by VideoCodec. Allows multiple, comma delimeted.
func (r ApiGetSubtitlecodecsRequest) VideoCodecs(videoCodecs string) ApiGetSubtitlecodecsRequest {
	r.videoCodecs = &videoCodecs
	return r
}

// Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
func (r ApiGetSubtitlecodecsRequest) SubtitleCodecs(subtitleCodecs string) ApiGetSubtitlecodecsRequest {
	r.subtitleCodecs = &subtitleCodecs
	return r
}

// Optional filter by Path.
func (r ApiGetSubtitlecodecsRequest) Path(path string) ApiGetSubtitlecodecsRequest {
	r.path = &path
	return r
}

// User Id
func (r ApiGetSubtitlecodecsRequest) UserId(userId string) ApiGetSubtitlecodecsRequest {
	r.userId = &userId
	return r
}

// Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
func (r ApiGetSubtitlecodecsRequest) MinOfficialRating(minOfficialRating string) ApiGetSubtitlecodecsRequest {
	r.minOfficialRating = &minOfficialRating
	return r
}

// Optional filter by items that are locked.
func (r ApiGetSubtitlecodecsRequest) IsLocked(isLocked bool) ApiGetSubtitlecodecsRequest {
	r.isLocked = &isLocked
	return r
}

// Optional filter by items that are placeholders
func (r ApiGetSubtitlecodecsRequest) IsPlaceHolder(isPlaceHolder bool) ApiGetSubtitlecodecsRequest {
	r.isPlaceHolder = &isPlaceHolder
	return r
}

// Optional filter by items that have official ratings
func (r ApiGetSubtitlecodecsRequest) HasOfficialRating(hasOfficialRating bool) ApiGetSubtitlecodecsRequest {
	r.hasOfficialRating = &hasOfficialRating
	return r
}

// Whether or not to hide items behind their boxsets.
func (r ApiGetSubtitlecodecsRequest) GroupItemsIntoCollections(groupItemsIntoCollections bool) ApiGetSubtitlecodecsRequest {
	r.groupItemsIntoCollections = &groupItemsIntoCollections
	return r
}

// Optional filter by items that are 3D, or not.
func (r ApiGetSubtitlecodecsRequest) Is3D(is3D bool) ApiGetSubtitlecodecsRequest {
	r.is3D = &is3D
	return r
}

// Optional filter by Series Status. Allows multiple, comma delimeted.
func (r ApiGetSubtitlecodecsRequest) SeriesStatus(seriesStatus string) ApiGetSubtitlecodecsRequest {
	r.seriesStatus = &seriesStatus
	return r
}

// Optional filter by items whose name is sorted equally or greater than a given input string.
func (r ApiGetSubtitlecodecsRequest) NameStartsWithOrGreater(nameStartsWithOrGreater string) ApiGetSubtitlecodecsRequest {
	r.nameStartsWithOrGreater = &nameStartsWithOrGreater
	return r
}

// Optional filter by items whose name is sorted equally than a given input string.
func (r ApiGetSubtitlecodecsRequest) NameStartsWith(nameStartsWith string) ApiGetSubtitlecodecsRequest {
	r.nameStartsWith = &nameStartsWith
	return r
}

// Optional filter by items whose name is equally or lesser than a given input string.
func (r ApiGetSubtitlecodecsRequest) NameLessThan(nameLessThan string) ApiGetSubtitlecodecsRequest {
	r.nameLessThan = &nameLessThan
	return r
}

func (r ApiGetSubtitlecodecsRequest) Execute() (*QueryResultUserLibraryTagItem, *http.Response, error) {
	return r.ApiService.GetSubtitlecodecsExecute(r)
}

/*
GetSubtitlecodecs Gets items based on a query.

No authentication required

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSubtitlecodecsRequest
*/
func (a *TagServiceAPIService) GetSubtitlecodecs(ctx context.Context) ApiGetSubtitlecodecsRequest {
	return ApiGetSubtitlecodecsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return QueryResultUserLibraryTagItem
func (a *TagServiceAPIService) GetSubtitlecodecsExecute(r ApiGetSubtitlecodecsRequest) (*QueryResultUserLibraryTagItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QueryResultUserLibraryTagItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TagServiceAPIService.GetSubtitlecodecs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/SubtitleCodecs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.artistType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ArtistType", r.artistType, "form", "")
	}
	if r.maxOfficialRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxOfficialRating", r.maxOfficialRating, "form", "")
	}
	if r.hasThemeSong != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasThemeSong", r.hasThemeSong, "form", "")
	}
	if r.hasThemeVideo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasThemeVideo", r.hasThemeVideo, "form", "")
	}
	if r.hasSubtitles != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasSubtitles", r.hasSubtitles, "form", "")
	}
	if r.hasSpecialFeature != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasSpecialFeature", r.hasSpecialFeature, "form", "")
	}
	if r.hasTrailer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasTrailer", r.hasTrailer, "form", "")
	}
	if r.adjacentTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AdjacentTo", r.adjacentTo, "form", "")
	}
	if r.minIndexNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinIndexNumber", r.minIndexNumber, "form", "")
	}
	if r.minPlayers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinPlayers", r.minPlayers, "form", "")
	}
	if r.maxPlayers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxPlayers", r.maxPlayers, "form", "")
	}
	if r.parentIndexNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ParentIndexNumber", r.parentIndexNumber, "form", "")
	}
	if r.hasParentalRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasParentalRating", r.hasParentalRating, "form", "")
	}
	if r.isHD != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsHD", r.isHD, "form", "")
	}
	if r.locationTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "LocationTypes", r.locationTypes, "form", "")
	}
	if r.excludeLocationTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ExcludeLocationTypes", r.excludeLocationTypes, "form", "")
	}
	if r.isMissing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsMissing", r.isMissing, "form", "")
	}
	if r.isUnaired != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsUnaired", r.isUnaired, "form", "")
	}
	if r.minCommunityRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinCommunityRating", r.minCommunityRating, "form", "")
	}
	if r.minCriticRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinCriticRating", r.minCriticRating, "form", "")
	}
	if r.airedDuringSeason != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AiredDuringSeason", r.airedDuringSeason, "form", "")
	}
	if r.minPremiereDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinPremiereDate", r.minPremiereDate, "form", "")
	}
	if r.minDateLastSaved != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinDateLastSaved", r.minDateLastSaved, "form", "")
	}
	if r.minDateLastSavedForUser != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinDateLastSavedForUser", r.minDateLastSavedForUser, "form", "")
	}
	if r.maxPremiereDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxPremiereDate", r.maxPremiereDate, "form", "")
	}
	if r.hasOverview != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasOverview", r.hasOverview, "form", "")
	}
	if r.hasImdbId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasImdbId", r.hasImdbId, "form", "")
	}
	if r.hasTmdbId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasTmdbId", r.hasTmdbId, "form", "")
	}
	if r.hasTvdbId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasTvdbId", r.hasTvdbId, "form", "")
	}
	if r.excludeItemIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ExcludeItemIds", r.excludeItemIds, "form", "")
	}
	if r.startIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "StartIndex", r.startIndex, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Limit", r.limit, "form", "")
	}
	if r.recursive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Recursive", r.recursive, "form", "")
	}
	if r.sortOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SortOrder", r.sortOrder, "form", "")
	}
	if r.parentId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ParentId", r.parentId, "form", "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Fields", r.fields, "form", "")
	}
	if r.excludeItemTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ExcludeItemTypes", r.excludeItemTypes, "form", "")
	}
	if r.includeItemTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IncludeItemTypes", r.includeItemTypes, "form", "")
	}
	if r.anyProviderIdEquals != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AnyProviderIdEquals", r.anyProviderIdEquals, "form", "")
	}
	if r.filters != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Filters", r.filters, "form", "")
	}
	if r.isFavorite != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsFavorite", r.isFavorite, "form", "")
	}
	if r.isMovie != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsMovie", r.isMovie, "form", "")
	}
	if r.isSeries != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsSeries", r.isSeries, "form", "")
	}
	if r.isNews != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsNews", r.isNews, "form", "")
	}
	if r.isKids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsKids", r.isKids, "form", "")
	}
	if r.isSports != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsSports", r.isSports, "form", "")
	}
	if r.mediaTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MediaTypes", r.mediaTypes, "form", "")
	}
	if r.imageTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ImageTypes", r.imageTypes, "form", "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SortBy", r.sortBy, "form", "")
	}
	if r.isPlayed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsPlayed", r.isPlayed, "form", "")
	}
	if r.genres != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Genres", r.genres, "form", "")
	}
	if r.officialRatings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "OfficialRatings", r.officialRatings, "form", "")
	}
	if r.tags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Tags", r.tags, "form", "")
	}
	if r.years != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Years", r.years, "form", "")
	}
	if r.enableImages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImages", r.enableImages, "form", "")
	}
	if r.enableUserData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableUserData", r.enableUserData, "form", "")
	}
	if r.imageTypeLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ImageTypeLimit", r.imageTypeLimit, "form", "")
	}
	if r.enableImageTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImageTypes", r.enableImageTypes, "form", "")
	}
	if r.person != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Person", r.person, "form", "")
	}
	if r.personIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "PersonIds", r.personIds, "form", "")
	}
	if r.personTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "PersonTypes", r.personTypes, "form", "")
	}
	if r.studios != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Studios", r.studios, "form", "")
	}
	if r.studioIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "StudioIds", r.studioIds, "form", "")
	}
	if r.artists != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Artists", r.artists, "form", "")
	}
	if r.artistIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ArtistIds", r.artistIds, "form", "")
	}
	if r.albums != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Albums", r.albums, "form", "")
	}
	if r.ids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Ids", r.ids, "form", "")
	}
	if r.videoTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "VideoTypes", r.videoTypes, "form", "")
	}
	if r.containers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Containers", r.containers, "form", "")
	}
	if r.audioCodecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AudioCodecs", r.audioCodecs, "form", "")
	}
	if r.videoCodecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "VideoCodecs", r.videoCodecs, "form", "")
	}
	if r.subtitleCodecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SubtitleCodecs", r.subtitleCodecs, "form", "")
	}
	if r.path != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Path", r.path, "form", "")
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "UserId", r.userId, "form", "")
	}
	if r.minOfficialRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinOfficialRating", r.minOfficialRating, "form", "")
	}
	if r.isLocked != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsLocked", r.isLocked, "form", "")
	}
	if r.isPlaceHolder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsPlaceHolder", r.isPlaceHolder, "form", "")
	}
	if r.hasOfficialRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasOfficialRating", r.hasOfficialRating, "form", "")
	}
	if r.groupItemsIntoCollections != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "GroupItemsIntoCollections", r.groupItemsIntoCollections, "form", "")
	}
	if r.is3D != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Is3D", r.is3D, "form", "")
	}
	if r.seriesStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SeriesStatus", r.seriesStatus, "form", "")
	}
	if r.nameStartsWithOrGreater != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "NameStartsWithOrGreater", r.nameStartsWithOrGreater, "form", "")
	}
	if r.nameStartsWith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "NameStartsWith", r.nameStartsWith, "form", "")
	}
	if r.nameLessThan != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "NameLessThan", r.nameLessThan, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTagsRequest struct {
	ctx context.Context
	ApiService TagServiceAPI
	artistType *string
	maxOfficialRating *string
	hasThemeSong *bool
	hasThemeVideo *bool
	hasSubtitles *bool
	hasSpecialFeature *bool
	hasTrailer *bool
	adjacentTo *string
	minIndexNumber *int32
	minPlayers *int32
	maxPlayers *int32
	parentIndexNumber *int32
	hasParentalRating *bool
	isHD *bool
	locationTypes *string
	excludeLocationTypes *string
	isMissing *bool
	isUnaired *bool
	minCommunityRating *float64
	minCriticRating *float64
	airedDuringSeason *int32
	minPremiereDate *string
	minDateLastSaved *string
	minDateLastSavedForUser *string
	maxPremiereDate *string
	hasOverview *bool
	hasImdbId *bool
	hasTmdbId *bool
	hasTvdbId *bool
	excludeItemIds *string
	startIndex *int32
	limit *int32
	recursive *bool
	sortOrder *string
	parentId *string
	fields *string
	excludeItemTypes *string
	includeItemTypes *string
	anyProviderIdEquals *string
	filters *string
	isFavorite *bool
	isMovie *bool
	isSeries *bool
	isNews *bool
	isKids *bool
	isSports *bool
	mediaTypes *string
	imageTypes *string
	sortBy *string
	isPlayed *bool
	genres *string
	officialRatings *string
	tags *string
	years *string
	enableImages *bool
	enableUserData *bool
	imageTypeLimit *int32
	enableImageTypes *string
	person *string
	personIds *string
	personTypes *string
	studios *string
	studioIds *string
	artists *string
	artistIds *string
	albums *string
	ids *string
	videoTypes *string
	containers *string
	audioCodecs *string
	videoCodecs *string
	subtitleCodecs *string
	path *string
	userId *string
	minOfficialRating *string
	isLocked *bool
	isPlaceHolder *bool
	hasOfficialRating *bool
	groupItemsIntoCollections *bool
	is3D *bool
	seriesStatus *string
	nameStartsWithOrGreater *string
	nameStartsWith *string
	nameLessThan *string
}

// Artist or AlbumArtist
func (r ApiGetTagsRequest) ArtistType(artistType string) ApiGetTagsRequest {
	r.artistType = &artistType
	return r
}

// Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
func (r ApiGetTagsRequest) MaxOfficialRating(maxOfficialRating string) ApiGetTagsRequest {
	r.maxOfficialRating = &maxOfficialRating
	return r
}

// Optional filter by items with theme songs.
func (r ApiGetTagsRequest) HasThemeSong(hasThemeSong bool) ApiGetTagsRequest {
	r.hasThemeSong = &hasThemeSong
	return r
}

// Optional filter by items with theme videos.
func (r ApiGetTagsRequest) HasThemeVideo(hasThemeVideo bool) ApiGetTagsRequest {
	r.hasThemeVideo = &hasThemeVideo
	return r
}

// Optional filter by items with subtitles.
func (r ApiGetTagsRequest) HasSubtitles(hasSubtitles bool) ApiGetTagsRequest {
	r.hasSubtitles = &hasSubtitles
	return r
}

// Optional filter by items with special features.
func (r ApiGetTagsRequest) HasSpecialFeature(hasSpecialFeature bool) ApiGetTagsRequest {
	r.hasSpecialFeature = &hasSpecialFeature
	return r
}

// Optional filter by items with trailers.
func (r ApiGetTagsRequest) HasTrailer(hasTrailer bool) ApiGetTagsRequest {
	r.hasTrailer = &hasTrailer
	return r
}

// Optional. Return items that are siblings of a supplied item.
func (r ApiGetTagsRequest) AdjacentTo(adjacentTo string) ApiGetTagsRequest {
	r.adjacentTo = &adjacentTo
	return r
}

// Optional filter by minimum index number.
func (r ApiGetTagsRequest) MinIndexNumber(minIndexNumber int32) ApiGetTagsRequest {
	r.minIndexNumber = &minIndexNumber
	return r
}

// Optional filter by minimum number of game players.
func (r ApiGetTagsRequest) MinPlayers(minPlayers int32) ApiGetTagsRequest {
	r.minPlayers = &minPlayers
	return r
}

// Optional filter by maximum number of game players.
func (r ApiGetTagsRequest) MaxPlayers(maxPlayers int32) ApiGetTagsRequest {
	r.maxPlayers = &maxPlayers
	return r
}

// Optional filter by parent index number.
func (r ApiGetTagsRequest) ParentIndexNumber(parentIndexNumber int32) ApiGetTagsRequest {
	r.parentIndexNumber = &parentIndexNumber
	return r
}

// Optional filter by items that have or do not have a parental rating
func (r ApiGetTagsRequest) HasParentalRating(hasParentalRating bool) ApiGetTagsRequest {
	r.hasParentalRating = &hasParentalRating
	return r
}

// Optional filter by items that are HD or not.
func (r ApiGetTagsRequest) IsHD(isHD bool) ApiGetTagsRequest {
	r.isHD = &isHD
	return r
}

// Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
func (r ApiGetTagsRequest) LocationTypes(locationTypes string) ApiGetTagsRequest {
	r.locationTypes = &locationTypes
	return r
}

// Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
func (r ApiGetTagsRequest) ExcludeLocationTypes(excludeLocationTypes string) ApiGetTagsRequest {
	r.excludeLocationTypes = &excludeLocationTypes
	return r
}

// Optional filter by items that are missing episodes or not.
func (r ApiGetTagsRequest) IsMissing(isMissing bool) ApiGetTagsRequest {
	r.isMissing = &isMissing
	return r
}

// Optional filter by items that are unaired episodes or not.
func (r ApiGetTagsRequest) IsUnaired(isUnaired bool) ApiGetTagsRequest {
	r.isUnaired = &isUnaired
	return r
}

// Optional filter by minimum community rating.
func (r ApiGetTagsRequest) MinCommunityRating(minCommunityRating float64) ApiGetTagsRequest {
	r.minCommunityRating = &minCommunityRating
	return r
}

// Optional filter by minimum critic rating.
func (r ApiGetTagsRequest) MinCriticRating(minCriticRating float64) ApiGetTagsRequest {
	r.minCriticRating = &minCriticRating
	return r
}

// Gets all episodes that aired during a season, including specials.
func (r ApiGetTagsRequest) AiredDuringSeason(airedDuringSeason int32) ApiGetTagsRequest {
	r.airedDuringSeason = &airedDuringSeason
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r ApiGetTagsRequest) MinPremiereDate(minPremiereDate string) ApiGetTagsRequest {
	r.minPremiereDate = &minPremiereDate
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r ApiGetTagsRequest) MinDateLastSaved(minDateLastSaved string) ApiGetTagsRequest {
	r.minDateLastSaved = &minDateLastSaved
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r ApiGetTagsRequest) MinDateLastSavedForUser(minDateLastSavedForUser string) ApiGetTagsRequest {
	r.minDateLastSavedForUser = &minDateLastSavedForUser
	return r
}

// Optional. The maximum premiere date. Format &#x3D; ISO
func (r ApiGetTagsRequest) MaxPremiereDate(maxPremiereDate string) ApiGetTagsRequest {
	r.maxPremiereDate = &maxPremiereDate
	return r
}

// Optional filter by items that have an overview or not.
func (r ApiGetTagsRequest) HasOverview(hasOverview bool) ApiGetTagsRequest {
	r.hasOverview = &hasOverview
	return r
}

// Optional filter by items that have an imdb id or not.
func (r ApiGetTagsRequest) HasImdbId(hasImdbId bool) ApiGetTagsRequest {
	r.hasImdbId = &hasImdbId
	return r
}

// Optional filter by items that have a tmdb id or not.
func (r ApiGetTagsRequest) HasTmdbId(hasTmdbId bool) ApiGetTagsRequest {
	r.hasTmdbId = &hasTmdbId
	return r
}

// Optional filter by items that have a tvdb id or not.
func (r ApiGetTagsRequest) HasTvdbId(hasTvdbId bool) ApiGetTagsRequest {
	r.hasTvdbId = &hasTvdbId
	return r
}

// Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
func (r ApiGetTagsRequest) ExcludeItemIds(excludeItemIds string) ApiGetTagsRequest {
	r.excludeItemIds = &excludeItemIds
	return r
}

// Optional. The record index to start at. All items with a lower index will be dropped from the results.
func (r ApiGetTagsRequest) StartIndex(startIndex int32) ApiGetTagsRequest {
	r.startIndex = &startIndex
	return r
}

// Optional. The maximum number of records to return
func (r ApiGetTagsRequest) Limit(limit int32) ApiGetTagsRequest {
	r.limit = &limit
	return r
}

// When searching within folders, this determines whether or not the search will be recursive. true/false
func (r ApiGetTagsRequest) Recursive(recursive bool) ApiGetTagsRequest {
	r.recursive = &recursive
	return r
}

// Sort Order - Ascending,Descending
func (r ApiGetTagsRequest) SortOrder(sortOrder string) ApiGetTagsRequest {
	r.sortOrder = &sortOrder
	return r
}

// Specify this to localize the search to a specific item or folder. Omit to use the root
func (r ApiGetTagsRequest) ParentId(parentId string) ApiGetTagsRequest {
	r.parentId = &parentId
	return r
}

// Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
func (r ApiGetTagsRequest) Fields(fields string) ApiGetTagsRequest {
	r.fields = &fields
	return r
}

// Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
func (r ApiGetTagsRequest) ExcludeItemTypes(excludeItemTypes string) ApiGetTagsRequest {
	r.excludeItemTypes = &excludeItemTypes
	return r
}

// Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
func (r ApiGetTagsRequest) IncludeItemTypes(includeItemTypes string) ApiGetTagsRequest {
	r.includeItemTypes = &includeItemTypes
	return r
}

// Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form &#39;prov.id&#39;, e.g. &#39;imdb.tt123456&#39;. This allows multiple, comma delimeted value pairs.
func (r ApiGetTagsRequest) AnyProviderIdEquals(anyProviderIdEquals string) ApiGetTagsRequest {
	r.anyProviderIdEquals = &anyProviderIdEquals
	return r
}

// Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
func (r ApiGetTagsRequest) Filters(filters string) ApiGetTagsRequest {
	r.filters = &filters
	return r
}

// Optional filter by items that are marked as favorite, or not.
func (r ApiGetTagsRequest) IsFavorite(isFavorite bool) ApiGetTagsRequest {
	r.isFavorite = &isFavorite
	return r
}

// Optional filter for movies.
func (r ApiGetTagsRequest) IsMovie(isMovie bool) ApiGetTagsRequest {
	r.isMovie = &isMovie
	return r
}

// Optional filter for movies.
func (r ApiGetTagsRequest) IsSeries(isSeries bool) ApiGetTagsRequest {
	r.isSeries = &isSeries
	return r
}

// Optional filter for news.
func (r ApiGetTagsRequest) IsNews(isNews bool) ApiGetTagsRequest {
	r.isNews = &isNews
	return r
}

// Optional filter for kids.
func (r ApiGetTagsRequest) IsKids(isKids bool) ApiGetTagsRequest {
	r.isKids = &isKids
	return r
}

// Optional filter for sports.
func (r ApiGetTagsRequest) IsSports(isSports bool) ApiGetTagsRequest {
	r.isSports = &isSports
	return r
}

// Optional filter by MediaType. Allows multiple, comma delimited.
func (r ApiGetTagsRequest) MediaTypes(mediaTypes string) ApiGetTagsRequest {
	r.mediaTypes = &mediaTypes
	return r
}

// Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
func (r ApiGetTagsRequest) ImageTypes(imageTypes string) ApiGetTagsRequest {
	r.imageTypes = &imageTypes
	return r
}

// Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
func (r ApiGetTagsRequest) SortBy(sortBy string) ApiGetTagsRequest {
	r.sortBy = &sortBy
	return r
}

// Optional filter by items that are played, or not.
func (r ApiGetTagsRequest) IsPlayed(isPlayed bool) ApiGetTagsRequest {
	r.isPlayed = &isPlayed
	return r
}

// Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
func (r ApiGetTagsRequest) Genres(genres string) ApiGetTagsRequest {
	r.genres = &genres
	return r
}

// Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
func (r ApiGetTagsRequest) OfficialRatings(officialRatings string) ApiGetTagsRequest {
	r.officialRatings = &officialRatings
	return r
}

// Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
func (r ApiGetTagsRequest) Tags(tags string) ApiGetTagsRequest {
	r.tags = &tags
	return r
}

// Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
func (r ApiGetTagsRequest) Years(years string) ApiGetTagsRequest {
	r.years = &years
	return r
}

// Optional, include image information in output
func (r ApiGetTagsRequest) EnableImages(enableImages bool) ApiGetTagsRequest {
	r.enableImages = &enableImages
	return r
}

// Optional, include user data
func (r ApiGetTagsRequest) EnableUserData(enableUserData bool) ApiGetTagsRequest {
	r.enableUserData = &enableUserData
	return r
}

// Optional, the max number of images to return, per image type
func (r ApiGetTagsRequest) ImageTypeLimit(imageTypeLimit int32) ApiGetTagsRequest {
	r.imageTypeLimit = &imageTypeLimit
	return r
}

// Optional. The image types to include in the output.
func (r ApiGetTagsRequest) EnableImageTypes(enableImageTypes string) ApiGetTagsRequest {
	r.enableImageTypes = &enableImageTypes
	return r
}

// Optional. If specified, results will be filtered to include only those containing the specified person.
func (r ApiGetTagsRequest) Person(person string) ApiGetTagsRequest {
	r.person = &person
	return r
}

// Optional. If specified, results will be filtered to include only those containing the specified person.
func (r ApiGetTagsRequest) PersonIds(personIds string) ApiGetTagsRequest {
	r.personIds = &personIds
	return r
}

// Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
func (r ApiGetTagsRequest) PersonTypes(personTypes string) ApiGetTagsRequest {
	r.personTypes = &personTypes
	return r
}

// Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
func (r ApiGetTagsRequest) Studios(studios string) ApiGetTagsRequest {
	r.studios = &studios
	return r
}

// Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
func (r ApiGetTagsRequest) StudioIds(studioIds string) ApiGetTagsRequest {
	r.studioIds = &studioIds
	return r
}

// Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
func (r ApiGetTagsRequest) Artists(artists string) ApiGetTagsRequest {
	r.artists = &artists
	return r
}

// Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
func (r ApiGetTagsRequest) ArtistIds(artistIds string) ApiGetTagsRequest {
	r.artistIds = &artistIds
	return r
}

// Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
func (r ApiGetTagsRequest) Albums(albums string) ApiGetTagsRequest {
	r.albums = &albums
	return r
}

// Optional. If specific items are needed, specify a list of item id&#39;s to retrieve. This allows multiple, comma delimited.
func (r ApiGetTagsRequest) Ids(ids string) ApiGetTagsRequest {
	r.ids = &ids
	return r
}

// Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
func (r ApiGetTagsRequest) VideoTypes(videoTypes string) ApiGetTagsRequest {
	r.videoTypes = &videoTypes
	return r
}

// Optional filter by Container. Allows multiple, comma delimeted.
func (r ApiGetTagsRequest) Containers(containers string) ApiGetTagsRequest {
	r.containers = &containers
	return r
}

// Optional filter by AudioCodec. Allows multiple, comma delimeted.
func (r ApiGetTagsRequest) AudioCodecs(audioCodecs string) ApiGetTagsRequest {
	r.audioCodecs = &audioCodecs
	return r
}

// Optional filter by VideoCodec. Allows multiple, comma delimeted.
func (r ApiGetTagsRequest) VideoCodecs(videoCodecs string) ApiGetTagsRequest {
	r.videoCodecs = &videoCodecs
	return r
}

// Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
func (r ApiGetTagsRequest) SubtitleCodecs(subtitleCodecs string) ApiGetTagsRequest {
	r.subtitleCodecs = &subtitleCodecs
	return r
}

// Optional filter by Path.
func (r ApiGetTagsRequest) Path(path string) ApiGetTagsRequest {
	r.path = &path
	return r
}

// User Id
func (r ApiGetTagsRequest) UserId(userId string) ApiGetTagsRequest {
	r.userId = &userId
	return r
}

// Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
func (r ApiGetTagsRequest) MinOfficialRating(minOfficialRating string) ApiGetTagsRequest {
	r.minOfficialRating = &minOfficialRating
	return r
}

// Optional filter by items that are locked.
func (r ApiGetTagsRequest) IsLocked(isLocked bool) ApiGetTagsRequest {
	r.isLocked = &isLocked
	return r
}

// Optional filter by items that are placeholders
func (r ApiGetTagsRequest) IsPlaceHolder(isPlaceHolder bool) ApiGetTagsRequest {
	r.isPlaceHolder = &isPlaceHolder
	return r
}

// Optional filter by items that have official ratings
func (r ApiGetTagsRequest) HasOfficialRating(hasOfficialRating bool) ApiGetTagsRequest {
	r.hasOfficialRating = &hasOfficialRating
	return r
}

// Whether or not to hide items behind their boxsets.
func (r ApiGetTagsRequest) GroupItemsIntoCollections(groupItemsIntoCollections bool) ApiGetTagsRequest {
	r.groupItemsIntoCollections = &groupItemsIntoCollections
	return r
}

// Optional filter by items that are 3D, or not.
func (r ApiGetTagsRequest) Is3D(is3D bool) ApiGetTagsRequest {
	r.is3D = &is3D
	return r
}

// Optional filter by Series Status. Allows multiple, comma delimeted.
func (r ApiGetTagsRequest) SeriesStatus(seriesStatus string) ApiGetTagsRequest {
	r.seriesStatus = &seriesStatus
	return r
}

// Optional filter by items whose name is sorted equally or greater than a given input string.
func (r ApiGetTagsRequest) NameStartsWithOrGreater(nameStartsWithOrGreater string) ApiGetTagsRequest {
	r.nameStartsWithOrGreater = &nameStartsWithOrGreater
	return r
}

// Optional filter by items whose name is sorted equally than a given input string.
func (r ApiGetTagsRequest) NameStartsWith(nameStartsWith string) ApiGetTagsRequest {
	r.nameStartsWith = &nameStartsWith
	return r
}

// Optional filter by items whose name is equally or lesser than a given input string.
func (r ApiGetTagsRequest) NameLessThan(nameLessThan string) ApiGetTagsRequest {
	r.nameLessThan = &nameLessThan
	return r
}

func (r ApiGetTagsRequest) Execute() (*QueryResultUserLibraryTagItem, *http.Response, error) {
	return r.ApiService.GetTagsExecute(r)
}

/*
GetTags Gets items based on a query.

No authentication required

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTagsRequest
*/
func (a *TagServiceAPIService) GetTags(ctx context.Context) ApiGetTagsRequest {
	return ApiGetTagsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return QueryResultUserLibraryTagItem
func (a *TagServiceAPIService) GetTagsExecute(r ApiGetTagsRequest) (*QueryResultUserLibraryTagItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QueryResultUserLibraryTagItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TagServiceAPIService.GetTags")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Tags"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.artistType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ArtistType", r.artistType, "form", "")
	}
	if r.maxOfficialRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxOfficialRating", r.maxOfficialRating, "form", "")
	}
	if r.hasThemeSong != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasThemeSong", r.hasThemeSong, "form", "")
	}
	if r.hasThemeVideo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasThemeVideo", r.hasThemeVideo, "form", "")
	}
	if r.hasSubtitles != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasSubtitles", r.hasSubtitles, "form", "")
	}
	if r.hasSpecialFeature != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasSpecialFeature", r.hasSpecialFeature, "form", "")
	}
	if r.hasTrailer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasTrailer", r.hasTrailer, "form", "")
	}
	if r.adjacentTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AdjacentTo", r.adjacentTo, "form", "")
	}
	if r.minIndexNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinIndexNumber", r.minIndexNumber, "form", "")
	}
	if r.minPlayers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinPlayers", r.minPlayers, "form", "")
	}
	if r.maxPlayers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxPlayers", r.maxPlayers, "form", "")
	}
	if r.parentIndexNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ParentIndexNumber", r.parentIndexNumber, "form", "")
	}
	if r.hasParentalRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasParentalRating", r.hasParentalRating, "form", "")
	}
	if r.isHD != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsHD", r.isHD, "form", "")
	}
	if r.locationTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "LocationTypes", r.locationTypes, "form", "")
	}
	if r.excludeLocationTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ExcludeLocationTypes", r.excludeLocationTypes, "form", "")
	}
	if r.isMissing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsMissing", r.isMissing, "form", "")
	}
	if r.isUnaired != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsUnaired", r.isUnaired, "form", "")
	}
	if r.minCommunityRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinCommunityRating", r.minCommunityRating, "form", "")
	}
	if r.minCriticRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinCriticRating", r.minCriticRating, "form", "")
	}
	if r.airedDuringSeason != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AiredDuringSeason", r.airedDuringSeason, "form", "")
	}
	if r.minPremiereDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinPremiereDate", r.minPremiereDate, "form", "")
	}
	if r.minDateLastSaved != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinDateLastSaved", r.minDateLastSaved, "form", "")
	}
	if r.minDateLastSavedForUser != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinDateLastSavedForUser", r.minDateLastSavedForUser, "form", "")
	}
	if r.maxPremiereDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxPremiereDate", r.maxPremiereDate, "form", "")
	}
	if r.hasOverview != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasOverview", r.hasOverview, "form", "")
	}
	if r.hasImdbId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasImdbId", r.hasImdbId, "form", "")
	}
	if r.hasTmdbId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasTmdbId", r.hasTmdbId, "form", "")
	}
	if r.hasTvdbId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasTvdbId", r.hasTvdbId, "form", "")
	}
	if r.excludeItemIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ExcludeItemIds", r.excludeItemIds, "form", "")
	}
	if r.startIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "StartIndex", r.startIndex, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Limit", r.limit, "form", "")
	}
	if r.recursive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Recursive", r.recursive, "form", "")
	}
	if r.sortOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SortOrder", r.sortOrder, "form", "")
	}
	if r.parentId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ParentId", r.parentId, "form", "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Fields", r.fields, "form", "")
	}
	if r.excludeItemTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ExcludeItemTypes", r.excludeItemTypes, "form", "")
	}
	if r.includeItemTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IncludeItemTypes", r.includeItemTypes, "form", "")
	}
	if r.anyProviderIdEquals != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AnyProviderIdEquals", r.anyProviderIdEquals, "form", "")
	}
	if r.filters != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Filters", r.filters, "form", "")
	}
	if r.isFavorite != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsFavorite", r.isFavorite, "form", "")
	}
	if r.isMovie != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsMovie", r.isMovie, "form", "")
	}
	if r.isSeries != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsSeries", r.isSeries, "form", "")
	}
	if r.isNews != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsNews", r.isNews, "form", "")
	}
	if r.isKids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsKids", r.isKids, "form", "")
	}
	if r.isSports != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsSports", r.isSports, "form", "")
	}
	if r.mediaTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MediaTypes", r.mediaTypes, "form", "")
	}
	if r.imageTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ImageTypes", r.imageTypes, "form", "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SortBy", r.sortBy, "form", "")
	}
	if r.isPlayed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsPlayed", r.isPlayed, "form", "")
	}
	if r.genres != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Genres", r.genres, "form", "")
	}
	if r.officialRatings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "OfficialRatings", r.officialRatings, "form", "")
	}
	if r.tags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Tags", r.tags, "form", "")
	}
	if r.years != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Years", r.years, "form", "")
	}
	if r.enableImages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImages", r.enableImages, "form", "")
	}
	if r.enableUserData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableUserData", r.enableUserData, "form", "")
	}
	if r.imageTypeLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ImageTypeLimit", r.imageTypeLimit, "form", "")
	}
	if r.enableImageTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImageTypes", r.enableImageTypes, "form", "")
	}
	if r.person != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Person", r.person, "form", "")
	}
	if r.personIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "PersonIds", r.personIds, "form", "")
	}
	if r.personTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "PersonTypes", r.personTypes, "form", "")
	}
	if r.studios != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Studios", r.studios, "form", "")
	}
	if r.studioIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "StudioIds", r.studioIds, "form", "")
	}
	if r.artists != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Artists", r.artists, "form", "")
	}
	if r.artistIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ArtistIds", r.artistIds, "form", "")
	}
	if r.albums != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Albums", r.albums, "form", "")
	}
	if r.ids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Ids", r.ids, "form", "")
	}
	if r.videoTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "VideoTypes", r.videoTypes, "form", "")
	}
	if r.containers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Containers", r.containers, "form", "")
	}
	if r.audioCodecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AudioCodecs", r.audioCodecs, "form", "")
	}
	if r.videoCodecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "VideoCodecs", r.videoCodecs, "form", "")
	}
	if r.subtitleCodecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SubtitleCodecs", r.subtitleCodecs, "form", "")
	}
	if r.path != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Path", r.path, "form", "")
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "UserId", r.userId, "form", "")
	}
	if r.minOfficialRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinOfficialRating", r.minOfficialRating, "form", "")
	}
	if r.isLocked != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsLocked", r.isLocked, "form", "")
	}
	if r.isPlaceHolder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsPlaceHolder", r.isPlaceHolder, "form", "")
	}
	if r.hasOfficialRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasOfficialRating", r.hasOfficialRating, "form", "")
	}
	if r.groupItemsIntoCollections != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "GroupItemsIntoCollections", r.groupItemsIntoCollections, "form", "")
	}
	if r.is3D != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Is3D", r.is3D, "form", "")
	}
	if r.seriesStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SeriesStatus", r.seriesStatus, "form", "")
	}
	if r.nameStartsWithOrGreater != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "NameStartsWithOrGreater", r.nameStartsWithOrGreater, "form", "")
	}
	if r.nameStartsWith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "NameStartsWith", r.nameStartsWith, "form", "")
	}
	if r.nameLessThan != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "NameLessThan", r.nameLessThan, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetVideocodecsRequest struct {
	ctx context.Context
	ApiService TagServiceAPI
	artistType *string
	maxOfficialRating *string
	hasThemeSong *bool
	hasThemeVideo *bool
	hasSubtitles *bool
	hasSpecialFeature *bool
	hasTrailer *bool
	adjacentTo *string
	minIndexNumber *int32
	minPlayers *int32
	maxPlayers *int32
	parentIndexNumber *int32
	hasParentalRating *bool
	isHD *bool
	locationTypes *string
	excludeLocationTypes *string
	isMissing *bool
	isUnaired *bool
	minCommunityRating *float64
	minCriticRating *float64
	airedDuringSeason *int32
	minPremiereDate *string
	minDateLastSaved *string
	minDateLastSavedForUser *string
	maxPremiereDate *string
	hasOverview *bool
	hasImdbId *bool
	hasTmdbId *bool
	hasTvdbId *bool
	excludeItemIds *string
	startIndex *int32
	limit *int32
	recursive *bool
	sortOrder *string
	parentId *string
	fields *string
	excludeItemTypes *string
	includeItemTypes *string
	anyProviderIdEquals *string
	filters *string
	isFavorite *bool
	isMovie *bool
	isSeries *bool
	isNews *bool
	isKids *bool
	isSports *bool
	mediaTypes *string
	imageTypes *string
	sortBy *string
	isPlayed *bool
	genres *string
	officialRatings *string
	tags *string
	years *string
	enableImages *bool
	enableUserData *bool
	imageTypeLimit *int32
	enableImageTypes *string
	person *string
	personIds *string
	personTypes *string
	studios *string
	studioIds *string
	artists *string
	artistIds *string
	albums *string
	ids *string
	videoTypes *string
	containers *string
	audioCodecs *string
	videoCodecs *string
	subtitleCodecs *string
	path *string
	userId *string
	minOfficialRating *string
	isLocked *bool
	isPlaceHolder *bool
	hasOfficialRating *bool
	groupItemsIntoCollections *bool
	is3D *bool
	seriesStatus *string
	nameStartsWithOrGreater *string
	nameStartsWith *string
	nameLessThan *string
}

// Artist or AlbumArtist
func (r ApiGetVideocodecsRequest) ArtistType(artistType string) ApiGetVideocodecsRequest {
	r.artistType = &artistType
	return r
}

// Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
func (r ApiGetVideocodecsRequest) MaxOfficialRating(maxOfficialRating string) ApiGetVideocodecsRequest {
	r.maxOfficialRating = &maxOfficialRating
	return r
}

// Optional filter by items with theme songs.
func (r ApiGetVideocodecsRequest) HasThemeSong(hasThemeSong bool) ApiGetVideocodecsRequest {
	r.hasThemeSong = &hasThemeSong
	return r
}

// Optional filter by items with theme videos.
func (r ApiGetVideocodecsRequest) HasThemeVideo(hasThemeVideo bool) ApiGetVideocodecsRequest {
	r.hasThemeVideo = &hasThemeVideo
	return r
}

// Optional filter by items with subtitles.
func (r ApiGetVideocodecsRequest) HasSubtitles(hasSubtitles bool) ApiGetVideocodecsRequest {
	r.hasSubtitles = &hasSubtitles
	return r
}

// Optional filter by items with special features.
func (r ApiGetVideocodecsRequest) HasSpecialFeature(hasSpecialFeature bool) ApiGetVideocodecsRequest {
	r.hasSpecialFeature = &hasSpecialFeature
	return r
}

// Optional filter by items with trailers.
func (r ApiGetVideocodecsRequest) HasTrailer(hasTrailer bool) ApiGetVideocodecsRequest {
	r.hasTrailer = &hasTrailer
	return r
}

// Optional. Return items that are siblings of a supplied item.
func (r ApiGetVideocodecsRequest) AdjacentTo(adjacentTo string) ApiGetVideocodecsRequest {
	r.adjacentTo = &adjacentTo
	return r
}

// Optional filter by minimum index number.
func (r ApiGetVideocodecsRequest) MinIndexNumber(minIndexNumber int32) ApiGetVideocodecsRequest {
	r.minIndexNumber = &minIndexNumber
	return r
}

// Optional filter by minimum number of game players.
func (r ApiGetVideocodecsRequest) MinPlayers(minPlayers int32) ApiGetVideocodecsRequest {
	r.minPlayers = &minPlayers
	return r
}

// Optional filter by maximum number of game players.
func (r ApiGetVideocodecsRequest) MaxPlayers(maxPlayers int32) ApiGetVideocodecsRequest {
	r.maxPlayers = &maxPlayers
	return r
}

// Optional filter by parent index number.
func (r ApiGetVideocodecsRequest) ParentIndexNumber(parentIndexNumber int32) ApiGetVideocodecsRequest {
	r.parentIndexNumber = &parentIndexNumber
	return r
}

// Optional filter by items that have or do not have a parental rating
func (r ApiGetVideocodecsRequest) HasParentalRating(hasParentalRating bool) ApiGetVideocodecsRequest {
	r.hasParentalRating = &hasParentalRating
	return r
}

// Optional filter by items that are HD or not.
func (r ApiGetVideocodecsRequest) IsHD(isHD bool) ApiGetVideocodecsRequest {
	r.isHD = &isHD
	return r
}

// Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
func (r ApiGetVideocodecsRequest) LocationTypes(locationTypes string) ApiGetVideocodecsRequest {
	r.locationTypes = &locationTypes
	return r
}

// Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
func (r ApiGetVideocodecsRequest) ExcludeLocationTypes(excludeLocationTypes string) ApiGetVideocodecsRequest {
	r.excludeLocationTypes = &excludeLocationTypes
	return r
}

// Optional filter by items that are missing episodes or not.
func (r ApiGetVideocodecsRequest) IsMissing(isMissing bool) ApiGetVideocodecsRequest {
	r.isMissing = &isMissing
	return r
}

// Optional filter by items that are unaired episodes or not.
func (r ApiGetVideocodecsRequest) IsUnaired(isUnaired bool) ApiGetVideocodecsRequest {
	r.isUnaired = &isUnaired
	return r
}

// Optional filter by minimum community rating.
func (r ApiGetVideocodecsRequest) MinCommunityRating(minCommunityRating float64) ApiGetVideocodecsRequest {
	r.minCommunityRating = &minCommunityRating
	return r
}

// Optional filter by minimum critic rating.
func (r ApiGetVideocodecsRequest) MinCriticRating(minCriticRating float64) ApiGetVideocodecsRequest {
	r.minCriticRating = &minCriticRating
	return r
}

// Gets all episodes that aired during a season, including specials.
func (r ApiGetVideocodecsRequest) AiredDuringSeason(airedDuringSeason int32) ApiGetVideocodecsRequest {
	r.airedDuringSeason = &airedDuringSeason
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r ApiGetVideocodecsRequest) MinPremiereDate(minPremiereDate string) ApiGetVideocodecsRequest {
	r.minPremiereDate = &minPremiereDate
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r ApiGetVideocodecsRequest) MinDateLastSaved(minDateLastSaved string) ApiGetVideocodecsRequest {
	r.minDateLastSaved = &minDateLastSaved
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r ApiGetVideocodecsRequest) MinDateLastSavedForUser(minDateLastSavedForUser string) ApiGetVideocodecsRequest {
	r.minDateLastSavedForUser = &minDateLastSavedForUser
	return r
}

// Optional. The maximum premiere date. Format &#x3D; ISO
func (r ApiGetVideocodecsRequest) MaxPremiereDate(maxPremiereDate string) ApiGetVideocodecsRequest {
	r.maxPremiereDate = &maxPremiereDate
	return r
}

// Optional filter by items that have an overview or not.
func (r ApiGetVideocodecsRequest) HasOverview(hasOverview bool) ApiGetVideocodecsRequest {
	r.hasOverview = &hasOverview
	return r
}

// Optional filter by items that have an imdb id or not.
func (r ApiGetVideocodecsRequest) HasImdbId(hasImdbId bool) ApiGetVideocodecsRequest {
	r.hasImdbId = &hasImdbId
	return r
}

// Optional filter by items that have a tmdb id or not.
func (r ApiGetVideocodecsRequest) HasTmdbId(hasTmdbId bool) ApiGetVideocodecsRequest {
	r.hasTmdbId = &hasTmdbId
	return r
}

// Optional filter by items that have a tvdb id or not.
func (r ApiGetVideocodecsRequest) HasTvdbId(hasTvdbId bool) ApiGetVideocodecsRequest {
	r.hasTvdbId = &hasTvdbId
	return r
}

// Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
func (r ApiGetVideocodecsRequest) ExcludeItemIds(excludeItemIds string) ApiGetVideocodecsRequest {
	r.excludeItemIds = &excludeItemIds
	return r
}

// Optional. The record index to start at. All items with a lower index will be dropped from the results.
func (r ApiGetVideocodecsRequest) StartIndex(startIndex int32) ApiGetVideocodecsRequest {
	r.startIndex = &startIndex
	return r
}

// Optional. The maximum number of records to return
func (r ApiGetVideocodecsRequest) Limit(limit int32) ApiGetVideocodecsRequest {
	r.limit = &limit
	return r
}

// When searching within folders, this determines whether or not the search will be recursive. true/false
func (r ApiGetVideocodecsRequest) Recursive(recursive bool) ApiGetVideocodecsRequest {
	r.recursive = &recursive
	return r
}

// Sort Order - Ascending,Descending
func (r ApiGetVideocodecsRequest) SortOrder(sortOrder string) ApiGetVideocodecsRequest {
	r.sortOrder = &sortOrder
	return r
}

// Specify this to localize the search to a specific item or folder. Omit to use the root
func (r ApiGetVideocodecsRequest) ParentId(parentId string) ApiGetVideocodecsRequest {
	r.parentId = &parentId
	return r
}

// Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
func (r ApiGetVideocodecsRequest) Fields(fields string) ApiGetVideocodecsRequest {
	r.fields = &fields
	return r
}

// Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
func (r ApiGetVideocodecsRequest) ExcludeItemTypes(excludeItemTypes string) ApiGetVideocodecsRequest {
	r.excludeItemTypes = &excludeItemTypes
	return r
}

// Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
func (r ApiGetVideocodecsRequest) IncludeItemTypes(includeItemTypes string) ApiGetVideocodecsRequest {
	r.includeItemTypes = &includeItemTypes
	return r
}

// Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form &#39;prov.id&#39;, e.g. &#39;imdb.tt123456&#39;. This allows multiple, comma delimeted value pairs.
func (r ApiGetVideocodecsRequest) AnyProviderIdEquals(anyProviderIdEquals string) ApiGetVideocodecsRequest {
	r.anyProviderIdEquals = &anyProviderIdEquals
	return r
}

// Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
func (r ApiGetVideocodecsRequest) Filters(filters string) ApiGetVideocodecsRequest {
	r.filters = &filters
	return r
}

// Optional filter by items that are marked as favorite, or not.
func (r ApiGetVideocodecsRequest) IsFavorite(isFavorite bool) ApiGetVideocodecsRequest {
	r.isFavorite = &isFavorite
	return r
}

// Optional filter for movies.
func (r ApiGetVideocodecsRequest) IsMovie(isMovie bool) ApiGetVideocodecsRequest {
	r.isMovie = &isMovie
	return r
}

// Optional filter for movies.
func (r ApiGetVideocodecsRequest) IsSeries(isSeries bool) ApiGetVideocodecsRequest {
	r.isSeries = &isSeries
	return r
}

// Optional filter for news.
func (r ApiGetVideocodecsRequest) IsNews(isNews bool) ApiGetVideocodecsRequest {
	r.isNews = &isNews
	return r
}

// Optional filter for kids.
func (r ApiGetVideocodecsRequest) IsKids(isKids bool) ApiGetVideocodecsRequest {
	r.isKids = &isKids
	return r
}

// Optional filter for sports.
func (r ApiGetVideocodecsRequest) IsSports(isSports bool) ApiGetVideocodecsRequest {
	r.isSports = &isSports
	return r
}

// Optional filter by MediaType. Allows multiple, comma delimited.
func (r ApiGetVideocodecsRequest) MediaTypes(mediaTypes string) ApiGetVideocodecsRequest {
	r.mediaTypes = &mediaTypes
	return r
}

// Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
func (r ApiGetVideocodecsRequest) ImageTypes(imageTypes string) ApiGetVideocodecsRequest {
	r.imageTypes = &imageTypes
	return r
}

// Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
func (r ApiGetVideocodecsRequest) SortBy(sortBy string) ApiGetVideocodecsRequest {
	r.sortBy = &sortBy
	return r
}

// Optional filter by items that are played, or not.
func (r ApiGetVideocodecsRequest) IsPlayed(isPlayed bool) ApiGetVideocodecsRequest {
	r.isPlayed = &isPlayed
	return r
}

// Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
func (r ApiGetVideocodecsRequest) Genres(genres string) ApiGetVideocodecsRequest {
	r.genres = &genres
	return r
}

// Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
func (r ApiGetVideocodecsRequest) OfficialRatings(officialRatings string) ApiGetVideocodecsRequest {
	r.officialRatings = &officialRatings
	return r
}

// Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
func (r ApiGetVideocodecsRequest) Tags(tags string) ApiGetVideocodecsRequest {
	r.tags = &tags
	return r
}

// Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
func (r ApiGetVideocodecsRequest) Years(years string) ApiGetVideocodecsRequest {
	r.years = &years
	return r
}

// Optional, include image information in output
func (r ApiGetVideocodecsRequest) EnableImages(enableImages bool) ApiGetVideocodecsRequest {
	r.enableImages = &enableImages
	return r
}

// Optional, include user data
func (r ApiGetVideocodecsRequest) EnableUserData(enableUserData bool) ApiGetVideocodecsRequest {
	r.enableUserData = &enableUserData
	return r
}

// Optional, the max number of images to return, per image type
func (r ApiGetVideocodecsRequest) ImageTypeLimit(imageTypeLimit int32) ApiGetVideocodecsRequest {
	r.imageTypeLimit = &imageTypeLimit
	return r
}

// Optional. The image types to include in the output.
func (r ApiGetVideocodecsRequest) EnableImageTypes(enableImageTypes string) ApiGetVideocodecsRequest {
	r.enableImageTypes = &enableImageTypes
	return r
}

// Optional. If specified, results will be filtered to include only those containing the specified person.
func (r ApiGetVideocodecsRequest) Person(person string) ApiGetVideocodecsRequest {
	r.person = &person
	return r
}

// Optional. If specified, results will be filtered to include only those containing the specified person.
func (r ApiGetVideocodecsRequest) PersonIds(personIds string) ApiGetVideocodecsRequest {
	r.personIds = &personIds
	return r
}

// Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
func (r ApiGetVideocodecsRequest) PersonTypes(personTypes string) ApiGetVideocodecsRequest {
	r.personTypes = &personTypes
	return r
}

// Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
func (r ApiGetVideocodecsRequest) Studios(studios string) ApiGetVideocodecsRequest {
	r.studios = &studios
	return r
}

// Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
func (r ApiGetVideocodecsRequest) StudioIds(studioIds string) ApiGetVideocodecsRequest {
	r.studioIds = &studioIds
	return r
}

// Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
func (r ApiGetVideocodecsRequest) Artists(artists string) ApiGetVideocodecsRequest {
	r.artists = &artists
	return r
}

// Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
func (r ApiGetVideocodecsRequest) ArtistIds(artistIds string) ApiGetVideocodecsRequest {
	r.artistIds = &artistIds
	return r
}

// Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
func (r ApiGetVideocodecsRequest) Albums(albums string) ApiGetVideocodecsRequest {
	r.albums = &albums
	return r
}

// Optional. If specific items are needed, specify a list of item id&#39;s to retrieve. This allows multiple, comma delimited.
func (r ApiGetVideocodecsRequest) Ids(ids string) ApiGetVideocodecsRequest {
	r.ids = &ids
	return r
}

// Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
func (r ApiGetVideocodecsRequest) VideoTypes(videoTypes string) ApiGetVideocodecsRequest {
	r.videoTypes = &videoTypes
	return r
}

// Optional filter by Container. Allows multiple, comma delimeted.
func (r ApiGetVideocodecsRequest) Containers(containers string) ApiGetVideocodecsRequest {
	r.containers = &containers
	return r
}

// Optional filter by AudioCodec. Allows multiple, comma delimeted.
func (r ApiGetVideocodecsRequest) AudioCodecs(audioCodecs string) ApiGetVideocodecsRequest {
	r.audioCodecs = &audioCodecs
	return r
}

// Optional filter by VideoCodec. Allows multiple, comma delimeted.
func (r ApiGetVideocodecsRequest) VideoCodecs(videoCodecs string) ApiGetVideocodecsRequest {
	r.videoCodecs = &videoCodecs
	return r
}

// Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
func (r ApiGetVideocodecsRequest) SubtitleCodecs(subtitleCodecs string) ApiGetVideocodecsRequest {
	r.subtitleCodecs = &subtitleCodecs
	return r
}

// Optional filter by Path.
func (r ApiGetVideocodecsRequest) Path(path string) ApiGetVideocodecsRequest {
	r.path = &path
	return r
}

// User Id
func (r ApiGetVideocodecsRequest) UserId(userId string) ApiGetVideocodecsRequest {
	r.userId = &userId
	return r
}

// Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
func (r ApiGetVideocodecsRequest) MinOfficialRating(minOfficialRating string) ApiGetVideocodecsRequest {
	r.minOfficialRating = &minOfficialRating
	return r
}

// Optional filter by items that are locked.
func (r ApiGetVideocodecsRequest) IsLocked(isLocked bool) ApiGetVideocodecsRequest {
	r.isLocked = &isLocked
	return r
}

// Optional filter by items that are placeholders
func (r ApiGetVideocodecsRequest) IsPlaceHolder(isPlaceHolder bool) ApiGetVideocodecsRequest {
	r.isPlaceHolder = &isPlaceHolder
	return r
}

// Optional filter by items that have official ratings
func (r ApiGetVideocodecsRequest) HasOfficialRating(hasOfficialRating bool) ApiGetVideocodecsRequest {
	r.hasOfficialRating = &hasOfficialRating
	return r
}

// Whether or not to hide items behind their boxsets.
func (r ApiGetVideocodecsRequest) GroupItemsIntoCollections(groupItemsIntoCollections bool) ApiGetVideocodecsRequest {
	r.groupItemsIntoCollections = &groupItemsIntoCollections
	return r
}

// Optional filter by items that are 3D, or not.
func (r ApiGetVideocodecsRequest) Is3D(is3D bool) ApiGetVideocodecsRequest {
	r.is3D = &is3D
	return r
}

// Optional filter by Series Status. Allows multiple, comma delimeted.
func (r ApiGetVideocodecsRequest) SeriesStatus(seriesStatus string) ApiGetVideocodecsRequest {
	r.seriesStatus = &seriesStatus
	return r
}

// Optional filter by items whose name is sorted equally or greater than a given input string.
func (r ApiGetVideocodecsRequest) NameStartsWithOrGreater(nameStartsWithOrGreater string) ApiGetVideocodecsRequest {
	r.nameStartsWithOrGreater = &nameStartsWithOrGreater
	return r
}

// Optional filter by items whose name is sorted equally than a given input string.
func (r ApiGetVideocodecsRequest) NameStartsWith(nameStartsWith string) ApiGetVideocodecsRequest {
	r.nameStartsWith = &nameStartsWith
	return r
}

// Optional filter by items whose name is equally or lesser than a given input string.
func (r ApiGetVideocodecsRequest) NameLessThan(nameLessThan string) ApiGetVideocodecsRequest {
	r.nameLessThan = &nameLessThan
	return r
}

func (r ApiGetVideocodecsRequest) Execute() (*QueryResultUserLibraryTagItem, *http.Response, error) {
	return r.ApiService.GetVideocodecsExecute(r)
}

/*
GetVideocodecs Gets items based on a query.

No authentication required

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetVideocodecsRequest
*/
func (a *TagServiceAPIService) GetVideocodecs(ctx context.Context) ApiGetVideocodecsRequest {
	return ApiGetVideocodecsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return QueryResultUserLibraryTagItem
func (a *TagServiceAPIService) GetVideocodecsExecute(r ApiGetVideocodecsRequest) (*QueryResultUserLibraryTagItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QueryResultUserLibraryTagItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TagServiceAPIService.GetVideocodecs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/VideoCodecs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.artistType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ArtistType", r.artistType, "form", "")
	}
	if r.maxOfficialRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxOfficialRating", r.maxOfficialRating, "form", "")
	}
	if r.hasThemeSong != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasThemeSong", r.hasThemeSong, "form", "")
	}
	if r.hasThemeVideo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasThemeVideo", r.hasThemeVideo, "form", "")
	}
	if r.hasSubtitles != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasSubtitles", r.hasSubtitles, "form", "")
	}
	if r.hasSpecialFeature != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasSpecialFeature", r.hasSpecialFeature, "form", "")
	}
	if r.hasTrailer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasTrailer", r.hasTrailer, "form", "")
	}
	if r.adjacentTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AdjacentTo", r.adjacentTo, "form", "")
	}
	if r.minIndexNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinIndexNumber", r.minIndexNumber, "form", "")
	}
	if r.minPlayers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinPlayers", r.minPlayers, "form", "")
	}
	if r.maxPlayers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxPlayers", r.maxPlayers, "form", "")
	}
	if r.parentIndexNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ParentIndexNumber", r.parentIndexNumber, "form", "")
	}
	if r.hasParentalRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasParentalRating", r.hasParentalRating, "form", "")
	}
	if r.isHD != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsHD", r.isHD, "form", "")
	}
	if r.locationTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "LocationTypes", r.locationTypes, "form", "")
	}
	if r.excludeLocationTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ExcludeLocationTypes", r.excludeLocationTypes, "form", "")
	}
	if r.isMissing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsMissing", r.isMissing, "form", "")
	}
	if r.isUnaired != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsUnaired", r.isUnaired, "form", "")
	}
	if r.minCommunityRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinCommunityRating", r.minCommunityRating, "form", "")
	}
	if r.minCriticRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinCriticRating", r.minCriticRating, "form", "")
	}
	if r.airedDuringSeason != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AiredDuringSeason", r.airedDuringSeason, "form", "")
	}
	if r.minPremiereDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinPremiereDate", r.minPremiereDate, "form", "")
	}
	if r.minDateLastSaved != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinDateLastSaved", r.minDateLastSaved, "form", "")
	}
	if r.minDateLastSavedForUser != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinDateLastSavedForUser", r.minDateLastSavedForUser, "form", "")
	}
	if r.maxPremiereDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxPremiereDate", r.maxPremiereDate, "form", "")
	}
	if r.hasOverview != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasOverview", r.hasOverview, "form", "")
	}
	if r.hasImdbId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasImdbId", r.hasImdbId, "form", "")
	}
	if r.hasTmdbId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasTmdbId", r.hasTmdbId, "form", "")
	}
	if r.hasTvdbId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasTvdbId", r.hasTvdbId, "form", "")
	}
	if r.excludeItemIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ExcludeItemIds", r.excludeItemIds, "form", "")
	}
	if r.startIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "StartIndex", r.startIndex, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Limit", r.limit, "form", "")
	}
	if r.recursive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Recursive", r.recursive, "form", "")
	}
	if r.sortOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SortOrder", r.sortOrder, "form", "")
	}
	if r.parentId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ParentId", r.parentId, "form", "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Fields", r.fields, "form", "")
	}
	if r.excludeItemTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ExcludeItemTypes", r.excludeItemTypes, "form", "")
	}
	if r.includeItemTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IncludeItemTypes", r.includeItemTypes, "form", "")
	}
	if r.anyProviderIdEquals != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AnyProviderIdEquals", r.anyProviderIdEquals, "form", "")
	}
	if r.filters != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Filters", r.filters, "form", "")
	}
	if r.isFavorite != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsFavorite", r.isFavorite, "form", "")
	}
	if r.isMovie != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsMovie", r.isMovie, "form", "")
	}
	if r.isSeries != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsSeries", r.isSeries, "form", "")
	}
	if r.isNews != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsNews", r.isNews, "form", "")
	}
	if r.isKids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsKids", r.isKids, "form", "")
	}
	if r.isSports != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsSports", r.isSports, "form", "")
	}
	if r.mediaTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MediaTypes", r.mediaTypes, "form", "")
	}
	if r.imageTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ImageTypes", r.imageTypes, "form", "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SortBy", r.sortBy, "form", "")
	}
	if r.isPlayed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsPlayed", r.isPlayed, "form", "")
	}
	if r.genres != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Genres", r.genres, "form", "")
	}
	if r.officialRatings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "OfficialRatings", r.officialRatings, "form", "")
	}
	if r.tags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Tags", r.tags, "form", "")
	}
	if r.years != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Years", r.years, "form", "")
	}
	if r.enableImages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImages", r.enableImages, "form", "")
	}
	if r.enableUserData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableUserData", r.enableUserData, "form", "")
	}
	if r.imageTypeLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ImageTypeLimit", r.imageTypeLimit, "form", "")
	}
	if r.enableImageTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImageTypes", r.enableImageTypes, "form", "")
	}
	if r.person != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Person", r.person, "form", "")
	}
	if r.personIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "PersonIds", r.personIds, "form", "")
	}
	if r.personTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "PersonTypes", r.personTypes, "form", "")
	}
	if r.studios != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Studios", r.studios, "form", "")
	}
	if r.studioIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "StudioIds", r.studioIds, "form", "")
	}
	if r.artists != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Artists", r.artists, "form", "")
	}
	if r.artistIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ArtistIds", r.artistIds, "form", "")
	}
	if r.albums != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Albums", r.albums, "form", "")
	}
	if r.ids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Ids", r.ids, "form", "")
	}
	if r.videoTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "VideoTypes", r.videoTypes, "form", "")
	}
	if r.containers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Containers", r.containers, "form", "")
	}
	if r.audioCodecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AudioCodecs", r.audioCodecs, "form", "")
	}
	if r.videoCodecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "VideoCodecs", r.videoCodecs, "form", "")
	}
	if r.subtitleCodecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SubtitleCodecs", r.subtitleCodecs, "form", "")
	}
	if r.path != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Path", r.path, "form", "")
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "UserId", r.userId, "form", "")
	}
	if r.minOfficialRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinOfficialRating", r.minOfficialRating, "form", "")
	}
	if r.isLocked != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsLocked", r.isLocked, "form", "")
	}
	if r.isPlaceHolder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsPlaceHolder", r.isPlaceHolder, "form", "")
	}
	if r.hasOfficialRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasOfficialRating", r.hasOfficialRating, "form", "")
	}
	if r.groupItemsIntoCollections != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "GroupItemsIntoCollections", r.groupItemsIntoCollections, "form", "")
	}
	if r.is3D != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Is3D", r.is3D, "form", "")
	}
	if r.seriesStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SeriesStatus", r.seriesStatus, "form", "")
	}
	if r.nameStartsWithOrGreater != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "NameStartsWithOrGreater", r.nameStartsWithOrGreater, "form", "")
	}
	if r.nameStartsWith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "NameStartsWith", r.nameStartsWith, "form", "")
	}
	if r.nameLessThan != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "NameLessThan", r.nameLessThan, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetYearsRequest struct {
	ctx context.Context
	ApiService TagServiceAPI
	artistType *string
	maxOfficialRating *string
	hasThemeSong *bool
	hasThemeVideo *bool
	hasSubtitles *bool
	hasSpecialFeature *bool
	hasTrailer *bool
	adjacentTo *string
	minIndexNumber *int32
	minPlayers *int32
	maxPlayers *int32
	parentIndexNumber *int32
	hasParentalRating *bool
	isHD *bool
	locationTypes *string
	excludeLocationTypes *string
	isMissing *bool
	isUnaired *bool
	minCommunityRating *float64
	minCriticRating *float64
	airedDuringSeason *int32
	minPremiereDate *string
	minDateLastSaved *string
	minDateLastSavedForUser *string
	maxPremiereDate *string
	hasOverview *bool
	hasImdbId *bool
	hasTmdbId *bool
	hasTvdbId *bool
	excludeItemIds *string
	startIndex *int32
	limit *int32
	recursive *bool
	sortOrder *string
	parentId *string
	fields *string
	excludeItemTypes *string
	includeItemTypes *string
	anyProviderIdEquals *string
	filters *string
	isFavorite *bool
	isMovie *bool
	isSeries *bool
	isNews *bool
	isKids *bool
	isSports *bool
	mediaTypes *string
	imageTypes *string
	sortBy *string
	isPlayed *bool
	genres *string
	officialRatings *string
	tags *string
	years *string
	enableImages *bool
	enableUserData *bool
	imageTypeLimit *int32
	enableImageTypes *string
	person *string
	personIds *string
	personTypes *string
	studios *string
	studioIds *string
	artists *string
	artistIds *string
	albums *string
	ids *string
	videoTypes *string
	containers *string
	audioCodecs *string
	videoCodecs *string
	subtitleCodecs *string
	path *string
	userId *string
	minOfficialRating *string
	isLocked *bool
	isPlaceHolder *bool
	hasOfficialRating *bool
	groupItemsIntoCollections *bool
	is3D *bool
	seriesStatus *string
	nameStartsWithOrGreater *string
	nameStartsWith *string
	nameLessThan *string
}

// Artist or AlbumArtist
func (r ApiGetYearsRequest) ArtistType(artistType string) ApiGetYearsRequest {
	r.artistType = &artistType
	return r
}

// Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
func (r ApiGetYearsRequest) MaxOfficialRating(maxOfficialRating string) ApiGetYearsRequest {
	r.maxOfficialRating = &maxOfficialRating
	return r
}

// Optional filter by items with theme songs.
func (r ApiGetYearsRequest) HasThemeSong(hasThemeSong bool) ApiGetYearsRequest {
	r.hasThemeSong = &hasThemeSong
	return r
}

// Optional filter by items with theme videos.
func (r ApiGetYearsRequest) HasThemeVideo(hasThemeVideo bool) ApiGetYearsRequest {
	r.hasThemeVideo = &hasThemeVideo
	return r
}

// Optional filter by items with subtitles.
func (r ApiGetYearsRequest) HasSubtitles(hasSubtitles bool) ApiGetYearsRequest {
	r.hasSubtitles = &hasSubtitles
	return r
}

// Optional filter by items with special features.
func (r ApiGetYearsRequest) HasSpecialFeature(hasSpecialFeature bool) ApiGetYearsRequest {
	r.hasSpecialFeature = &hasSpecialFeature
	return r
}

// Optional filter by items with trailers.
func (r ApiGetYearsRequest) HasTrailer(hasTrailer bool) ApiGetYearsRequest {
	r.hasTrailer = &hasTrailer
	return r
}

// Optional. Return items that are siblings of a supplied item.
func (r ApiGetYearsRequest) AdjacentTo(adjacentTo string) ApiGetYearsRequest {
	r.adjacentTo = &adjacentTo
	return r
}

// Optional filter by minimum index number.
func (r ApiGetYearsRequest) MinIndexNumber(minIndexNumber int32) ApiGetYearsRequest {
	r.minIndexNumber = &minIndexNumber
	return r
}

// Optional filter by minimum number of game players.
func (r ApiGetYearsRequest) MinPlayers(minPlayers int32) ApiGetYearsRequest {
	r.minPlayers = &minPlayers
	return r
}

// Optional filter by maximum number of game players.
func (r ApiGetYearsRequest) MaxPlayers(maxPlayers int32) ApiGetYearsRequest {
	r.maxPlayers = &maxPlayers
	return r
}

// Optional filter by parent index number.
func (r ApiGetYearsRequest) ParentIndexNumber(parentIndexNumber int32) ApiGetYearsRequest {
	r.parentIndexNumber = &parentIndexNumber
	return r
}

// Optional filter by items that have or do not have a parental rating
func (r ApiGetYearsRequest) HasParentalRating(hasParentalRating bool) ApiGetYearsRequest {
	r.hasParentalRating = &hasParentalRating
	return r
}

// Optional filter by items that are HD or not.
func (r ApiGetYearsRequest) IsHD(isHD bool) ApiGetYearsRequest {
	r.isHD = &isHD
	return r
}

// Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
func (r ApiGetYearsRequest) LocationTypes(locationTypes string) ApiGetYearsRequest {
	r.locationTypes = &locationTypes
	return r
}

// Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
func (r ApiGetYearsRequest) ExcludeLocationTypes(excludeLocationTypes string) ApiGetYearsRequest {
	r.excludeLocationTypes = &excludeLocationTypes
	return r
}

// Optional filter by items that are missing episodes or not.
func (r ApiGetYearsRequest) IsMissing(isMissing bool) ApiGetYearsRequest {
	r.isMissing = &isMissing
	return r
}

// Optional filter by items that are unaired episodes or not.
func (r ApiGetYearsRequest) IsUnaired(isUnaired bool) ApiGetYearsRequest {
	r.isUnaired = &isUnaired
	return r
}

// Optional filter by minimum community rating.
func (r ApiGetYearsRequest) MinCommunityRating(minCommunityRating float64) ApiGetYearsRequest {
	r.minCommunityRating = &minCommunityRating
	return r
}

// Optional filter by minimum critic rating.
func (r ApiGetYearsRequest) MinCriticRating(minCriticRating float64) ApiGetYearsRequest {
	r.minCriticRating = &minCriticRating
	return r
}

// Gets all episodes that aired during a season, including specials.
func (r ApiGetYearsRequest) AiredDuringSeason(airedDuringSeason int32) ApiGetYearsRequest {
	r.airedDuringSeason = &airedDuringSeason
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r ApiGetYearsRequest) MinPremiereDate(minPremiereDate string) ApiGetYearsRequest {
	r.minPremiereDate = &minPremiereDate
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r ApiGetYearsRequest) MinDateLastSaved(minDateLastSaved string) ApiGetYearsRequest {
	r.minDateLastSaved = &minDateLastSaved
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO
func (r ApiGetYearsRequest) MinDateLastSavedForUser(minDateLastSavedForUser string) ApiGetYearsRequest {
	r.minDateLastSavedForUser = &minDateLastSavedForUser
	return r
}

// Optional. The maximum premiere date. Format &#x3D; ISO
func (r ApiGetYearsRequest) MaxPremiereDate(maxPremiereDate string) ApiGetYearsRequest {
	r.maxPremiereDate = &maxPremiereDate
	return r
}

// Optional filter by items that have an overview or not.
func (r ApiGetYearsRequest) HasOverview(hasOverview bool) ApiGetYearsRequest {
	r.hasOverview = &hasOverview
	return r
}

// Optional filter by items that have an imdb id or not.
func (r ApiGetYearsRequest) HasImdbId(hasImdbId bool) ApiGetYearsRequest {
	r.hasImdbId = &hasImdbId
	return r
}

// Optional filter by items that have a tmdb id or not.
func (r ApiGetYearsRequest) HasTmdbId(hasTmdbId bool) ApiGetYearsRequest {
	r.hasTmdbId = &hasTmdbId
	return r
}

// Optional filter by items that have a tvdb id or not.
func (r ApiGetYearsRequest) HasTvdbId(hasTvdbId bool) ApiGetYearsRequest {
	r.hasTvdbId = &hasTvdbId
	return r
}

// Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
func (r ApiGetYearsRequest) ExcludeItemIds(excludeItemIds string) ApiGetYearsRequest {
	r.excludeItemIds = &excludeItemIds
	return r
}

// Optional. The record index to start at. All items with a lower index will be dropped from the results.
func (r ApiGetYearsRequest) StartIndex(startIndex int32) ApiGetYearsRequest {
	r.startIndex = &startIndex
	return r
}

// Optional. The maximum number of records to return
func (r ApiGetYearsRequest) Limit(limit int32) ApiGetYearsRequest {
	r.limit = &limit
	return r
}

// When searching within folders, this determines whether or not the search will be recursive. true/false
func (r ApiGetYearsRequest) Recursive(recursive bool) ApiGetYearsRequest {
	r.recursive = &recursive
	return r
}

// Sort Order - Ascending,Descending
func (r ApiGetYearsRequest) SortOrder(sortOrder string) ApiGetYearsRequest {
	r.sortOrder = &sortOrder
	return r
}

// Specify this to localize the search to a specific item or folder. Omit to use the root
func (r ApiGetYearsRequest) ParentId(parentId string) ApiGetYearsRequest {
	r.parentId = &parentId
	return r
}

// Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
func (r ApiGetYearsRequest) Fields(fields string) ApiGetYearsRequest {
	r.fields = &fields
	return r
}

// Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
func (r ApiGetYearsRequest) ExcludeItemTypes(excludeItemTypes string) ApiGetYearsRequest {
	r.excludeItemTypes = &excludeItemTypes
	return r
}

// Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
func (r ApiGetYearsRequest) IncludeItemTypes(includeItemTypes string) ApiGetYearsRequest {
	r.includeItemTypes = &includeItemTypes
	return r
}

// Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form &#39;prov.id&#39;, e.g. &#39;imdb.tt123456&#39;. This allows multiple, comma delimeted value pairs.
func (r ApiGetYearsRequest) AnyProviderIdEquals(anyProviderIdEquals string) ApiGetYearsRequest {
	r.anyProviderIdEquals = &anyProviderIdEquals
	return r
}

// Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
func (r ApiGetYearsRequest) Filters(filters string) ApiGetYearsRequest {
	r.filters = &filters
	return r
}

// Optional filter by items that are marked as favorite, or not.
func (r ApiGetYearsRequest) IsFavorite(isFavorite bool) ApiGetYearsRequest {
	r.isFavorite = &isFavorite
	return r
}

// Optional filter for movies.
func (r ApiGetYearsRequest) IsMovie(isMovie bool) ApiGetYearsRequest {
	r.isMovie = &isMovie
	return r
}

// Optional filter for movies.
func (r ApiGetYearsRequest) IsSeries(isSeries bool) ApiGetYearsRequest {
	r.isSeries = &isSeries
	return r
}

// Optional filter for news.
func (r ApiGetYearsRequest) IsNews(isNews bool) ApiGetYearsRequest {
	r.isNews = &isNews
	return r
}

// Optional filter for kids.
func (r ApiGetYearsRequest) IsKids(isKids bool) ApiGetYearsRequest {
	r.isKids = &isKids
	return r
}

// Optional filter for sports.
func (r ApiGetYearsRequest) IsSports(isSports bool) ApiGetYearsRequest {
	r.isSports = &isSports
	return r
}

// Optional filter by MediaType. Allows multiple, comma delimited.
func (r ApiGetYearsRequest) MediaTypes(mediaTypes string) ApiGetYearsRequest {
	r.mediaTypes = &mediaTypes
	return r
}

// Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
func (r ApiGetYearsRequest) ImageTypes(imageTypes string) ApiGetYearsRequest {
	r.imageTypes = &imageTypes
	return r
}

// Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
func (r ApiGetYearsRequest) SortBy(sortBy string) ApiGetYearsRequest {
	r.sortBy = &sortBy
	return r
}

// Optional filter by items that are played, or not.
func (r ApiGetYearsRequest) IsPlayed(isPlayed bool) ApiGetYearsRequest {
	r.isPlayed = &isPlayed
	return r
}

// Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
func (r ApiGetYearsRequest) Genres(genres string) ApiGetYearsRequest {
	r.genres = &genres
	return r
}

// Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
func (r ApiGetYearsRequest) OfficialRatings(officialRatings string) ApiGetYearsRequest {
	r.officialRatings = &officialRatings
	return r
}

// Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
func (r ApiGetYearsRequest) Tags(tags string) ApiGetYearsRequest {
	r.tags = &tags
	return r
}

// Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
func (r ApiGetYearsRequest) Years(years string) ApiGetYearsRequest {
	r.years = &years
	return r
}

// Optional, include image information in output
func (r ApiGetYearsRequest) EnableImages(enableImages bool) ApiGetYearsRequest {
	r.enableImages = &enableImages
	return r
}

// Optional, include user data
func (r ApiGetYearsRequest) EnableUserData(enableUserData bool) ApiGetYearsRequest {
	r.enableUserData = &enableUserData
	return r
}

// Optional, the max number of images to return, per image type
func (r ApiGetYearsRequest) ImageTypeLimit(imageTypeLimit int32) ApiGetYearsRequest {
	r.imageTypeLimit = &imageTypeLimit
	return r
}

// Optional. The image types to include in the output.
func (r ApiGetYearsRequest) EnableImageTypes(enableImageTypes string) ApiGetYearsRequest {
	r.enableImageTypes = &enableImageTypes
	return r
}

// Optional. If specified, results will be filtered to include only those containing the specified person.
func (r ApiGetYearsRequest) Person(person string) ApiGetYearsRequest {
	r.person = &person
	return r
}

// Optional. If specified, results will be filtered to include only those containing the specified person.
func (r ApiGetYearsRequest) PersonIds(personIds string) ApiGetYearsRequest {
	r.personIds = &personIds
	return r
}

// Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
func (r ApiGetYearsRequest) PersonTypes(personTypes string) ApiGetYearsRequest {
	r.personTypes = &personTypes
	return r
}

// Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
func (r ApiGetYearsRequest) Studios(studios string) ApiGetYearsRequest {
	r.studios = &studios
	return r
}

// Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
func (r ApiGetYearsRequest) StudioIds(studioIds string) ApiGetYearsRequest {
	r.studioIds = &studioIds
	return r
}

// Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
func (r ApiGetYearsRequest) Artists(artists string) ApiGetYearsRequest {
	r.artists = &artists
	return r
}

// Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
func (r ApiGetYearsRequest) ArtistIds(artistIds string) ApiGetYearsRequest {
	r.artistIds = &artistIds
	return r
}

// Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
func (r ApiGetYearsRequest) Albums(albums string) ApiGetYearsRequest {
	r.albums = &albums
	return r
}

// Optional. If specific items are needed, specify a list of item id&#39;s to retrieve. This allows multiple, comma delimited.
func (r ApiGetYearsRequest) Ids(ids string) ApiGetYearsRequest {
	r.ids = &ids
	return r
}

// Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
func (r ApiGetYearsRequest) VideoTypes(videoTypes string) ApiGetYearsRequest {
	r.videoTypes = &videoTypes
	return r
}

// Optional filter by Container. Allows multiple, comma delimeted.
func (r ApiGetYearsRequest) Containers(containers string) ApiGetYearsRequest {
	r.containers = &containers
	return r
}

// Optional filter by AudioCodec. Allows multiple, comma delimeted.
func (r ApiGetYearsRequest) AudioCodecs(audioCodecs string) ApiGetYearsRequest {
	r.audioCodecs = &audioCodecs
	return r
}

// Optional filter by VideoCodec. Allows multiple, comma delimeted.
func (r ApiGetYearsRequest) VideoCodecs(videoCodecs string) ApiGetYearsRequest {
	r.videoCodecs = &videoCodecs
	return r
}

// Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
func (r ApiGetYearsRequest) SubtitleCodecs(subtitleCodecs string) ApiGetYearsRequest {
	r.subtitleCodecs = &subtitleCodecs
	return r
}

// Optional filter by Path.
func (r ApiGetYearsRequest) Path(path string) ApiGetYearsRequest {
	r.path = &path
	return r
}

// User Id
func (r ApiGetYearsRequest) UserId(userId string) ApiGetYearsRequest {
	r.userId = &userId
	return r
}

// Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
func (r ApiGetYearsRequest) MinOfficialRating(minOfficialRating string) ApiGetYearsRequest {
	r.minOfficialRating = &minOfficialRating
	return r
}

// Optional filter by items that are locked.
func (r ApiGetYearsRequest) IsLocked(isLocked bool) ApiGetYearsRequest {
	r.isLocked = &isLocked
	return r
}

// Optional filter by items that are placeholders
func (r ApiGetYearsRequest) IsPlaceHolder(isPlaceHolder bool) ApiGetYearsRequest {
	r.isPlaceHolder = &isPlaceHolder
	return r
}

// Optional filter by items that have official ratings
func (r ApiGetYearsRequest) HasOfficialRating(hasOfficialRating bool) ApiGetYearsRequest {
	r.hasOfficialRating = &hasOfficialRating
	return r
}

// Whether or not to hide items behind their boxsets.
func (r ApiGetYearsRequest) GroupItemsIntoCollections(groupItemsIntoCollections bool) ApiGetYearsRequest {
	r.groupItemsIntoCollections = &groupItemsIntoCollections
	return r
}

// Optional filter by items that are 3D, or not.
func (r ApiGetYearsRequest) Is3D(is3D bool) ApiGetYearsRequest {
	r.is3D = &is3D
	return r
}

// Optional filter by Series Status. Allows multiple, comma delimeted.
func (r ApiGetYearsRequest) SeriesStatus(seriesStatus string) ApiGetYearsRequest {
	r.seriesStatus = &seriesStatus
	return r
}

// Optional filter by items whose name is sorted equally or greater than a given input string.
func (r ApiGetYearsRequest) NameStartsWithOrGreater(nameStartsWithOrGreater string) ApiGetYearsRequest {
	r.nameStartsWithOrGreater = &nameStartsWithOrGreater
	return r
}

// Optional filter by items whose name is sorted equally than a given input string.
func (r ApiGetYearsRequest) NameStartsWith(nameStartsWith string) ApiGetYearsRequest {
	r.nameStartsWith = &nameStartsWith
	return r
}

// Optional filter by items whose name is equally or lesser than a given input string.
func (r ApiGetYearsRequest) NameLessThan(nameLessThan string) ApiGetYearsRequest {
	r.nameLessThan = &nameLessThan
	return r
}

func (r ApiGetYearsRequest) Execute() (*QueryResultUserLibraryTagItem, *http.Response, error) {
	return r.ApiService.GetYearsExecute(r)
}

/*
GetYears Gets items based on a query.

No authentication required

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetYearsRequest
*/
func (a *TagServiceAPIService) GetYears(ctx context.Context) ApiGetYearsRequest {
	return ApiGetYearsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return QueryResultUserLibraryTagItem
func (a *TagServiceAPIService) GetYearsExecute(r ApiGetYearsRequest) (*QueryResultUserLibraryTagItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QueryResultUserLibraryTagItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TagServiceAPIService.GetYears")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Years"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.artistType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ArtistType", r.artistType, "form", "")
	}
	if r.maxOfficialRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxOfficialRating", r.maxOfficialRating, "form", "")
	}
	if r.hasThemeSong != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasThemeSong", r.hasThemeSong, "form", "")
	}
	if r.hasThemeVideo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasThemeVideo", r.hasThemeVideo, "form", "")
	}
	if r.hasSubtitles != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasSubtitles", r.hasSubtitles, "form", "")
	}
	if r.hasSpecialFeature != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasSpecialFeature", r.hasSpecialFeature, "form", "")
	}
	if r.hasTrailer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasTrailer", r.hasTrailer, "form", "")
	}
	if r.adjacentTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AdjacentTo", r.adjacentTo, "form", "")
	}
	if r.minIndexNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinIndexNumber", r.minIndexNumber, "form", "")
	}
	if r.minPlayers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinPlayers", r.minPlayers, "form", "")
	}
	if r.maxPlayers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxPlayers", r.maxPlayers, "form", "")
	}
	if r.parentIndexNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ParentIndexNumber", r.parentIndexNumber, "form", "")
	}
	if r.hasParentalRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasParentalRating", r.hasParentalRating, "form", "")
	}
	if r.isHD != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsHD", r.isHD, "form", "")
	}
	if r.locationTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "LocationTypes", r.locationTypes, "form", "")
	}
	if r.excludeLocationTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ExcludeLocationTypes", r.excludeLocationTypes, "form", "")
	}
	if r.isMissing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsMissing", r.isMissing, "form", "")
	}
	if r.isUnaired != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsUnaired", r.isUnaired, "form", "")
	}
	if r.minCommunityRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinCommunityRating", r.minCommunityRating, "form", "")
	}
	if r.minCriticRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinCriticRating", r.minCriticRating, "form", "")
	}
	if r.airedDuringSeason != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AiredDuringSeason", r.airedDuringSeason, "form", "")
	}
	if r.minPremiereDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinPremiereDate", r.minPremiereDate, "form", "")
	}
	if r.minDateLastSaved != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinDateLastSaved", r.minDateLastSaved, "form", "")
	}
	if r.minDateLastSavedForUser != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinDateLastSavedForUser", r.minDateLastSavedForUser, "form", "")
	}
	if r.maxPremiereDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxPremiereDate", r.maxPremiereDate, "form", "")
	}
	if r.hasOverview != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasOverview", r.hasOverview, "form", "")
	}
	if r.hasImdbId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasImdbId", r.hasImdbId, "form", "")
	}
	if r.hasTmdbId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasTmdbId", r.hasTmdbId, "form", "")
	}
	if r.hasTvdbId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasTvdbId", r.hasTvdbId, "form", "")
	}
	if r.excludeItemIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ExcludeItemIds", r.excludeItemIds, "form", "")
	}
	if r.startIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "StartIndex", r.startIndex, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Limit", r.limit, "form", "")
	}
	if r.recursive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Recursive", r.recursive, "form", "")
	}
	if r.sortOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SortOrder", r.sortOrder, "form", "")
	}
	if r.parentId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ParentId", r.parentId, "form", "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Fields", r.fields, "form", "")
	}
	if r.excludeItemTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ExcludeItemTypes", r.excludeItemTypes, "form", "")
	}
	if r.includeItemTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IncludeItemTypes", r.includeItemTypes, "form", "")
	}
	if r.anyProviderIdEquals != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AnyProviderIdEquals", r.anyProviderIdEquals, "form", "")
	}
	if r.filters != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Filters", r.filters, "form", "")
	}
	if r.isFavorite != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsFavorite", r.isFavorite, "form", "")
	}
	if r.isMovie != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsMovie", r.isMovie, "form", "")
	}
	if r.isSeries != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsSeries", r.isSeries, "form", "")
	}
	if r.isNews != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsNews", r.isNews, "form", "")
	}
	if r.isKids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsKids", r.isKids, "form", "")
	}
	if r.isSports != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsSports", r.isSports, "form", "")
	}
	if r.mediaTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MediaTypes", r.mediaTypes, "form", "")
	}
	if r.imageTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ImageTypes", r.imageTypes, "form", "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SortBy", r.sortBy, "form", "")
	}
	if r.isPlayed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsPlayed", r.isPlayed, "form", "")
	}
	if r.genres != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Genres", r.genres, "form", "")
	}
	if r.officialRatings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "OfficialRatings", r.officialRatings, "form", "")
	}
	if r.tags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Tags", r.tags, "form", "")
	}
	if r.years != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Years", r.years, "form", "")
	}
	if r.enableImages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImages", r.enableImages, "form", "")
	}
	if r.enableUserData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableUserData", r.enableUserData, "form", "")
	}
	if r.imageTypeLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ImageTypeLimit", r.imageTypeLimit, "form", "")
	}
	if r.enableImageTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EnableImageTypes", r.enableImageTypes, "form", "")
	}
	if r.person != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Person", r.person, "form", "")
	}
	if r.personIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "PersonIds", r.personIds, "form", "")
	}
	if r.personTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "PersonTypes", r.personTypes, "form", "")
	}
	if r.studios != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Studios", r.studios, "form", "")
	}
	if r.studioIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "StudioIds", r.studioIds, "form", "")
	}
	if r.artists != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Artists", r.artists, "form", "")
	}
	if r.artistIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ArtistIds", r.artistIds, "form", "")
	}
	if r.albums != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Albums", r.albums, "form", "")
	}
	if r.ids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Ids", r.ids, "form", "")
	}
	if r.videoTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "VideoTypes", r.videoTypes, "form", "")
	}
	if r.containers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Containers", r.containers, "form", "")
	}
	if r.audioCodecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AudioCodecs", r.audioCodecs, "form", "")
	}
	if r.videoCodecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "VideoCodecs", r.videoCodecs, "form", "")
	}
	if r.subtitleCodecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SubtitleCodecs", r.subtitleCodecs, "form", "")
	}
	if r.path != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Path", r.path, "form", "")
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "UserId", r.userId, "form", "")
	}
	if r.minOfficialRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MinOfficialRating", r.minOfficialRating, "form", "")
	}
	if r.isLocked != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsLocked", r.isLocked, "form", "")
	}
	if r.isPlaceHolder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsPlaceHolder", r.isPlaceHolder, "form", "")
	}
	if r.hasOfficialRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "HasOfficialRating", r.hasOfficialRating, "form", "")
	}
	if r.groupItemsIntoCollections != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "GroupItemsIntoCollections", r.groupItemsIntoCollections, "form", "")
	}
	if r.is3D != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Is3D", r.is3D, "form", "")
	}
	if r.seriesStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SeriesStatus", r.seriesStatus, "form", "")
	}
	if r.nameStartsWithOrGreater != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "NameStartsWithOrGreater", r.nameStartsWithOrGreater, "form", "")
	}
	if r.nameStartsWith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "NameStartsWith", r.nameStartsWith, "form", "")
	}
	if r.nameLessThan != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "NameLessThan", r.nameLessThan, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
