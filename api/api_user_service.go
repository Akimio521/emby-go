/*
Emby Server API

Explore the Emby Server API

API version: 4.1.1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package api

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


type UserServiceAPI interface {

	/*
	DeleteUsersById Deletes a user

	Requires authentication as administrator

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiDeleteUsersByIdRequest
	*/
	DeleteUsersById(ctx context.Context, id string) ApiDeleteUsersByIdRequest

	// DeleteUsersByIdExecute executes the request
	DeleteUsersByIdExecute(r ApiDeleteUsersByIdRequest) (*http.Response, error)

	/*
	GetUsers Gets a list of users

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetUsersRequest
	*/
	GetUsers(ctx context.Context) ApiGetUsersRequest

	// GetUsersExecute executes the request
	//  @return []UserDto
	GetUsersExecute(r ApiGetUsersRequest) ([]UserDto, *http.Response, error)

	/*
	GetUsersById Gets a user by Id

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiGetUsersByIdRequest
	*/
	GetUsersById(ctx context.Context, id string) ApiGetUsersByIdRequest

	// GetUsersByIdExecute executes the request
	//  @return UserDto
	GetUsersByIdExecute(r ApiGetUsersByIdRequest) (*UserDto, *http.Response, error)

	/*
	GetUsersPublic Gets a list of publicly visible users for display on a login screen.

	No authentication required

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetUsersPublicRequest
	*/
	GetUsersPublic(ctx context.Context) ApiGetUsersPublicRequest

	// GetUsersPublicExecute executes the request
	//  @return []UserDto
	GetUsersPublicExecute(r ApiGetUsersPublicRequest) ([]UserDto, *http.Response, error)

	/*
	PostUsersAuthenticatebyname Authenticates a user

	Authenticate a user by nane and password. A 200 status code indicates success, while anything in the 400 or 500 range indicates failure
---
No authentication required

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostUsersAuthenticatebynameRequest
	*/
	PostUsersAuthenticatebyname(ctx context.Context) ApiPostUsersAuthenticatebynameRequest

	// PostUsersAuthenticatebynameExecute executes the request
	//  @return AuthenticationAuthenticationResult
	PostUsersAuthenticatebynameExecute(r ApiPostUsersAuthenticatebynameRequest) (*AuthenticationAuthenticationResult, *http.Response, error)

	/*
	PostUsersById Updates a user

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiPostUsersByIdRequest
	*/
	PostUsersById(ctx context.Context, id string) ApiPostUsersByIdRequest

	// PostUsersByIdExecute executes the request
	PostUsersByIdExecute(r ApiPostUsersByIdRequest) (*http.Response, error)

	/*
	PostUsersByIdAuthenticate Authenticates a user

	No authentication required

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiPostUsersByIdAuthenticateRequest
	*/
	PostUsersByIdAuthenticate(ctx context.Context, id string) ApiPostUsersByIdAuthenticateRequest

	// PostUsersByIdAuthenticateExecute executes the request
	//  @return AuthenticationAuthenticationResult
	PostUsersByIdAuthenticateExecute(r ApiPostUsersByIdAuthenticateRequest) (*AuthenticationAuthenticationResult, *http.Response, error)

	/*
	PostUsersByIdConfiguration Updates a user configuration

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiPostUsersByIdConfigurationRequest
	*/
	PostUsersByIdConfiguration(ctx context.Context, id string) ApiPostUsersByIdConfigurationRequest

	// PostUsersByIdConfigurationExecute executes the request
	PostUsersByIdConfigurationExecute(r ApiPostUsersByIdConfigurationRequest) (*http.Response, error)

	/*
	PostUsersByIdEasypassword Updates a user's easy password

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiPostUsersByIdEasypasswordRequest
	*/
	PostUsersByIdEasypassword(ctx context.Context, id string) ApiPostUsersByIdEasypasswordRequest

	// PostUsersByIdEasypasswordExecute executes the request
	PostUsersByIdEasypasswordExecute(r ApiPostUsersByIdEasypasswordRequest) (*http.Response, error)

	/*
	PostUsersByIdPassword Updates a user's password

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiPostUsersByIdPasswordRequest
	*/
	PostUsersByIdPassword(ctx context.Context, id string) ApiPostUsersByIdPasswordRequest

	// PostUsersByIdPasswordExecute executes the request
	PostUsersByIdPasswordExecute(r ApiPostUsersByIdPasswordRequest) (*http.Response, error)

	/*
	PostUsersByIdPolicy Updates a user policy

	Requires authentication as administrator

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiPostUsersByIdPolicyRequest
	*/
	PostUsersByIdPolicy(ctx context.Context, id string) ApiPostUsersByIdPolicyRequest

	// PostUsersByIdPolicyExecute executes the request
	PostUsersByIdPolicyExecute(r ApiPostUsersByIdPolicyRequest) (*http.Response, error)

	/*
	PostUsersForgotpassword Initiates the forgot password process for a local user

	No authentication required

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostUsersForgotpasswordRequest
	*/
	PostUsersForgotpassword(ctx context.Context) ApiPostUsersForgotpasswordRequest

	// PostUsersForgotpasswordExecute executes the request
	//  @return UsersForgotPasswordResult
	PostUsersForgotpasswordExecute(r ApiPostUsersForgotpasswordRequest) (*UsersForgotPasswordResult, *http.Response, error)

	/*
	PostUsersForgotpasswordPin Redeems a forgot password pin

	No authentication required

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostUsersForgotpasswordPinRequest
	*/
	PostUsersForgotpasswordPin(ctx context.Context) ApiPostUsersForgotpasswordPinRequest

	// PostUsersForgotpasswordPinExecute executes the request
	//  @return UsersPinRedeemResult
	PostUsersForgotpasswordPinExecute(r ApiPostUsersForgotpasswordPinRequest) (*UsersPinRedeemResult, *http.Response, error)

	/*
	PostUsersNew Creates a user

	Requires authentication as administrator

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostUsersNewRequest
	*/
	PostUsersNew(ctx context.Context) ApiPostUsersNewRequest

	// PostUsersNewExecute executes the request
	//  @return UserDto
	PostUsersNewExecute(r ApiPostUsersNewRequest) (*UserDto, *http.Response, error)
}

// UserServiceAPIService UserServiceAPI service
type UserServiceAPIService service

type ApiDeleteUsersByIdRequest struct {
	ctx context.Context
	ApiService UserServiceAPI
	id string
}

func (r ApiDeleteUsersByIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteUsersByIdExecute(r)
}

/*
DeleteUsersById Deletes a user

Requires authentication as administrator

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiDeleteUsersByIdRequest
*/
func (a *UserServiceAPIService) DeleteUsersById(ctx context.Context, id string) ApiDeleteUsersByIdRequest {
	return ApiDeleteUsersByIdRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *UserServiceAPIService) DeleteUsersByIdExecute(r ApiDeleteUsersByIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserServiceAPIService.DeleteUsersById")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Users/{Id}"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetUsersRequest struct {
	ctx context.Context
	ApiService UserServiceAPI
	isHidden *bool
	isDisabled *bool
}

// Optional filter by IsHidden&#x3D;true or false
func (r ApiGetUsersRequest) IsHidden(isHidden bool) ApiGetUsersRequest {
	r.isHidden = &isHidden
	return r
}

// Optional filter by IsDisabled&#x3D;true or false
func (r ApiGetUsersRequest) IsDisabled(isDisabled bool) ApiGetUsersRequest {
	r.isDisabled = &isDisabled
	return r
}

func (r ApiGetUsersRequest) Execute() ([]UserDto, *http.Response, error) {
	return r.ApiService.GetUsersExecute(r)
}

/*
GetUsers Gets a list of users

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetUsersRequest
*/
func (a *UserServiceAPIService) GetUsers(ctx context.Context) ApiGetUsersRequest {
	return ApiGetUsersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []UserDto
func (a *UserServiceAPIService) GetUsersExecute(r ApiGetUsersRequest) ([]UserDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UserDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserServiceAPIService.GetUsers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Users"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.isHidden != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsHidden", r.isHidden, "form", "")
	}
	if r.isDisabled != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsDisabled", r.isDisabled, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUsersByIdRequest struct {
	ctx context.Context
	ApiService UserServiceAPI
	id string
}

func (r ApiGetUsersByIdRequest) Execute() (*UserDto, *http.Response, error) {
	return r.ApiService.GetUsersByIdExecute(r)
}

/*
GetUsersById Gets a user by Id

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiGetUsersByIdRequest
*/
func (a *UserServiceAPIService) GetUsersById(ctx context.Context, id string) ApiGetUsersByIdRequest {
	return ApiGetUsersByIdRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return UserDto
func (a *UserServiceAPIService) GetUsersByIdExecute(r ApiGetUsersByIdRequest) (*UserDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UserDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserServiceAPIService.GetUsersById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Users/{Id}"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUsersPublicRequest struct {
	ctx context.Context
	ApiService UserServiceAPI
}

func (r ApiGetUsersPublicRequest) Execute() ([]UserDto, *http.Response, error) {
	return r.ApiService.GetUsersPublicExecute(r)
}

/*
GetUsersPublic Gets a list of publicly visible users for display on a login screen.

No authentication required

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetUsersPublicRequest
*/
func (a *UserServiceAPIService) GetUsersPublic(ctx context.Context) ApiGetUsersPublicRequest {
	return ApiGetUsersPublicRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []UserDto
func (a *UserServiceAPIService) GetUsersPublicExecute(r ApiGetUsersPublicRequest) ([]UserDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UserDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserServiceAPIService.GetUsersPublic")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Users/Public"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostUsersAuthenticatebynameRequest struct {
	ctx context.Context
	ApiService UserServiceAPI
	xEmbyAuthorization *string
	authenticateUserByName *AuthenticateUserByName
}

// The authorization header can be either named &#39;Authorization&#39; or &#39;X-Emby-Authorization&#39;.    It must be of the following schema:     Emby UserId&#x3D;\&quot;(guid)\&quot;, Client&#x3D;\&quot;(string)\&quot;, Device&#x3D;\&quot;(string)\&quot;, DeviceId&#x3D;\&quot;(string)\&quot;, Version&#x3D;\&quot;string\&quot;, Token&#x3D;\&quot;(string)\&quot;     Please consult the documentation for further details.
func (r ApiPostUsersAuthenticatebynameRequest) XEmbyAuthorization(xEmbyAuthorization string) ApiPostUsersAuthenticatebynameRequest {
	r.xEmbyAuthorization = &xEmbyAuthorization
	return r
}

// AuthenticateUserByName
func (r ApiPostUsersAuthenticatebynameRequest) AuthenticateUserByName(authenticateUserByName AuthenticateUserByName) ApiPostUsersAuthenticatebynameRequest {
	r.authenticateUserByName = &authenticateUserByName
	return r
}

func (r ApiPostUsersAuthenticatebynameRequest) Execute() (*AuthenticationAuthenticationResult, *http.Response, error) {
	return r.ApiService.PostUsersAuthenticatebynameExecute(r)
}

/*
PostUsersAuthenticatebyname Authenticates a user

Authenticate a user by nane and password. A 200 status code indicates success, while anything in the 400 or 500 range indicates failure
---
No authentication required

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostUsersAuthenticatebynameRequest
*/
func (a *UserServiceAPIService) PostUsersAuthenticatebyname(ctx context.Context) ApiPostUsersAuthenticatebynameRequest {
	return ApiPostUsersAuthenticatebynameRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AuthenticationAuthenticationResult
func (a *UserServiceAPIService) PostUsersAuthenticatebynameExecute(r ApiPostUsersAuthenticatebynameRequest) (*AuthenticationAuthenticationResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AuthenticationAuthenticationResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserServiceAPIService.PostUsersAuthenticatebyname")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Users/AuthenticateByName"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xEmbyAuthorization == nil {
		return localVarReturnValue, nil, reportError("xEmbyAuthorization is required and must be specified")
	}
	if r.authenticateUserByName == nil {
		return localVarReturnValue, nil, reportError("authenticateUserByName is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Emby-Authorization", r.xEmbyAuthorization, "simple", "")
	// body params
	localVarPostBody = r.authenticateUserByName
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostUsersByIdRequest struct {
	ctx context.Context
	ApiService UserServiceAPI
	id string
	userDto *UserDto
}

// UserDto: 
func (r ApiPostUsersByIdRequest) UserDto(userDto UserDto) ApiPostUsersByIdRequest {
	r.userDto = &userDto
	return r
}

func (r ApiPostUsersByIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostUsersByIdExecute(r)
}

/*
PostUsersById Updates a user

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiPostUsersByIdRequest
*/
func (a *UserServiceAPIService) PostUsersById(ctx context.Context, id string) ApiPostUsersByIdRequest {
	return ApiPostUsersByIdRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *UserServiceAPIService) PostUsersByIdExecute(r ApiPostUsersByIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserServiceAPIService.PostUsersById")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Users/{Id}"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.userDto == nil {
		return nil, reportError("userDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.userDto
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostUsersByIdAuthenticateRequest struct {
	ctx context.Context
	ApiService UserServiceAPI
	id string
	authenticateUser *AuthenticateUser
}

// AuthenticateUser
func (r ApiPostUsersByIdAuthenticateRequest) AuthenticateUser(authenticateUser AuthenticateUser) ApiPostUsersByIdAuthenticateRequest {
	r.authenticateUser = &authenticateUser
	return r
}

func (r ApiPostUsersByIdAuthenticateRequest) Execute() (*AuthenticationAuthenticationResult, *http.Response, error) {
	return r.ApiService.PostUsersByIdAuthenticateExecute(r)
}

/*
PostUsersByIdAuthenticate Authenticates a user

No authentication required

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiPostUsersByIdAuthenticateRequest
*/
func (a *UserServiceAPIService) PostUsersByIdAuthenticate(ctx context.Context, id string) ApiPostUsersByIdAuthenticateRequest {
	return ApiPostUsersByIdAuthenticateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return AuthenticationAuthenticationResult
func (a *UserServiceAPIService) PostUsersByIdAuthenticateExecute(r ApiPostUsersByIdAuthenticateRequest) (*AuthenticationAuthenticationResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AuthenticationAuthenticationResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserServiceAPIService.PostUsersByIdAuthenticate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Users/{Id}/Authenticate"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authenticateUser == nil {
		return localVarReturnValue, nil, reportError("authenticateUser is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.authenticateUser
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostUsersByIdConfigurationRequest struct {
	ctx context.Context
	ApiService UserServiceAPI
	id string
	configurationUserConfiguration *ConfigurationUserConfiguration
}

// UserConfiguration: 
func (r ApiPostUsersByIdConfigurationRequest) ConfigurationUserConfiguration(configurationUserConfiguration ConfigurationUserConfiguration) ApiPostUsersByIdConfigurationRequest {
	r.configurationUserConfiguration = &configurationUserConfiguration
	return r
}

func (r ApiPostUsersByIdConfigurationRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostUsersByIdConfigurationExecute(r)
}

/*
PostUsersByIdConfiguration Updates a user configuration

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiPostUsersByIdConfigurationRequest
*/
func (a *UserServiceAPIService) PostUsersByIdConfiguration(ctx context.Context, id string) ApiPostUsersByIdConfigurationRequest {
	return ApiPostUsersByIdConfigurationRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *UserServiceAPIService) PostUsersByIdConfigurationExecute(r ApiPostUsersByIdConfigurationRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserServiceAPIService.PostUsersByIdConfiguration")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Users/{Id}/Configuration"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.configurationUserConfiguration == nil {
		return nil, reportError("configurationUserConfiguration is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.configurationUserConfiguration
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostUsersByIdEasypasswordRequest struct {
	ctx context.Context
	ApiService UserServiceAPI
	id string
	updateUserEasyPassword *UpdateUserEasyPassword
}

// UpdateUserEasyPassword
func (r ApiPostUsersByIdEasypasswordRequest) UpdateUserEasyPassword(updateUserEasyPassword UpdateUserEasyPassword) ApiPostUsersByIdEasypasswordRequest {
	r.updateUserEasyPassword = &updateUserEasyPassword
	return r
}

func (r ApiPostUsersByIdEasypasswordRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostUsersByIdEasypasswordExecute(r)
}

/*
PostUsersByIdEasypassword Updates a user's easy password

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiPostUsersByIdEasypasswordRequest
*/
func (a *UserServiceAPIService) PostUsersByIdEasypassword(ctx context.Context, id string) ApiPostUsersByIdEasypasswordRequest {
	return ApiPostUsersByIdEasypasswordRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *UserServiceAPIService) PostUsersByIdEasypasswordExecute(r ApiPostUsersByIdEasypasswordRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserServiceAPIService.PostUsersByIdEasypassword")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Users/{Id}/EasyPassword"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateUserEasyPassword == nil {
		return nil, reportError("updateUserEasyPassword is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateUserEasyPassword
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostUsersByIdPasswordRequest struct {
	ctx context.Context
	ApiService UserServiceAPI
	id string
	updateUserPassword *UpdateUserPassword
}

// UpdateUserPassword
func (r ApiPostUsersByIdPasswordRequest) UpdateUserPassword(updateUserPassword UpdateUserPassword) ApiPostUsersByIdPasswordRequest {
	r.updateUserPassword = &updateUserPassword
	return r
}

func (r ApiPostUsersByIdPasswordRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostUsersByIdPasswordExecute(r)
}

/*
PostUsersByIdPassword Updates a user's password

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiPostUsersByIdPasswordRequest
*/
func (a *UserServiceAPIService) PostUsersByIdPassword(ctx context.Context, id string) ApiPostUsersByIdPasswordRequest {
	return ApiPostUsersByIdPasswordRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *UserServiceAPIService) PostUsersByIdPasswordExecute(r ApiPostUsersByIdPasswordRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserServiceAPIService.PostUsersByIdPassword")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Users/{Id}/Password"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateUserPassword == nil {
		return nil, reportError("updateUserPassword is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateUserPassword
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostUsersByIdPolicyRequest struct {
	ctx context.Context
	ApiService UserServiceAPI
	id string
	usersUserPolicy *UsersUserPolicy
}

// UserPolicy: 
func (r ApiPostUsersByIdPolicyRequest) UsersUserPolicy(usersUserPolicy UsersUserPolicy) ApiPostUsersByIdPolicyRequest {
	r.usersUserPolicy = &usersUserPolicy
	return r
}

func (r ApiPostUsersByIdPolicyRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostUsersByIdPolicyExecute(r)
}

/*
PostUsersByIdPolicy Updates a user policy

Requires authentication as administrator

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiPostUsersByIdPolicyRequest
*/
func (a *UserServiceAPIService) PostUsersByIdPolicy(ctx context.Context, id string) ApiPostUsersByIdPolicyRequest {
	return ApiPostUsersByIdPolicyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *UserServiceAPIService) PostUsersByIdPolicyExecute(r ApiPostUsersByIdPolicyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserServiceAPIService.PostUsersByIdPolicy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Users/{Id}/Policy"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.usersUserPolicy == nil {
		return nil, reportError("usersUserPolicy is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.usersUserPolicy
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostUsersForgotpasswordRequest struct {
	ctx context.Context
	ApiService UserServiceAPI
	forgotPassword *ForgotPassword
}

// ForgotPassword
func (r ApiPostUsersForgotpasswordRequest) ForgotPassword(forgotPassword ForgotPassword) ApiPostUsersForgotpasswordRequest {
	r.forgotPassword = &forgotPassword
	return r
}

func (r ApiPostUsersForgotpasswordRequest) Execute() (*UsersForgotPasswordResult, *http.Response, error) {
	return r.ApiService.PostUsersForgotpasswordExecute(r)
}

/*
PostUsersForgotpassword Initiates the forgot password process for a local user

No authentication required

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostUsersForgotpasswordRequest
*/
func (a *UserServiceAPIService) PostUsersForgotpassword(ctx context.Context) ApiPostUsersForgotpasswordRequest {
	return ApiPostUsersForgotpasswordRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UsersForgotPasswordResult
func (a *UserServiceAPIService) PostUsersForgotpasswordExecute(r ApiPostUsersForgotpasswordRequest) (*UsersForgotPasswordResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UsersForgotPasswordResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserServiceAPIService.PostUsersForgotpassword")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Users/ForgotPassword"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.forgotPassword == nil {
		return localVarReturnValue, nil, reportError("forgotPassword is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.forgotPassword
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostUsersForgotpasswordPinRequest struct {
	ctx context.Context
	ApiService UserServiceAPI
	forgotPasswordPin *ForgotPasswordPin
}

// ForgotPasswordPin
func (r ApiPostUsersForgotpasswordPinRequest) ForgotPasswordPin(forgotPasswordPin ForgotPasswordPin) ApiPostUsersForgotpasswordPinRequest {
	r.forgotPasswordPin = &forgotPasswordPin
	return r
}

func (r ApiPostUsersForgotpasswordPinRequest) Execute() (*UsersPinRedeemResult, *http.Response, error) {
	return r.ApiService.PostUsersForgotpasswordPinExecute(r)
}

/*
PostUsersForgotpasswordPin Redeems a forgot password pin

No authentication required

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostUsersForgotpasswordPinRequest
*/
func (a *UserServiceAPIService) PostUsersForgotpasswordPin(ctx context.Context) ApiPostUsersForgotpasswordPinRequest {
	return ApiPostUsersForgotpasswordPinRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UsersPinRedeemResult
func (a *UserServiceAPIService) PostUsersForgotpasswordPinExecute(r ApiPostUsersForgotpasswordPinRequest) (*UsersPinRedeemResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UsersPinRedeemResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserServiceAPIService.PostUsersForgotpasswordPin")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Users/ForgotPassword/Pin"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.forgotPasswordPin == nil {
		return localVarReturnValue, nil, reportError("forgotPasswordPin is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.forgotPasswordPin
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostUsersNewRequest struct {
	ctx context.Context
	ApiService UserServiceAPI
	createUserByName *CreateUserByName
}

// CreateUserByName
func (r ApiPostUsersNewRequest) CreateUserByName(createUserByName CreateUserByName) ApiPostUsersNewRequest {
	r.createUserByName = &createUserByName
	return r
}

func (r ApiPostUsersNewRequest) Execute() (*UserDto, *http.Response, error) {
	return r.ApiService.PostUsersNewExecute(r)
}

/*
PostUsersNew Creates a user

Requires authentication as administrator

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostUsersNewRequest
*/
func (a *UserServiceAPIService) PostUsersNew(ctx context.Context) ApiPostUsersNewRequest {
	return ApiPostUsersNewRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UserDto
func (a *UserServiceAPIService) PostUsersNewExecute(r ApiPostUsersNewRequest) (*UserDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UserDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserServiceAPIService.PostUsersNew")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Users/New"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createUserByName == nil {
		return localVarReturnValue, nil, reportError("createUserByName is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createUserByName
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
