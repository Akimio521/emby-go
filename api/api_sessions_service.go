/*
Emby Server API

Explore the Emby Server API

API version: 4.1.1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package api

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


type SessionsServiceAPI interface {

	/*
	DeleteAuthKeysByKey Method for DeleteAuthKeysByKey

	Requires authentication as administrator

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param key Auth Key
	@return ApiDeleteAuthKeysByKeyRequest
	*/
	DeleteAuthKeysByKey(ctx context.Context, key string) ApiDeleteAuthKeysByKeyRequest

	// DeleteAuthKeysByKeyExecute executes the request
	DeleteAuthKeysByKeyExecute(r ApiDeleteAuthKeysByKeyRequest) (*http.Response, error)

	/*
	DeleteSessionsByIdUsersByUserid Removes an additional user from a session

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Session Id
	@param userId UserId Id
	@return ApiDeleteSessionsByIdUsersByUseridRequest
	*/
	DeleteSessionsByIdUsersByUserid(ctx context.Context, id string, userId string) ApiDeleteSessionsByIdUsersByUseridRequest

	// DeleteSessionsByIdUsersByUseridExecute executes the request
	DeleteSessionsByIdUsersByUseridExecute(r ApiDeleteSessionsByIdUsersByUseridRequest) (*http.Response, error)

	/*
	GetAuthKeys Method for GetAuthKeys

	Requires authentication as administrator

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetAuthKeysRequest
	*/
	GetAuthKeys(ctx context.Context) ApiGetAuthKeysRequest

	// GetAuthKeysExecute executes the request
	GetAuthKeysExecute(r ApiGetAuthKeysRequest) (*http.Response, error)

	/*
	GetAuthProviders Method for GetAuthProviders

	Requires authentication as administrator

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetAuthProvidersRequest
	*/
	GetAuthProviders(ctx context.Context) ApiGetAuthProvidersRequest

	// GetAuthProvidersExecute executes the request
	//  @return []NameIdPair
	GetAuthProvidersExecute(r ApiGetAuthProvidersRequest) ([]NameIdPair, *http.Response, error)

	/*
	GetSessions Gets a list of sessions

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetSessionsRequest
	*/
	GetSessions(ctx context.Context) ApiGetSessionsRequest

	// GetSessionsExecute executes the request
	//  @return []SessionSessionInfo
	GetSessionsExecute(r ApiGetSessionsRequest) ([]SessionSessionInfo, *http.Response, error)

	/*
	PostAuthKeys Method for PostAuthKeys

	Requires authentication as administrator

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostAuthKeysRequest
	*/
	PostAuthKeys(ctx context.Context) ApiPostAuthKeysRequest

	// PostAuthKeysExecute executes the request
	PostAuthKeysExecute(r ApiPostAuthKeysRequest) (*http.Response, error)

	/*
	PostSessionsByIdCommand Issues a system command to a client

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Session Id
	@return ApiPostSessionsByIdCommandRequest
	*/
	PostSessionsByIdCommand(ctx context.Context, id string) ApiPostSessionsByIdCommandRequest

	// PostSessionsByIdCommandExecute executes the request
	PostSessionsByIdCommandExecute(r ApiPostSessionsByIdCommandRequest) (*http.Response, error)

	/*
	PostSessionsByIdCommandByCommand Issues a system command to a client

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Session Id
	@param command The command to send.
	@return ApiPostSessionsByIdCommandByCommandRequest
	*/
	PostSessionsByIdCommandByCommand(ctx context.Context, id string, command string) ApiPostSessionsByIdCommandByCommandRequest

	// PostSessionsByIdCommandByCommandExecute executes the request
	PostSessionsByIdCommandByCommandExecute(r ApiPostSessionsByIdCommandByCommandRequest) (*http.Response, error)

	/*
	PostSessionsByIdMessage Issues a command to a client to display a message to the user

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Session Id
	@return ApiPostSessionsByIdMessageRequest
	*/
	PostSessionsByIdMessage(ctx context.Context, id string) ApiPostSessionsByIdMessageRequest

	// PostSessionsByIdMessageExecute executes the request
	PostSessionsByIdMessageExecute(r ApiPostSessionsByIdMessageRequest) (*http.Response, error)

	/*
	PostSessionsByIdPlaying Instructs a session to play an item

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Session Id
	@return ApiPostSessionsByIdPlayingRequest
	*/
	PostSessionsByIdPlaying(ctx context.Context, id string) ApiPostSessionsByIdPlayingRequest

	// PostSessionsByIdPlayingExecute executes the request
	PostSessionsByIdPlayingExecute(r ApiPostSessionsByIdPlayingRequest) (*http.Response, error)

	/*
	PostSessionsByIdPlayingByCommand Issues a playstate command to a client

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Session Id
	@param command
	@return ApiPostSessionsByIdPlayingByCommandRequest
	*/
	PostSessionsByIdPlayingByCommand(ctx context.Context, id string, command string) ApiPostSessionsByIdPlayingByCommandRequest

	// PostSessionsByIdPlayingByCommandExecute executes the request
	PostSessionsByIdPlayingByCommandExecute(r ApiPostSessionsByIdPlayingByCommandRequest) (*http.Response, error)

	/*
	PostSessionsByIdSystemByCommand Issues a system command to a client

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Session Id
	@param command The command to send.
	@return ApiPostSessionsByIdSystemByCommandRequest
	*/
	PostSessionsByIdSystemByCommand(ctx context.Context, id string, command string) ApiPostSessionsByIdSystemByCommandRequest

	// PostSessionsByIdSystemByCommandExecute executes the request
	PostSessionsByIdSystemByCommandExecute(r ApiPostSessionsByIdSystemByCommandRequest) (*http.Response, error)

	/*
	PostSessionsByIdUsersByUserid Adds an additional user to a session

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Session Id
	@param userId UserId Id
	@return ApiPostSessionsByIdUsersByUseridRequest
	*/
	PostSessionsByIdUsersByUserid(ctx context.Context, id string, userId string) ApiPostSessionsByIdUsersByUseridRequest

	// PostSessionsByIdUsersByUseridExecute executes the request
	PostSessionsByIdUsersByUseridExecute(r ApiPostSessionsByIdUsersByUseridRequest) (*http.Response, error)

	/*
	PostSessionsByIdViewing Instructs a session to browse to an item or view

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Session Id
	@return ApiPostSessionsByIdViewingRequest
	*/
	PostSessionsByIdViewing(ctx context.Context, id string) ApiPostSessionsByIdViewingRequest

	// PostSessionsByIdViewingExecute executes the request
	PostSessionsByIdViewingExecute(r ApiPostSessionsByIdViewingRequest) (*http.Response, error)

	/*
	PostSessionsCapabilities Updates capabilities for a device

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostSessionsCapabilitiesRequest
	*/
	PostSessionsCapabilities(ctx context.Context) ApiPostSessionsCapabilitiesRequest

	// PostSessionsCapabilitiesExecute executes the request
	PostSessionsCapabilitiesExecute(r ApiPostSessionsCapabilitiesRequest) (*http.Response, error)

	/*
	PostSessionsCapabilitiesFull Updates capabilities for a device

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostSessionsCapabilitiesFullRequest
	*/
	PostSessionsCapabilitiesFull(ctx context.Context) ApiPostSessionsCapabilitiesFullRequest

	// PostSessionsCapabilitiesFullExecute executes the request
	PostSessionsCapabilitiesFullExecute(r ApiPostSessionsCapabilitiesFullRequest) (*http.Response, error)

	/*
	PostSessionsLogout Reports that a session has ended

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostSessionsLogoutRequest
	*/
	PostSessionsLogout(ctx context.Context) ApiPostSessionsLogoutRequest

	// PostSessionsLogoutExecute executes the request
	PostSessionsLogoutExecute(r ApiPostSessionsLogoutRequest) (*http.Response, error)
}

// SessionsServiceAPIService SessionsServiceAPI service
type SessionsServiceAPIService service

type ApiDeleteAuthKeysByKeyRequest struct {
	ctx context.Context
	ApiService SessionsServiceAPI
	key string
}

func (r ApiDeleteAuthKeysByKeyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteAuthKeysByKeyExecute(r)
}

/*
DeleteAuthKeysByKey Method for DeleteAuthKeysByKey

Requires authentication as administrator

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param key Auth Key
 @return ApiDeleteAuthKeysByKeyRequest
*/
func (a *SessionsServiceAPIService) DeleteAuthKeysByKey(ctx context.Context, key string) ApiDeleteAuthKeysByKeyRequest {
	return ApiDeleteAuthKeysByKeyRequest{
		ApiService: a,
		ctx: ctx,
		key: key,
	}
}

// Execute executes the request
func (a *SessionsServiceAPIService) DeleteAuthKeysByKeyExecute(r ApiDeleteAuthKeysByKeyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SessionsServiceAPIService.DeleteAuthKeysByKey")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Auth/Keys/{Key}"
	localVarPath = strings.Replace(localVarPath, "{"+"Key"+"}", url.PathEscape(parameterValueToString(r.key, "key")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteSessionsByIdUsersByUseridRequest struct {
	ctx context.Context
	ApiService SessionsServiceAPI
	id string
	userId string
}

func (r ApiDeleteSessionsByIdUsersByUseridRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteSessionsByIdUsersByUseridExecute(r)
}

/*
DeleteSessionsByIdUsersByUserid Removes an additional user from a session

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Session Id
 @param userId UserId Id
 @return ApiDeleteSessionsByIdUsersByUseridRequest
*/
func (a *SessionsServiceAPIService) DeleteSessionsByIdUsersByUserid(ctx context.Context, id string, userId string) ApiDeleteSessionsByIdUsersByUseridRequest {
	return ApiDeleteSessionsByIdUsersByUseridRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		userId: userId,
	}
}

// Execute executes the request
func (a *SessionsServiceAPIService) DeleteSessionsByIdUsersByUseridExecute(r ApiDeleteSessionsByIdUsersByUseridRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SessionsServiceAPIService.DeleteSessionsByIdUsersByUserid")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Sessions/{Id}/Users/{UserId}"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"UserId"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetAuthKeysRequest struct {
	ctx context.Context
	ApiService SessionsServiceAPI
}

func (r ApiGetAuthKeysRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetAuthKeysExecute(r)
}

/*
GetAuthKeys Method for GetAuthKeys

Requires authentication as administrator

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAuthKeysRequest
*/
func (a *SessionsServiceAPIService) GetAuthKeys(ctx context.Context) ApiGetAuthKeysRequest {
	return ApiGetAuthKeysRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SessionsServiceAPIService) GetAuthKeysExecute(r ApiGetAuthKeysRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SessionsServiceAPIService.GetAuthKeys")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Auth/Keys"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetAuthProvidersRequest struct {
	ctx context.Context
	ApiService SessionsServiceAPI
}

func (r ApiGetAuthProvidersRequest) Execute() ([]NameIdPair, *http.Response, error) {
	return r.ApiService.GetAuthProvidersExecute(r)
}

/*
GetAuthProviders Method for GetAuthProviders

Requires authentication as administrator

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAuthProvidersRequest
*/
func (a *SessionsServiceAPIService) GetAuthProviders(ctx context.Context) ApiGetAuthProvidersRequest {
	return ApiGetAuthProvidersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []NameIdPair
func (a *SessionsServiceAPIService) GetAuthProvidersExecute(r ApiGetAuthProvidersRequest) ([]NameIdPair, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []NameIdPair
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SessionsServiceAPIService.GetAuthProviders")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Auth/Providers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSessionsRequest struct {
	ctx context.Context
	ApiService SessionsServiceAPI
	controllableByUserId *string
	deviceId *string
}

// Optional. Filter by sessions that a given user is allowed to remote control.
func (r ApiGetSessionsRequest) ControllableByUserId(controllableByUserId string) ApiGetSessionsRequest {
	r.controllableByUserId = &controllableByUserId
	return r
}

// Optional. Filter by device id.
func (r ApiGetSessionsRequest) DeviceId(deviceId string) ApiGetSessionsRequest {
	r.deviceId = &deviceId
	return r
}

func (r ApiGetSessionsRequest) Execute() ([]SessionSessionInfo, *http.Response, error) {
	return r.ApiService.GetSessionsExecute(r)
}

/*
GetSessions Gets a list of sessions

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSessionsRequest
*/
func (a *SessionsServiceAPIService) GetSessions(ctx context.Context) ApiGetSessionsRequest {
	return ApiGetSessionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []SessionSessionInfo
func (a *SessionsServiceAPIService) GetSessionsExecute(r ApiGetSessionsRequest) ([]SessionSessionInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SessionSessionInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SessionsServiceAPIService.GetSessions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Sessions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.controllableByUserId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ControllableByUserId", r.controllableByUserId, "form", "")
	}
	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "DeviceId", r.deviceId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostAuthKeysRequest struct {
	ctx context.Context
	ApiService SessionsServiceAPI
	app *string
}

// App
func (r ApiPostAuthKeysRequest) App(app string) ApiPostAuthKeysRequest {
	r.app = &app
	return r
}

func (r ApiPostAuthKeysRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostAuthKeysExecute(r)
}

/*
PostAuthKeys Method for PostAuthKeys

Requires authentication as administrator

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostAuthKeysRequest
*/
func (a *SessionsServiceAPIService) PostAuthKeys(ctx context.Context) ApiPostAuthKeysRequest {
	return ApiPostAuthKeysRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SessionsServiceAPIService) PostAuthKeysExecute(r ApiPostAuthKeysRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SessionsServiceAPIService.PostAuthKeys")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Auth/Keys"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.app == nil {
		return nil, reportError("app is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "App", r.app, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostSessionsByIdCommandRequest struct {
	ctx context.Context
	ApiService SessionsServiceAPI
	id string
	generalCommand *GeneralCommand
}

// GeneralCommand: 
func (r ApiPostSessionsByIdCommandRequest) GeneralCommand(generalCommand GeneralCommand) ApiPostSessionsByIdCommandRequest {
	r.generalCommand = &generalCommand
	return r
}

func (r ApiPostSessionsByIdCommandRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostSessionsByIdCommandExecute(r)
}

/*
PostSessionsByIdCommand Issues a system command to a client

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Session Id
 @return ApiPostSessionsByIdCommandRequest
*/
func (a *SessionsServiceAPIService) PostSessionsByIdCommand(ctx context.Context, id string) ApiPostSessionsByIdCommandRequest {
	return ApiPostSessionsByIdCommandRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *SessionsServiceAPIService) PostSessionsByIdCommandExecute(r ApiPostSessionsByIdCommandRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SessionsServiceAPIService.PostSessionsByIdCommand")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Sessions/{Id}/Command"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.generalCommand == nil {
		return nil, reportError("generalCommand is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.generalCommand
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostSessionsByIdCommandByCommandRequest struct {
	ctx context.Context
	ApiService SessionsServiceAPI
	id string
	command string
}

func (r ApiPostSessionsByIdCommandByCommandRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostSessionsByIdCommandByCommandExecute(r)
}

/*
PostSessionsByIdCommandByCommand Issues a system command to a client

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Session Id
 @param command The command to send.
 @return ApiPostSessionsByIdCommandByCommandRequest
*/
func (a *SessionsServiceAPIService) PostSessionsByIdCommandByCommand(ctx context.Context, id string, command string) ApiPostSessionsByIdCommandByCommandRequest {
	return ApiPostSessionsByIdCommandByCommandRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		command: command,
	}
}

// Execute executes the request
func (a *SessionsServiceAPIService) PostSessionsByIdCommandByCommandExecute(r ApiPostSessionsByIdCommandByCommandRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SessionsServiceAPIService.PostSessionsByIdCommandByCommand")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Sessions/{Id}/Command/{Command}"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Command"+"}", url.PathEscape(parameterValueToString(r.command, "command")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostSessionsByIdMessageRequest struct {
	ctx context.Context
	ApiService SessionsServiceAPI
	id string
	text *string
	header *string
	timeoutMs *int64
}

// The message text.
func (r ApiPostSessionsByIdMessageRequest) Text(text string) ApiPostSessionsByIdMessageRequest {
	r.text = &text
	return r
}

// The message header.
func (r ApiPostSessionsByIdMessageRequest) Header(header string) ApiPostSessionsByIdMessageRequest {
	r.header = &header
	return r
}

// The message timeout. If omitted the user will have to confirm viewing the message.
func (r ApiPostSessionsByIdMessageRequest) TimeoutMs(timeoutMs int64) ApiPostSessionsByIdMessageRequest {
	r.timeoutMs = &timeoutMs
	return r
}

func (r ApiPostSessionsByIdMessageRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostSessionsByIdMessageExecute(r)
}

/*
PostSessionsByIdMessage Issues a command to a client to display a message to the user

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Session Id
 @return ApiPostSessionsByIdMessageRequest
*/
func (a *SessionsServiceAPIService) PostSessionsByIdMessage(ctx context.Context, id string) ApiPostSessionsByIdMessageRequest {
	return ApiPostSessionsByIdMessageRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *SessionsServiceAPIService) PostSessionsByIdMessageExecute(r ApiPostSessionsByIdMessageRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SessionsServiceAPIService.PostSessionsByIdMessage")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Sessions/{Id}/Message"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.text == nil {
		return nil, reportError("text is required and must be specified")
	}
	if r.header == nil {
		return nil, reportError("header is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "Text", r.text, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "Header", r.header, "form", "")
	if r.timeoutMs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "TimeoutMs", r.timeoutMs, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostSessionsByIdPlayingRequest struct {
	ctx context.Context
	ApiService SessionsServiceAPI
	id string
	itemIds *[]int64
	playCommand *string
	playRequest *PlayRequest
	startPositionTicks *int64
}

// The ids of the items to play, comma delimited
func (r ApiPostSessionsByIdPlayingRequest) ItemIds(itemIds []int64) ApiPostSessionsByIdPlayingRequest {
	r.itemIds = &itemIds
	return r
}

// The type of play command to issue (PlayNow, PlayNext, PlayLast). Clients who have not yet implemented play next and play last may play now.
func (r ApiPostSessionsByIdPlayingRequest) PlayCommand(playCommand string) ApiPostSessionsByIdPlayingRequest {
	r.playCommand = &playCommand
	return r
}

// PlayRequest: 
func (r ApiPostSessionsByIdPlayingRequest) PlayRequest(playRequest PlayRequest) ApiPostSessionsByIdPlayingRequest {
	r.playRequest = &playRequest
	return r
}

// The starting position of the first item.
func (r ApiPostSessionsByIdPlayingRequest) StartPositionTicks(startPositionTicks int64) ApiPostSessionsByIdPlayingRequest {
	r.startPositionTicks = &startPositionTicks
	return r
}

func (r ApiPostSessionsByIdPlayingRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostSessionsByIdPlayingExecute(r)
}

/*
PostSessionsByIdPlaying Instructs a session to play an item

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Session Id
 @return ApiPostSessionsByIdPlayingRequest
*/
func (a *SessionsServiceAPIService) PostSessionsByIdPlaying(ctx context.Context, id string) ApiPostSessionsByIdPlayingRequest {
	return ApiPostSessionsByIdPlayingRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *SessionsServiceAPIService) PostSessionsByIdPlayingExecute(r ApiPostSessionsByIdPlayingRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SessionsServiceAPIService.PostSessionsByIdPlaying")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Sessions/{Id}/Playing"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.itemIds == nil {
		return nil, reportError("itemIds is required and must be specified")
	}
	if r.playCommand == nil {
		return nil, reportError("playCommand is required and must be specified")
	}
	if r.playRequest == nil {
		return nil, reportError("playRequest is required and must be specified")
	}

	{
		t := *r.itemIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ItemIds", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ItemIds", t, "form", "multi")
		}
	}
	if r.startPositionTicks != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "StartPositionTicks", r.startPositionTicks, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "PlayCommand", r.playCommand, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.playRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostSessionsByIdPlayingByCommandRequest struct {
	ctx context.Context
	ApiService SessionsServiceAPI
	id string
	command string
	playstateRequest *PlaystateRequest
}

// PlaystateRequest: 
func (r ApiPostSessionsByIdPlayingByCommandRequest) PlaystateRequest(playstateRequest PlaystateRequest) ApiPostSessionsByIdPlayingByCommandRequest {
	r.playstateRequest = &playstateRequest
	return r
}

func (r ApiPostSessionsByIdPlayingByCommandRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostSessionsByIdPlayingByCommandExecute(r)
}

/*
PostSessionsByIdPlayingByCommand Issues a playstate command to a client

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Session Id
 @param command
 @return ApiPostSessionsByIdPlayingByCommandRequest
*/
func (a *SessionsServiceAPIService) PostSessionsByIdPlayingByCommand(ctx context.Context, id string, command string) ApiPostSessionsByIdPlayingByCommandRequest {
	return ApiPostSessionsByIdPlayingByCommandRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		command: command,
	}
}

// Execute executes the request
func (a *SessionsServiceAPIService) PostSessionsByIdPlayingByCommandExecute(r ApiPostSessionsByIdPlayingByCommandRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SessionsServiceAPIService.PostSessionsByIdPlayingByCommand")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Sessions/{Id}/Playing/{Command}"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Command"+"}", url.PathEscape(parameterValueToString(r.command, "command")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.playstateRequest == nil {
		return nil, reportError("playstateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.playstateRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostSessionsByIdSystemByCommandRequest struct {
	ctx context.Context
	ApiService SessionsServiceAPI
	id string
	command string
}

func (r ApiPostSessionsByIdSystemByCommandRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostSessionsByIdSystemByCommandExecute(r)
}

/*
PostSessionsByIdSystemByCommand Issues a system command to a client

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Session Id
 @param command The command to send.
 @return ApiPostSessionsByIdSystemByCommandRequest
*/
func (a *SessionsServiceAPIService) PostSessionsByIdSystemByCommand(ctx context.Context, id string, command string) ApiPostSessionsByIdSystemByCommandRequest {
	return ApiPostSessionsByIdSystemByCommandRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		command: command,
	}
}

// Execute executes the request
func (a *SessionsServiceAPIService) PostSessionsByIdSystemByCommandExecute(r ApiPostSessionsByIdSystemByCommandRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SessionsServiceAPIService.PostSessionsByIdSystemByCommand")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Sessions/{Id}/System/{Command}"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Command"+"}", url.PathEscape(parameterValueToString(r.command, "command")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostSessionsByIdUsersByUseridRequest struct {
	ctx context.Context
	ApiService SessionsServiceAPI
	id string
	userId string
}

func (r ApiPostSessionsByIdUsersByUseridRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostSessionsByIdUsersByUseridExecute(r)
}

/*
PostSessionsByIdUsersByUserid Adds an additional user to a session

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Session Id
 @param userId UserId Id
 @return ApiPostSessionsByIdUsersByUseridRequest
*/
func (a *SessionsServiceAPIService) PostSessionsByIdUsersByUserid(ctx context.Context, id string, userId string) ApiPostSessionsByIdUsersByUseridRequest {
	return ApiPostSessionsByIdUsersByUseridRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		userId: userId,
	}
}

// Execute executes the request
func (a *SessionsServiceAPIService) PostSessionsByIdUsersByUseridExecute(r ApiPostSessionsByIdUsersByUseridRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SessionsServiceAPIService.PostSessionsByIdUsersByUserid")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Sessions/{Id}/Users/{UserId}"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"UserId"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostSessionsByIdViewingRequest struct {
	ctx context.Context
	ApiService SessionsServiceAPI
	id string
	itemType *string
	itemId *string
	itemName *string
}

// The type of item to browse to.
func (r ApiPostSessionsByIdViewingRequest) ItemType(itemType string) ApiPostSessionsByIdViewingRequest {
	r.itemType = &itemType
	return r
}

// The Id of the item.
func (r ApiPostSessionsByIdViewingRequest) ItemId(itemId string) ApiPostSessionsByIdViewingRequest {
	r.itemId = &itemId
	return r
}

// The name of the item.
func (r ApiPostSessionsByIdViewingRequest) ItemName(itemName string) ApiPostSessionsByIdViewingRequest {
	r.itemName = &itemName
	return r
}

func (r ApiPostSessionsByIdViewingRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostSessionsByIdViewingExecute(r)
}

/*
PostSessionsByIdViewing Instructs a session to browse to an item or view

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Session Id
 @return ApiPostSessionsByIdViewingRequest
*/
func (a *SessionsServiceAPIService) PostSessionsByIdViewing(ctx context.Context, id string) ApiPostSessionsByIdViewingRequest {
	return ApiPostSessionsByIdViewingRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *SessionsServiceAPIService) PostSessionsByIdViewingExecute(r ApiPostSessionsByIdViewingRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SessionsServiceAPIService.PostSessionsByIdViewing")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Sessions/{Id}/Viewing"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.itemType == nil {
		return nil, reportError("itemType is required and must be specified")
	}
	if r.itemId == nil {
		return nil, reportError("itemId is required and must be specified")
	}
	if r.itemName == nil {
		return nil, reportError("itemName is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "ItemType", r.itemType, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "ItemId", r.itemId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "ItemName", r.itemName, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostSessionsCapabilitiesRequest struct {
	ctx context.Context
	ApiService SessionsServiceAPI
	id *string
	playableMediaTypes *string
	supportedCommands *string
	supportsMediaControl *bool
	supportsSync *bool
	supportsPersistentIdentifier *bool
}

// Session Id
func (r ApiPostSessionsCapabilitiesRequest) Id(id string) ApiPostSessionsCapabilitiesRequest {
	r.id = &id
	return r
}

// A list of playable media types, comma delimited. Audio, Video, Book, Game, Photo.
func (r ApiPostSessionsCapabilitiesRequest) PlayableMediaTypes(playableMediaTypes string) ApiPostSessionsCapabilitiesRequest {
	r.playableMediaTypes = &playableMediaTypes
	return r
}

// A list of supported remote control commands, comma delimited
func (r ApiPostSessionsCapabilitiesRequest) SupportedCommands(supportedCommands string) ApiPostSessionsCapabilitiesRequest {
	r.supportedCommands = &supportedCommands
	return r
}

// Determines whether media can be played remotely.
func (r ApiPostSessionsCapabilitiesRequest) SupportsMediaControl(supportsMediaControl bool) ApiPostSessionsCapabilitiesRequest {
	r.supportsMediaControl = &supportsMediaControl
	return r
}

// Determines whether sync is supported.
func (r ApiPostSessionsCapabilitiesRequest) SupportsSync(supportsSync bool) ApiPostSessionsCapabilitiesRequest {
	r.supportsSync = &supportsSync
	return r
}

// Determines whether the device supports a unique identifier.
func (r ApiPostSessionsCapabilitiesRequest) SupportsPersistentIdentifier(supportsPersistentIdentifier bool) ApiPostSessionsCapabilitiesRequest {
	r.supportsPersistentIdentifier = &supportsPersistentIdentifier
	return r
}

func (r ApiPostSessionsCapabilitiesRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostSessionsCapabilitiesExecute(r)
}

/*
PostSessionsCapabilities Updates capabilities for a device

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostSessionsCapabilitiesRequest
*/
func (a *SessionsServiceAPIService) PostSessionsCapabilities(ctx context.Context) ApiPostSessionsCapabilitiesRequest {
	return ApiPostSessionsCapabilitiesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SessionsServiceAPIService) PostSessionsCapabilitiesExecute(r ApiPostSessionsCapabilitiesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SessionsServiceAPIService.PostSessionsCapabilities")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Sessions/Capabilities"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.id == nil {
		return nil, reportError("id is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "Id", r.id, "form", "")
	if r.playableMediaTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "PlayableMediaTypes", r.playableMediaTypes, "form", "")
	}
	if r.supportedCommands != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SupportedCommands", r.supportedCommands, "form", "")
	}
	if r.supportsMediaControl != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SupportsMediaControl", r.supportsMediaControl, "form", "")
	}
	if r.supportsSync != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SupportsSync", r.supportsSync, "form", "")
	}
	if r.supportsPersistentIdentifier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SupportsPersistentIdentifier", r.supportsPersistentIdentifier, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostSessionsCapabilitiesFullRequest struct {
	ctx context.Context
	ApiService SessionsServiceAPI
	id *string
	clientCapabilities *ClientCapabilities
}

// Session Id
func (r ApiPostSessionsCapabilitiesFullRequest) Id(id string) ApiPostSessionsCapabilitiesFullRequest {
	r.id = &id
	return r
}

// ClientCapabilities: 
func (r ApiPostSessionsCapabilitiesFullRequest) ClientCapabilities(clientCapabilities ClientCapabilities) ApiPostSessionsCapabilitiesFullRequest {
	r.clientCapabilities = &clientCapabilities
	return r
}

func (r ApiPostSessionsCapabilitiesFullRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostSessionsCapabilitiesFullExecute(r)
}

/*
PostSessionsCapabilitiesFull Updates capabilities for a device

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostSessionsCapabilitiesFullRequest
*/
func (a *SessionsServiceAPIService) PostSessionsCapabilitiesFull(ctx context.Context) ApiPostSessionsCapabilitiesFullRequest {
	return ApiPostSessionsCapabilitiesFullRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SessionsServiceAPIService) PostSessionsCapabilitiesFullExecute(r ApiPostSessionsCapabilitiesFullRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SessionsServiceAPIService.PostSessionsCapabilitiesFull")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Sessions/Capabilities/Full"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.id == nil {
		return nil, reportError("id is required and must be specified")
	}
	if r.clientCapabilities == nil {
		return nil, reportError("clientCapabilities is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "Id", r.id, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.clientCapabilities
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostSessionsLogoutRequest struct {
	ctx context.Context
	ApiService SessionsServiceAPI
}

func (r ApiPostSessionsLogoutRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostSessionsLogoutExecute(r)
}

/*
PostSessionsLogout Reports that a session has ended

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostSessionsLogoutRequest
*/
func (a *SessionsServiceAPIService) PostSessionsLogout(ctx context.Context) ApiPostSessionsLogoutRequest {
	return ApiPostSessionsLogoutRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SessionsServiceAPIService) PostSessionsLogoutExecute(r ApiPostSessionsLogoutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SessionsServiceAPIService.PostSessionsLogout")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Sessions/Logout"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
