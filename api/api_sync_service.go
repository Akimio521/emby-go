/*
Emby Server API

Explore the Emby Server API

API version: 4.1.1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package api

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


type SyncServiceAPI interface {

	/*
	DeleteSyncByTargetidItems Cancels items from a sync target

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param targetId TargetId
	@return ApiDeleteSyncByTargetidItemsRequest
	*/
	DeleteSyncByTargetidItems(ctx context.Context, targetId string) ApiDeleteSyncByTargetidItemsRequest

	// DeleteSyncByTargetidItemsExecute executes the request
	DeleteSyncByTargetidItemsExecute(r ApiDeleteSyncByTargetidItemsRequest) (*http.Response, error)

	/*
	DeleteSyncJobitemsById Cancels a sync job item

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Id
	@return ApiDeleteSyncJobitemsByIdRequest
	*/
	DeleteSyncJobitemsById(ctx context.Context, id string) ApiDeleteSyncJobitemsByIdRequest

	// DeleteSyncJobitemsByIdExecute executes the request
	DeleteSyncJobitemsByIdExecute(r ApiDeleteSyncJobitemsByIdRequest) (*http.Response, error)

	/*
	DeleteSyncJobsById Cancels a sync job.

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Id
	@return ApiDeleteSyncJobsByIdRequest
	*/
	DeleteSyncJobsById(ctx context.Context, id string) ApiDeleteSyncJobsByIdRequest

	// DeleteSyncJobsByIdExecute executes the request
	DeleteSyncJobsByIdExecute(r ApiDeleteSyncJobsByIdRequest) (*http.Response, error)

	/*
	GetSyncItemsReady Gets ready to download sync items.

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetSyncItemsReadyRequest
	*/
	GetSyncItemsReady(ctx context.Context) ApiGetSyncItemsReadyRequest

	// GetSyncItemsReadyExecute executes the request
	//  @return []SyncModelSyncedItem
	GetSyncItemsReadyExecute(r ApiGetSyncItemsReadyRequest) ([]SyncModelSyncedItem, *http.Response, error)

	/*
	GetSyncJobitems Gets sync job items.

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetSyncJobitemsRequest
	*/
	GetSyncJobitems(ctx context.Context) ApiGetSyncJobitemsRequest

	// GetSyncJobitemsExecute executes the request
	//  @return QueryResultSyncModelSyncJobItem
	GetSyncJobitemsExecute(r ApiGetSyncJobitemsRequest) (*QueryResultSyncModelSyncJobItem, *http.Response, error)

	/*
	GetSyncJobitemsByIdAdditionalfiles Gets a sync job item file

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Id
	@return ApiGetSyncJobitemsByIdAdditionalfilesRequest
	*/
	GetSyncJobitemsByIdAdditionalfiles(ctx context.Context, id string) ApiGetSyncJobitemsByIdAdditionalfilesRequest

	// GetSyncJobitemsByIdAdditionalfilesExecute executes the request
	GetSyncJobitemsByIdAdditionalfilesExecute(r ApiGetSyncJobitemsByIdAdditionalfilesRequest) (*http.Response, error)

	/*
	GetSyncJobitemsByIdFile Gets a sync job item file

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Id
	@return ApiGetSyncJobitemsByIdFileRequest
	*/
	GetSyncJobitemsByIdFile(ctx context.Context, id string) ApiGetSyncJobitemsByIdFileRequest

	// GetSyncJobitemsByIdFileExecute executes the request
	GetSyncJobitemsByIdFileExecute(r ApiGetSyncJobitemsByIdFileRequest) (*http.Response, error)

	/*
	GetSyncJobs Gets sync jobs.

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetSyncJobsRequest
	*/
	GetSyncJobs(ctx context.Context) ApiGetSyncJobsRequest

	// GetSyncJobsExecute executes the request
	//  @return QueryResultSyncSyncJob
	GetSyncJobsExecute(r ApiGetSyncJobsRequest) (*QueryResultSyncSyncJob, *http.Response, error)

	/*
	GetSyncJobsById Gets a sync job.

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Id
	@return ApiGetSyncJobsByIdRequest
	*/
	GetSyncJobsById(ctx context.Context, id string) ApiGetSyncJobsByIdRequest

	// GetSyncJobsByIdExecute executes the request
	//  @return SyncSyncJob
	GetSyncJobsByIdExecute(r ApiGetSyncJobsByIdRequest) (*SyncSyncJob, *http.Response, error)

	/*
	GetSyncOptions Gets a list of available sync targets.

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetSyncOptionsRequest
	*/
	GetSyncOptions(ctx context.Context) ApiGetSyncOptionsRequest

	// GetSyncOptionsExecute executes the request
	//  @return SyncModelSyncDialogOptions
	GetSyncOptionsExecute(r ApiGetSyncOptionsRequest) (*SyncModelSyncDialogOptions, *http.Response, error)

	/*
	GetSyncTargets Gets a list of available sync targets.

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetSyncTargetsRequest
	*/
	GetSyncTargets(ctx context.Context) ApiGetSyncTargetsRequest

	// GetSyncTargetsExecute executes the request
	//  @return []SyncSyncTarget
	GetSyncTargetsExecute(r ApiGetSyncTargetsRequest) ([]SyncSyncTarget, *http.Response, error)

	/*
	PostSyncByItemidStatus Gets sync status for an item.

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param itemId
	@return ApiPostSyncByItemidStatusRequest
	*/
	PostSyncByItemidStatus(ctx context.Context, itemId string) ApiPostSyncByItemidStatusRequest

	// PostSyncByItemidStatusExecute executes the request
	PostSyncByItemidStatusExecute(r ApiPostSyncByItemidStatusRequest) (*http.Response, error)

	/*
	PostSyncData Syncs data between device and server

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostSyncDataRequest
	*/
	PostSyncData(ctx context.Context) ApiPostSyncDataRequest

	// PostSyncDataExecute executes the request
	//  @return SyncModelSyncDataResponse
	PostSyncDataExecute(r ApiPostSyncDataRequest) (*SyncModelSyncDataResponse, *http.Response, error)

	/*
	PostSyncItemsCancel Cancels items from a sync target

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostSyncItemsCancelRequest
	*/
	PostSyncItemsCancel(ctx context.Context) ApiPostSyncItemsCancelRequest

	// PostSyncItemsCancelExecute executes the request
	PostSyncItemsCancelExecute(r ApiPostSyncItemsCancelRequest) (*http.Response, error)

	/*
	PostSyncJobitemsByIdEnable Enables a cancelled or queued sync job item

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Id
	@return ApiPostSyncJobitemsByIdEnableRequest
	*/
	PostSyncJobitemsByIdEnable(ctx context.Context, id string) ApiPostSyncJobitemsByIdEnableRequest

	// PostSyncJobitemsByIdEnableExecute executes the request
	PostSyncJobitemsByIdEnableExecute(r ApiPostSyncJobitemsByIdEnableRequest) (*http.Response, error)

	/*
	PostSyncJobitemsByIdMarkforremoval Marks a job item for removal

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Id
	@return ApiPostSyncJobitemsByIdMarkforremovalRequest
	*/
	PostSyncJobitemsByIdMarkforremoval(ctx context.Context, id string) ApiPostSyncJobitemsByIdMarkforremovalRequest

	// PostSyncJobitemsByIdMarkforremovalExecute executes the request
	PostSyncJobitemsByIdMarkforremovalExecute(r ApiPostSyncJobitemsByIdMarkforremovalRequest) (*http.Response, error)

	/*
	PostSyncJobitemsByIdTransferred Reports that a sync job item has successfully been transferred.

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Id
	@return ApiPostSyncJobitemsByIdTransferredRequest
	*/
	PostSyncJobitemsByIdTransferred(ctx context.Context, id string) ApiPostSyncJobitemsByIdTransferredRequest

	// PostSyncJobitemsByIdTransferredExecute executes the request
	PostSyncJobitemsByIdTransferredExecute(r ApiPostSyncJobitemsByIdTransferredRequest) (*http.Response, error)

	/*
	PostSyncJobitemsByIdUnmarkforremoval Unmarks a job item for removal

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Id
	@return ApiPostSyncJobitemsByIdUnmarkforremovalRequest
	*/
	PostSyncJobitemsByIdUnmarkforremoval(ctx context.Context, id string) ApiPostSyncJobitemsByIdUnmarkforremovalRequest

	// PostSyncJobitemsByIdUnmarkforremovalExecute executes the request
	PostSyncJobitemsByIdUnmarkforremovalExecute(r ApiPostSyncJobitemsByIdUnmarkforremovalRequest) (*http.Response, error)

	/*
	PostSyncJobs Gets sync jobs.

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostSyncJobsRequest
	*/
	PostSyncJobs(ctx context.Context) ApiPostSyncJobsRequest

	// PostSyncJobsExecute executes the request
	//  @return SyncModelSyncJobCreationResult
	PostSyncJobsExecute(r ApiPostSyncJobsRequest) (*SyncModelSyncJobCreationResult, *http.Response, error)

	/*
	PostSyncJobsById Updates a sync job.

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiPostSyncJobsByIdRequest
	*/
	PostSyncJobsById(ctx context.Context, id int64) ApiPostSyncJobsByIdRequest

	// PostSyncJobsByIdExecute executes the request
	PostSyncJobsByIdExecute(r ApiPostSyncJobsByIdRequest) (*http.Response, error)

	/*
	PostSyncOfflineactions Reports an action that occurred while offline.

	Requires authentication as user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostSyncOfflineactionsRequest
	*/
	PostSyncOfflineactions(ctx context.Context) ApiPostSyncOfflineactionsRequest

	// PostSyncOfflineactionsExecute executes the request
	PostSyncOfflineactionsExecute(r ApiPostSyncOfflineactionsRequest) (*http.Response, error)
}

// SyncServiceAPIService SyncServiceAPI service
type SyncServiceAPIService service

type ApiDeleteSyncByTargetidItemsRequest struct {
	ctx context.Context
	ApiService SyncServiceAPI
	targetId string
}

func (r ApiDeleteSyncByTargetidItemsRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteSyncByTargetidItemsExecute(r)
}

/*
DeleteSyncByTargetidItems Cancels items from a sync target

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param targetId TargetId
 @return ApiDeleteSyncByTargetidItemsRequest
*/
func (a *SyncServiceAPIService) DeleteSyncByTargetidItems(ctx context.Context, targetId string) ApiDeleteSyncByTargetidItemsRequest {
	return ApiDeleteSyncByTargetidItemsRequest{
		ApiService: a,
		ctx: ctx,
		targetId: targetId,
	}
}

// Execute executes the request
func (a *SyncServiceAPIService) DeleteSyncByTargetidItemsExecute(r ApiDeleteSyncByTargetidItemsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SyncServiceAPIService.DeleteSyncByTargetidItems")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Sync/{TargetId}/Items"
	localVarPath = strings.Replace(localVarPath, "{"+"TargetId"+"}", url.PathEscape(parameterValueToString(r.targetId, "targetId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteSyncJobitemsByIdRequest struct {
	ctx context.Context
	ApiService SyncServiceAPI
	id string
}

func (r ApiDeleteSyncJobitemsByIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteSyncJobitemsByIdExecute(r)
}

/*
DeleteSyncJobitemsById Cancels a sync job item

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Id
 @return ApiDeleteSyncJobitemsByIdRequest
*/
func (a *SyncServiceAPIService) DeleteSyncJobitemsById(ctx context.Context, id string) ApiDeleteSyncJobitemsByIdRequest {
	return ApiDeleteSyncJobitemsByIdRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *SyncServiceAPIService) DeleteSyncJobitemsByIdExecute(r ApiDeleteSyncJobitemsByIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SyncServiceAPIService.DeleteSyncJobitemsById")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Sync/JobItems/{Id}"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteSyncJobsByIdRequest struct {
	ctx context.Context
	ApiService SyncServiceAPI
	id string
}

func (r ApiDeleteSyncJobsByIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteSyncJobsByIdExecute(r)
}

/*
DeleteSyncJobsById Cancels a sync job.

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Id
 @return ApiDeleteSyncJobsByIdRequest
*/
func (a *SyncServiceAPIService) DeleteSyncJobsById(ctx context.Context, id string) ApiDeleteSyncJobsByIdRequest {
	return ApiDeleteSyncJobsByIdRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *SyncServiceAPIService) DeleteSyncJobsByIdExecute(r ApiDeleteSyncJobsByIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SyncServiceAPIService.DeleteSyncJobsById")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Sync/Jobs/{Id}"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetSyncItemsReadyRequest struct {
	ctx context.Context
	ApiService SyncServiceAPI
	targetId *string
}

// TargetId
func (r ApiGetSyncItemsReadyRequest) TargetId(targetId string) ApiGetSyncItemsReadyRequest {
	r.targetId = &targetId
	return r
}

func (r ApiGetSyncItemsReadyRequest) Execute() ([]SyncModelSyncedItem, *http.Response, error) {
	return r.ApiService.GetSyncItemsReadyExecute(r)
}

/*
GetSyncItemsReady Gets ready to download sync items.

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSyncItemsReadyRequest
*/
func (a *SyncServiceAPIService) GetSyncItemsReady(ctx context.Context) ApiGetSyncItemsReadyRequest {
	return ApiGetSyncItemsReadyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []SyncModelSyncedItem
func (a *SyncServiceAPIService) GetSyncItemsReadyExecute(r ApiGetSyncItemsReadyRequest) ([]SyncModelSyncedItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SyncModelSyncedItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SyncServiceAPIService.GetSyncItemsReady")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Sync/Items/Ready"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.targetId == nil {
		return localVarReturnValue, nil, reportError("targetId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "TargetId", r.targetId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSyncJobitemsRequest struct {
	ctx context.Context
	ApiService SyncServiceAPI
}

func (r ApiGetSyncJobitemsRequest) Execute() (*QueryResultSyncModelSyncJobItem, *http.Response, error) {
	return r.ApiService.GetSyncJobitemsExecute(r)
}

/*
GetSyncJobitems Gets sync job items.

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSyncJobitemsRequest
*/
func (a *SyncServiceAPIService) GetSyncJobitems(ctx context.Context) ApiGetSyncJobitemsRequest {
	return ApiGetSyncJobitemsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return QueryResultSyncModelSyncJobItem
func (a *SyncServiceAPIService) GetSyncJobitemsExecute(r ApiGetSyncJobitemsRequest) (*QueryResultSyncModelSyncJobItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QueryResultSyncModelSyncJobItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SyncServiceAPIService.GetSyncJobitems")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Sync/JobItems"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSyncJobitemsByIdAdditionalfilesRequest struct {
	ctx context.Context
	ApiService SyncServiceAPI
	id string
	name *string
}

// Name
func (r ApiGetSyncJobitemsByIdAdditionalfilesRequest) Name(name string) ApiGetSyncJobitemsByIdAdditionalfilesRequest {
	r.name = &name
	return r
}

func (r ApiGetSyncJobitemsByIdAdditionalfilesRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetSyncJobitemsByIdAdditionalfilesExecute(r)
}

/*
GetSyncJobitemsByIdAdditionalfiles Gets a sync job item file

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Id
 @return ApiGetSyncJobitemsByIdAdditionalfilesRequest
*/
func (a *SyncServiceAPIService) GetSyncJobitemsByIdAdditionalfiles(ctx context.Context, id string) ApiGetSyncJobitemsByIdAdditionalfilesRequest {
	return ApiGetSyncJobitemsByIdAdditionalfilesRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *SyncServiceAPIService) GetSyncJobitemsByIdAdditionalfilesExecute(r ApiGetSyncJobitemsByIdAdditionalfilesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SyncServiceAPIService.GetSyncJobitemsByIdAdditionalfiles")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Sync/JobItems/{Id}/AdditionalFiles"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.name == nil {
		return nil, reportError("name is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "Name", r.name, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetSyncJobitemsByIdFileRequest struct {
	ctx context.Context
	ApiService SyncServiceAPI
	id string
}

func (r ApiGetSyncJobitemsByIdFileRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetSyncJobitemsByIdFileExecute(r)
}

/*
GetSyncJobitemsByIdFile Gets a sync job item file

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Id
 @return ApiGetSyncJobitemsByIdFileRequest
*/
func (a *SyncServiceAPIService) GetSyncJobitemsByIdFile(ctx context.Context, id string) ApiGetSyncJobitemsByIdFileRequest {
	return ApiGetSyncJobitemsByIdFileRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *SyncServiceAPIService) GetSyncJobitemsByIdFileExecute(r ApiGetSyncJobitemsByIdFileRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SyncServiceAPIService.GetSyncJobitemsByIdFile")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Sync/JobItems/{Id}/File"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetSyncJobsRequest struct {
	ctx context.Context
	ApiService SyncServiceAPI
}

func (r ApiGetSyncJobsRequest) Execute() (*QueryResultSyncSyncJob, *http.Response, error) {
	return r.ApiService.GetSyncJobsExecute(r)
}

/*
GetSyncJobs Gets sync jobs.

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSyncJobsRequest
*/
func (a *SyncServiceAPIService) GetSyncJobs(ctx context.Context) ApiGetSyncJobsRequest {
	return ApiGetSyncJobsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return QueryResultSyncSyncJob
func (a *SyncServiceAPIService) GetSyncJobsExecute(r ApiGetSyncJobsRequest) (*QueryResultSyncSyncJob, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QueryResultSyncSyncJob
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SyncServiceAPIService.GetSyncJobs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Sync/Jobs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSyncJobsByIdRequest struct {
	ctx context.Context
	ApiService SyncServiceAPI
	id string
}

func (r ApiGetSyncJobsByIdRequest) Execute() (*SyncSyncJob, *http.Response, error) {
	return r.ApiService.GetSyncJobsByIdExecute(r)
}

/*
GetSyncJobsById Gets a sync job.

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Id
 @return ApiGetSyncJobsByIdRequest
*/
func (a *SyncServiceAPIService) GetSyncJobsById(ctx context.Context, id string) ApiGetSyncJobsByIdRequest {
	return ApiGetSyncJobsByIdRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return SyncSyncJob
func (a *SyncServiceAPIService) GetSyncJobsByIdExecute(r ApiGetSyncJobsByIdRequest) (*SyncSyncJob, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SyncSyncJob
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SyncServiceAPIService.GetSyncJobsById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Sync/Jobs/{Id}"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSyncOptionsRequest struct {
	ctx context.Context
	ApiService SyncServiceAPI
	userId *string
	itemIds *string
	parentId *string
	targetId *string
	category *string
}

// UserId
func (r ApiGetSyncOptionsRequest) UserId(userId string) ApiGetSyncOptionsRequest {
	r.userId = &userId
	return r
}

// ItemIds
func (r ApiGetSyncOptionsRequest) ItemIds(itemIds string) ApiGetSyncOptionsRequest {
	r.itemIds = &itemIds
	return r
}

// ParentId
func (r ApiGetSyncOptionsRequest) ParentId(parentId string) ApiGetSyncOptionsRequest {
	r.parentId = &parentId
	return r
}

// TargetId
func (r ApiGetSyncOptionsRequest) TargetId(targetId string) ApiGetSyncOptionsRequest {
	r.targetId = &targetId
	return r
}

// Category
func (r ApiGetSyncOptionsRequest) Category(category string) ApiGetSyncOptionsRequest {
	r.category = &category
	return r
}

func (r ApiGetSyncOptionsRequest) Execute() (*SyncModelSyncDialogOptions, *http.Response, error) {
	return r.ApiService.GetSyncOptionsExecute(r)
}

/*
GetSyncOptions Gets a list of available sync targets.

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSyncOptionsRequest
*/
func (a *SyncServiceAPIService) GetSyncOptions(ctx context.Context) ApiGetSyncOptionsRequest {
	return ApiGetSyncOptionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SyncModelSyncDialogOptions
func (a *SyncServiceAPIService) GetSyncOptionsExecute(r ApiGetSyncOptionsRequest) (*SyncModelSyncDialogOptions, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SyncModelSyncDialogOptions
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SyncServiceAPIService.GetSyncOptions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Sync/Options"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.userId == nil {
		return localVarReturnValue, nil, reportError("userId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "UserId", r.userId, "form", "")
	if r.itemIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ItemIds", r.itemIds, "form", "")
	}
	if r.parentId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ParentId", r.parentId, "form", "")
	}
	if r.targetId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "TargetId", r.targetId, "form", "")
	}
	if r.category != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Category", r.category, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSyncTargetsRequest struct {
	ctx context.Context
	ApiService SyncServiceAPI
	userId *string
}

// UserId
func (r ApiGetSyncTargetsRequest) UserId(userId string) ApiGetSyncTargetsRequest {
	r.userId = &userId
	return r
}

func (r ApiGetSyncTargetsRequest) Execute() ([]SyncSyncTarget, *http.Response, error) {
	return r.ApiService.GetSyncTargetsExecute(r)
}

/*
GetSyncTargets Gets a list of available sync targets.

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSyncTargetsRequest
*/
func (a *SyncServiceAPIService) GetSyncTargets(ctx context.Context) ApiGetSyncTargetsRequest {
	return ApiGetSyncTargetsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []SyncSyncTarget
func (a *SyncServiceAPIService) GetSyncTargetsExecute(r ApiGetSyncTargetsRequest) ([]SyncSyncTarget, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SyncSyncTarget
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SyncServiceAPIService.GetSyncTargets")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Sync/Targets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.userId == nil {
		return localVarReturnValue, nil, reportError("userId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "UserId", r.userId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostSyncByItemidStatusRequest struct {
	ctx context.Context
	ApiService SyncServiceAPI
	itemId string
	syncModelSyncedItemProgress *SyncModelSyncedItemProgress
}

// SyncedItemProgress: 
func (r ApiPostSyncByItemidStatusRequest) SyncModelSyncedItemProgress(syncModelSyncedItemProgress SyncModelSyncedItemProgress) ApiPostSyncByItemidStatusRequest {
	r.syncModelSyncedItemProgress = &syncModelSyncedItemProgress
	return r
}

func (r ApiPostSyncByItemidStatusRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostSyncByItemidStatusExecute(r)
}

/*
PostSyncByItemidStatus Gets sync status for an item.

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param itemId
 @return ApiPostSyncByItemidStatusRequest
*/
func (a *SyncServiceAPIService) PostSyncByItemidStatus(ctx context.Context, itemId string) ApiPostSyncByItemidStatusRequest {
	return ApiPostSyncByItemidStatusRequest{
		ApiService: a,
		ctx: ctx,
		itemId: itemId,
	}
}

// Execute executes the request
func (a *SyncServiceAPIService) PostSyncByItemidStatusExecute(r ApiPostSyncByItemidStatusRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SyncServiceAPIService.PostSyncByItemidStatus")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Sync/{ItemId}/Status"
	localVarPath = strings.Replace(localVarPath, "{"+"ItemId"+"}", url.PathEscape(parameterValueToString(r.itemId, "itemId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.syncModelSyncedItemProgress == nil {
		return nil, reportError("syncModelSyncedItemProgress is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.syncModelSyncedItemProgress
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostSyncDataRequest struct {
	ctx context.Context
	ApiService SyncServiceAPI
	syncModelSyncDataRequest *SyncModelSyncDataRequest
}

// SyncDataRequest: 
func (r ApiPostSyncDataRequest) SyncModelSyncDataRequest(syncModelSyncDataRequest SyncModelSyncDataRequest) ApiPostSyncDataRequest {
	r.syncModelSyncDataRequest = &syncModelSyncDataRequest
	return r
}

func (r ApiPostSyncDataRequest) Execute() (*SyncModelSyncDataResponse, *http.Response, error) {
	return r.ApiService.PostSyncDataExecute(r)
}

/*
PostSyncData Syncs data between device and server

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostSyncDataRequest
*/
func (a *SyncServiceAPIService) PostSyncData(ctx context.Context) ApiPostSyncDataRequest {
	return ApiPostSyncDataRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SyncModelSyncDataResponse
func (a *SyncServiceAPIService) PostSyncDataExecute(r ApiPostSyncDataRequest) (*SyncModelSyncDataResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SyncModelSyncDataResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SyncServiceAPIService.PostSyncData")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Sync/Data"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.syncModelSyncDataRequest == nil {
		return localVarReturnValue, nil, reportError("syncModelSyncDataRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.syncModelSyncDataRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostSyncItemsCancelRequest struct {
	ctx context.Context
	ApiService SyncServiceAPI
	itemIds *string
}

// ItemIds
func (r ApiPostSyncItemsCancelRequest) ItemIds(itemIds string) ApiPostSyncItemsCancelRequest {
	r.itemIds = &itemIds
	return r
}

func (r ApiPostSyncItemsCancelRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostSyncItemsCancelExecute(r)
}

/*
PostSyncItemsCancel Cancels items from a sync target

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostSyncItemsCancelRequest
*/
func (a *SyncServiceAPIService) PostSyncItemsCancel(ctx context.Context) ApiPostSyncItemsCancelRequest {
	return ApiPostSyncItemsCancelRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SyncServiceAPIService) PostSyncItemsCancelExecute(r ApiPostSyncItemsCancelRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SyncServiceAPIService.PostSyncItemsCancel")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Sync/Items/Cancel"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.itemIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ItemIds", r.itemIds, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostSyncJobitemsByIdEnableRequest struct {
	ctx context.Context
	ApiService SyncServiceAPI
	id string
}

func (r ApiPostSyncJobitemsByIdEnableRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostSyncJobitemsByIdEnableExecute(r)
}

/*
PostSyncJobitemsByIdEnable Enables a cancelled or queued sync job item

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Id
 @return ApiPostSyncJobitemsByIdEnableRequest
*/
func (a *SyncServiceAPIService) PostSyncJobitemsByIdEnable(ctx context.Context, id string) ApiPostSyncJobitemsByIdEnableRequest {
	return ApiPostSyncJobitemsByIdEnableRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *SyncServiceAPIService) PostSyncJobitemsByIdEnableExecute(r ApiPostSyncJobitemsByIdEnableRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SyncServiceAPIService.PostSyncJobitemsByIdEnable")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Sync/JobItems/{Id}/Enable"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostSyncJobitemsByIdMarkforremovalRequest struct {
	ctx context.Context
	ApiService SyncServiceAPI
	id string
}

func (r ApiPostSyncJobitemsByIdMarkforremovalRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostSyncJobitemsByIdMarkforremovalExecute(r)
}

/*
PostSyncJobitemsByIdMarkforremoval Marks a job item for removal

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Id
 @return ApiPostSyncJobitemsByIdMarkforremovalRequest
*/
func (a *SyncServiceAPIService) PostSyncJobitemsByIdMarkforremoval(ctx context.Context, id string) ApiPostSyncJobitemsByIdMarkforremovalRequest {
	return ApiPostSyncJobitemsByIdMarkforremovalRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *SyncServiceAPIService) PostSyncJobitemsByIdMarkforremovalExecute(r ApiPostSyncJobitemsByIdMarkforremovalRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SyncServiceAPIService.PostSyncJobitemsByIdMarkforremoval")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Sync/JobItems/{Id}/MarkForRemoval"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostSyncJobitemsByIdTransferredRequest struct {
	ctx context.Context
	ApiService SyncServiceAPI
	id string
}

func (r ApiPostSyncJobitemsByIdTransferredRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostSyncJobitemsByIdTransferredExecute(r)
}

/*
PostSyncJobitemsByIdTransferred Reports that a sync job item has successfully been transferred.

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Id
 @return ApiPostSyncJobitemsByIdTransferredRequest
*/
func (a *SyncServiceAPIService) PostSyncJobitemsByIdTransferred(ctx context.Context, id string) ApiPostSyncJobitemsByIdTransferredRequest {
	return ApiPostSyncJobitemsByIdTransferredRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *SyncServiceAPIService) PostSyncJobitemsByIdTransferredExecute(r ApiPostSyncJobitemsByIdTransferredRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SyncServiceAPIService.PostSyncJobitemsByIdTransferred")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Sync/JobItems/{Id}/Transferred"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostSyncJobitemsByIdUnmarkforremovalRequest struct {
	ctx context.Context
	ApiService SyncServiceAPI
	id string
}

func (r ApiPostSyncJobitemsByIdUnmarkforremovalRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostSyncJobitemsByIdUnmarkforremovalExecute(r)
}

/*
PostSyncJobitemsByIdUnmarkforremoval Unmarks a job item for removal

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Id
 @return ApiPostSyncJobitemsByIdUnmarkforremovalRequest
*/
func (a *SyncServiceAPIService) PostSyncJobitemsByIdUnmarkforremoval(ctx context.Context, id string) ApiPostSyncJobitemsByIdUnmarkforremovalRequest {
	return ApiPostSyncJobitemsByIdUnmarkforremovalRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *SyncServiceAPIService) PostSyncJobitemsByIdUnmarkforremovalExecute(r ApiPostSyncJobitemsByIdUnmarkforremovalRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SyncServiceAPIService.PostSyncJobitemsByIdUnmarkforremoval")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Sync/JobItems/{Id}/UnmarkForRemoval"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostSyncJobsRequest struct {
	ctx context.Context
	ApiService SyncServiceAPI
	syncModelSyncJobRequest *SyncModelSyncJobRequest
}

// SyncJobRequest: 
func (r ApiPostSyncJobsRequest) SyncModelSyncJobRequest(syncModelSyncJobRequest SyncModelSyncJobRequest) ApiPostSyncJobsRequest {
	r.syncModelSyncJobRequest = &syncModelSyncJobRequest
	return r
}

func (r ApiPostSyncJobsRequest) Execute() (*SyncModelSyncJobCreationResult, *http.Response, error) {
	return r.ApiService.PostSyncJobsExecute(r)
}

/*
PostSyncJobs Gets sync jobs.

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostSyncJobsRequest
*/
func (a *SyncServiceAPIService) PostSyncJobs(ctx context.Context) ApiPostSyncJobsRequest {
	return ApiPostSyncJobsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SyncModelSyncJobCreationResult
func (a *SyncServiceAPIService) PostSyncJobsExecute(r ApiPostSyncJobsRequest) (*SyncModelSyncJobCreationResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SyncModelSyncJobCreationResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SyncServiceAPIService.PostSyncJobs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Sync/Jobs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.syncModelSyncJobRequest == nil {
		return localVarReturnValue, nil, reportError("syncModelSyncJobRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.syncModelSyncJobRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostSyncJobsByIdRequest struct {
	ctx context.Context
	ApiService SyncServiceAPI
	id int64
	syncSyncJob *SyncSyncJob
}

// SyncJob: 
func (r ApiPostSyncJobsByIdRequest) SyncSyncJob(syncSyncJob SyncSyncJob) ApiPostSyncJobsByIdRequest {
	r.syncSyncJob = &syncSyncJob
	return r
}

func (r ApiPostSyncJobsByIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostSyncJobsByIdExecute(r)
}

/*
PostSyncJobsById Updates a sync job.

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiPostSyncJobsByIdRequest
*/
func (a *SyncServiceAPIService) PostSyncJobsById(ctx context.Context, id int64) ApiPostSyncJobsByIdRequest {
	return ApiPostSyncJobsByIdRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *SyncServiceAPIService) PostSyncJobsByIdExecute(r ApiPostSyncJobsByIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SyncServiceAPIService.PostSyncJobsById")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Sync/Jobs/{Id}"
	localVarPath = strings.Replace(localVarPath, "{"+"Id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.syncSyncJob == nil {
		return nil, reportError("syncSyncJob is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.syncSyncJob
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostSyncOfflineactionsRequest struct {
	ctx context.Context
	ApiService SyncServiceAPI
	usersUserAction *[]UsersUserAction
}

// List&#x60;1: 
func (r ApiPostSyncOfflineactionsRequest) UsersUserAction(usersUserAction []UsersUserAction) ApiPostSyncOfflineactionsRequest {
	r.usersUserAction = &usersUserAction
	return r
}

func (r ApiPostSyncOfflineactionsRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostSyncOfflineactionsExecute(r)
}

/*
PostSyncOfflineactions Reports an action that occurred while offline.

Requires authentication as user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostSyncOfflineactionsRequest
*/
func (a *SyncServiceAPIService) PostSyncOfflineactions(ctx context.Context) ApiPostSyncOfflineactionsRequest {
	return ApiPostSyncOfflineactionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SyncServiceAPIService) PostSyncOfflineactionsExecute(r ApiPostSyncOfflineactionsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SyncServiceAPIService.PostSyncOfflineactions")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Sync/OfflineActions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.usersUserAction == nil {
		return nil, reportError("usersUserAction is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.usersUserAction
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikeyauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
